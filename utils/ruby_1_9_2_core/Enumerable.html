<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- RD version: 0.9.5  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>Module: Enumerable (Ruby 1.9.2) </title>
  <!-- raw_prefix  = '.'   -->
  <link rel="stylesheet" href="css/obf.css" >

  <script src="js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
</head>

<body id="top" class="module">
<div id='actionbar' >
<div class='wrapper'>
<ul class='grids g0'>
  <li class='grid-2' ><a href='/' target='_top' >Home</a></li>
  <li class='grid-2' ><a href='/core' target='_top' >Core</a></li>
  <li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib</a></li>
  <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
  <li class='grid-7 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="index.html">Home</a>
          <a href="index.html#classes">Classes</a>
          <a href="index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="enum_c.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="enum.c">enum.c</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-i-all-3F">#all?</a></li>
          
          <li><a href="#method-i-any-3F">#any?</a></li>
          
          <li><a href="#method-i-chunk">#chunk</a></li>
          
          <li><a href="#method-i-collect">#collect</a></li>
          
          <li><a href="#method-i-collect_concat">#collect_concat</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-cycle">#cycle</a></li>
          
          <li><a href="#method-i-detect">#detect</a></li>
          
          <li><a href="#method-i-drop">#drop</a></li>
          
          <li><a href="#method-i-drop_while">#drop_while</a></li>
          
          <li><a href="#method-i-each_cons">#each_cons</a></li>
          
          <li><a href="#method-i-each_entry">#each_entry</a></li>
          
          <li><a href="#method-i-each_slice">#each_slice</a></li>
          
          <li><a href="#method-i-each_with_index">#each_with_index</a></li>
          
          <li><a href="#method-i-each_with_object">#each_with_object</a></li>
          
          <li><a href="#method-i-entries">#entries</a></li>
          
          <li><a href="#method-i-find">#find</a></li>
          
          <li><a href="#method-i-find_all">#find_all</a></li>
          
          <li><a href="#method-i-find_index">#find_index</a></li>
          
          <li><a href="#method-i-first">#first</a></li>
          
          <li><a href="#method-i-flat_map">#flat_map</a></li>
          
          <li><a href="#method-i-grep">#grep</a></li>
          
          <li><a href="#method-i-group_by">#group_by</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-inject">#inject</a></li>
          
          <li><a href="#method-i-map">#map</a></li>
          
          <li><a href="#method-i-max">#max</a></li>
          
          <li><a href="#method-i-max_by">#max_by</a></li>
          
          <li><a href="#method-i-member-3F">#member?</a></li>
          
          <li><a href="#method-i-min">#min</a></li>
          
          <li><a href="#method-i-min_by">#min_by</a></li>
          
          <li><a href="#method-i-minmax">#minmax</a></li>
          
          <li><a href="#method-i-minmax_by">#minmax_by</a></li>
          
          <li><a href="#method-i-none-3F">#none?</a></li>
          
          <li><a href="#method-i-one-3F">#one?</a></li>
          
          <li><a href="#method-i-partition">#partition</a></li>
          
          <li><a href="#method-i-reduce">#reduce</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reverse_each">#reverse_each</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-slice_before">#slice_before</a></li>
          
          <li><a href="#method-i-sort">#sort</a></li>
          
          <li><a href="#method-i-sort_by">#sort_by</a></li>
          
          <li><a href="#method-i-take">#take</a></li>
          
          <li><a href="#method-i-take_while">#take_while</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-zip">#zip</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="Encoding.html">Encoding</a></li>
        
          <li><a href="Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          <li><a href="Encoding/Converter.html">Encoding::Converter</a></li>
        
          <li><a href="Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          <li><a href="Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          <li><a href="Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          <li><a href="Process.html">Process</a></li>
        
          <li><a href="Process/GID.html">Process::GID</a></li>
        
          <li><a href="Process/Status.html">Process::Status</a></li>
        
          <li><a href="Process/Sys.html">Process::Sys</a></li>
        
          <li><a href="Process/UID.html">Process::UID</a></li>
        
          <li><a href="Enumerator.html">Enumerator</a></li>
        
          <li><a href="Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          <li><a href="Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          <li><a href="File.html">File</a></li>
        
          <li><a href="File/Constants.html">File::Constants</a></li>
        
          <li><a href="File/Stat.html">File::Stat</a></li>
        
          <li><a href="IO.html">IO</a></li>
        
          <li><a href="IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          <li><a href="IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          <li><a href="RubyVM.html">RubyVM</a></li>
        
          <li><a href="RubyVM/Env.html">RubyVM::Env</a></li>
        
          <li><a href="RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          <li><a href="GC.html">GC</a></li>
        
          <li><a href="GC/Profiler.html">GC::Profiler</a></li>
        
          <li><a href="Math.html">Math</a></li>
        
          <li><a href="Math/DomainError.html">Math::DomainError</a></li>
        
          <li><a href="NameError.html">NameError</a></li>
        
          <li><a href="NameError/message.html">NameError::message</a></li>
        
          <li><a href="ARGF.html">ARGF</a></li>
        
          <li><a href="ArgumentError.html">ArgumentError</a></li>
        
          <li><a href="Array.html">Array</a></li>
        
          <li><a href="BasicObject.html">BasicObject</a></li>
        
          <li><a href="Bignum.html">Bignum</a></li>
        
          <li><a href="Binding.html">Binding</a></li>
        
          <li><a href="Class.html">Class</a></li>
        
          <li><a href="Comparable.html">Comparable</a></li>
        
          <li><a href="Complex.html">Complex</a></li>
        
          <li><a href="Continuation.html">Continuation</a></li>
        
          <li><a href="Data.html">Data</a></li>
        
          <li><a href="Dir.html">Dir</a></li>
        
          <li><a href="EOFError.html">EOFError</a></li>
        
          <li><a href="EncodingError.html">EncodingError</a></li>
        
          <li><a href="Enumerable.html">Enumerable</a></li>
        
          <li><a href="Errno.html">Errno</a></li>
        
          <li><a href="Exception.html">Exception</a></li>
        
          <li><a href="FalseClass.html">FalseClass</a></li>
        
          <li><a href="Fiber.html">Fiber</a></li>
        
          <li><a href="FiberError.html">FiberError</a></li>
        
          <li><a href="FileTest.html">FileTest</a></li>
        
          <li><a href="Fixnum.html">Fixnum</a></li>
        
          <li><a href="Float.html">Float</a></li>
        
          <li><a href="FloatDomainError.html">FloatDomainError</a></li>
        
          <li><a href="Hash.html">Hash</a></li>
        
          <li><a href="IOError.html">IOError</a></li>
        
          <li><a href="IndexError.html">IndexError</a></li>
        
          <li><a href="Integer.html">Integer</a></li>
        
          <li><a href="Interrupt.html">Interrupt</a></li>
        
          <li><a href="Kernel.html">Kernel</a></li>
        
          <li><a href="KeyError.html">KeyError</a></li>
        
          <li><a href="LoadError.html">LoadError</a></li>
        
          <li><a href="LocalJumpError.html">LocalJumpError</a></li>
        
          <li><a href="Marshal.html">Marshal</a></li>
        
          <li><a href="MatchData.html">MatchData</a></li>
        
          <li><a href="Method.html">Method</a></li>
        
          <li><a href="Module.html">Module</a></li>
        
          <li><a href="Mutex.html">Mutex</a></li>
        
          <li><a href="NilClass.html">NilClass</a></li>
        
          <li><a href="NoMemoryError.html">NoMemoryError</a></li>
        
          <li><a href="NoMethodError.html">NoMethodError</a></li>
        
          <li><a href="NotImplementedError.html">NotImplementedError</a></li>
        
          <li><a href="Numeric.html">Numeric</a></li>
        
          <li><a href="Object.html">Object</a></li>
        
          <li><a href="ObjectSpace.html">ObjectSpace</a></li>
        
          <li><a href="Proc.html">Proc</a></li>
        
          <li><a href="Random.html">Random</a></li>
        
          <li><a href="Range.html">Range</a></li>
        
          <li><a href="RangeError.html">RangeError</a></li>
        
          <li><a href="Rational.html">Rational</a></li>
        
          <li><a href="Regexp.html">Regexp</a></li>
        
          <li><a href="RegexpError.html">RegexpError</a></li>
        
          <li><a href="RuntimeError.html">RuntimeError</a></li>
        
          <li><a href="ScriptError.html">ScriptError</a></li>
        
          <li><a href="SecurityError.html">SecurityError</a></li>
        
          <li><a href="Signal.html">Signal</a></li>
        
          <li><a href="SignalException.html">SignalException</a></li>
        
          <li><a href="StandardError.html">StandardError</a></li>
        
          <li><a href="StopIteration.html">StopIteration</a></li>
        
          <li><a href="String.html">String</a></li>
        
          <li><a href="Struct.html">Struct</a></li>
        
          <li><a href="Symbol.html">Symbol</a></li>
        
          <li><a href="SyntaxError.html">SyntaxError</a></li>
        
          <li><a href="SystemCallError.html">SystemCallError</a></li>
        
          <li><a href="SystemExit.html">SystemExit</a></li>
        
          <li><a href="SystemStackError.html">SystemStackError</a></li>
        
          <li><a href="Thread.html">Thread</a></li>
        
          <li><a href="ThreadError.html">ThreadError</a></li>
        
          <li><a href="ThreadGroup.html">ThreadGroup</a></li>
        
          <li><a href="Time.html">Time</a></li>
        
          <li><a href="TrueClass.html">TrueClass</a></li>
        
          <li><a href="TypeError.html">TypeError</a></li>
        
          <li><a href="UnboundMethod.html">UnboundMethod</a></li>
        
          <li><a href="ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          <li><a href="fatal.html">fatal</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="module">Enumerable</h1>

    <div id="description" class="description">
      
<p>The <tt><a href="Enumerable.html">Enumerable</a></tt> mixin provides
collection classes with several traversal and searching methods, and with
the ability to sort. The class must provide a method <tt>each</tt>, which
yields successive members of the collection. If <tt><a
href="Enumerable.html#method-i-max">Enumerable#max</a></tt>, <tt><a
href="Enumerable.html#method-i-min">min</a></tt>, or <tt><a
href="Enumerable.html#method-i-sort">sort</a></tt> is used, the objects in
the collection must also implement a meaningful <tt>&lt;=&gt;</tt>
operator, as these methods rely on an ordering between members of the
collection.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="all-3F-method" class="method-detail ">
          <a name="method-i-all-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">all? [{|obj| block } ]   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block never returns <tt>false</tt> or
<tt>nil</tt>. If the block is not given, Ruby adds an implicit block of
<tt>{|obj| obj}</tt> (that is <tt>all?</tt> will return <tt>true</tt> only
if none of the collection members are <tt>false</tt> or <tt>nil</tt>.)</p>

<pre>%w{ant bear cat}.all? {|word| word.length &gt;= 3}   #=&gt; true
%w{ant bear cat}.all? {|word| word.length &gt;= 4}   #=&gt; false
[ nil, true, 99 ].all?                            #=&gt; false</pre>
            

            
            <div class="method-source-code" id="all-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_all(VALUE obj)
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)&amp;result);
    return result;
}</code>
</pre> 
            </div><!-- all-3F-source -->
            
          </div>

          

          
        </div><!-- all-3F-method -->

      
        <div id="any-3F-method" class="method-detail ">
          <a name="method-i-any-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">any? [{|obj| block } ]   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block ever returns a value other than
<tt>false</tt> or <tt>nil</tt>. If the block is not given, Ruby adds an
implicit block of <tt>{|obj| obj}</tt> (that is <tt>any?</tt> will return
<tt>true</tt> if at least one of the collection members is not
<tt>false</tt> or <tt>nil</tt>.</p>

<pre>%w{ant bear cat}.any? {|word| word.length &gt;= 3}   #=&gt; true
%w{ant bear cat}.any? {|word| word.length &gt;= 4}   #=&gt; true
[ nil, true, 99 ].any?                            #=&gt; true</pre>
            

            
            <div class="method-source-code" id="any-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_any(VALUE obj)
{
    VALUE result = Qfalse;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)&amp;result);
    return result;
}</code>
</pre> 
            </div><!-- any-3F-source -->
            
          </div>

          

          
        </div><!-- any-3F-method -->

      
        <div id="chunk-method" class="method-detail ">
          <a name="method-i-chunk"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">chunk {|elt| ... }                       &rarr; an_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">chunk(initial_state) {|elt, state| ... } &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Creates an enumerator for each chunked elements. The consecutive elements
which have same block value are chunked.</p>

<p>The result enumerator yields the block value and an array of chunked
elements. So “each” method can be called as follows.</p>

<pre>enum.chunk {|elt| key }.each {|key, ary| ... }
enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }</pre>

<p>For example, consecutive even numbers and odd numbers can be splitted as
follows.</p>

<pre>[3,1,4,1,5,9,2,6,5,3,5].chunk {|n|
  n.even?
}.each {|even, ary|
  p [even, ary]
}
#=&gt; [false, [3, 1]]
#   [true, [4]]
#   [false, [1, 5, 9]]
#   [true, [2, 6]]
#   [false, [5, 3, 5]]</pre>

<p>This method is especially useful for sorted series of elements. The
following example counts words for each initial letter.</p>

<pre>open(&quot;/usr/share/dict/words&quot;, &quot;r:iso-8859-1&quot;) {|f|
  f.chunk {|line| line.ord }.each {|ch, lines| p [ch.chr, lines.length] }
}
#=&gt; [&quot;\n&quot;, 1]
#   [&quot;A&quot;, 1327]
#   [&quot;B&quot;, 1372]
#   [&quot;C&quot;, 1507]
#   [&quot;D&quot;, 791]
#   ...</pre>

<p>The following key values has special meaning:</p>
<ul><li>
<p>nil and :_separator specifies that the elements are dropped.</p>
</li><li>
<p>:_alone specifies that the element should be chunked as a singleton.</p>
</li></ul>

<p>Other symbols which begins an underscore are reserved.</p>

<p>nil and :_separator can be used to ignore some elements. For example, the
sequence of hyphens in svn log can be eliminated as follows.</p>

<pre>sep = &quot;-&quot;*72 + &quot;\n&quot;
IO.popen(&quot;svn log README&quot;) {|f|
  f.chunk {|line|
    line != sep || nil
  }.each {|_, lines|
    pp lines
  }
}
#=&gt; [&quot;r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n&quot;,
#    &quot;\n&quot;,
#    &quot;* README, README.ja: Update the portability section.\n&quot;,
#    &quot;\n&quot;]
#   [&quot;r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n&quot;,
#    &quot;\n&quot;,
#    &quot;* README, README.ja: Add a note about default C flags.\n&quot;,
#    &quot;\n&quot;]
#   ...</pre>

<p>paragraphs separated by empty lines can be parsed as follows.</p>

<pre>File.foreach(&quot;README&quot;).chunk {|line|
  /\A\s*\z/ !~ line || nil
}.each {|_, lines|
  pp lines
}</pre>

<p>:_alone can be used to pass through bunch of elements. For example, sort
consecutive lines formed as Foo#bar and pass other lines, chunk can be used
as follows.</p>

<pre>pat = /\A[A-Z][A-Za-z0-9_]+\#/
open(filename) {|f|
  f.chunk {|line| pat =~ line ? $&amp; : :_alone }.each {|key, lines|
    if key != :_alone
      print lines.sort.join('')
    else
      print lines.join('')
    end
  }
}</pre>

<p>If the block needs to maintain state over multiple elements,
<em>initial_state</em> argument can be used. If non-nil value is given, it
is duplicated for each “each” method invocation of the enumerator. The
duplicated object is passed to 2nd argument of the block for “chunk”
method.</p>
            

            
            <div class="method-source-code" id="chunk-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_chunk(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE initial_state;
    VALUE enumerator;

    if(!rb_block_given_p())
        rb_raise(rb_eArgError, &quot;no block given&quot;);
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;initial_state);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_enumerable&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_categorize&quot;), rb_block_proc());
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_initial_state&quot;), initial_state);
    rb_block_call(enumerator, rb_intern(&quot;initialize&quot;), 0, 0, chunk_i, enumerator);
    return enumerator;
}</code>
</pre> 
            </div><!-- chunk-source -->
            
          </div>

          

          
        </div><!-- chunk-method -->

      
        <div id="collect-method" class="method-detail ">
          <a name="method-i-collect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map     {| obj | block }  &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                   &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                       &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
(1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</pre>
            

            
            <div class="method-source-code" id="collect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- collect-source -->
            
          </div>

          

          
        </div><!-- collect-method -->

      
        <div id="collect_concat-method" class="method-detail ">
          <a name="method-i-collect_concat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flat_map       {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect_concat {| obj | block }  &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flat_map                         &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect_concat                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>[[1,2],[3,4]].flat_map {|i| i }   #=&gt; [1, 2, 3, 4]</pre>
            

            
            <div class="method-source-code" id="collect_concat-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- collect_concat-source -->
            
          </div>

          

          
        </div><!-- collect_concat-method -->

      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">count                   &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count(item)             &rarr; int</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count {| obj | block }  &rarr; int</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the number of items in <em>enum</em>, where size is called if it
responds to it, otherwise the items are counted through enumeration.  If an
argument is given, counts the number of items in <em>enum</em>, for which
equals to <em>item</em>.  If a block is given, counts the number of
elements yielding a true value.</p>

<pre>ary = [1, 2, 4, 2]
ary.count             #=&gt; 4
ary.count(2)          #=&gt; 2
ary.count{|x|x%2==0}  #=&gt; 3</pre>
            

            
            <div class="method-source-code" id="count-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];      /* [count, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[1]);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = count_i;
    }

    memo[0] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)&amp;memo);
    return INT2NUM(memo[0]);
}</code>
</pre> 
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->

      
        <div id="cycle-method" class="method-detail ">
          <a name="method-i-cycle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil) {|obj| block }   &rarr;  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil)                  &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> for each element of <em>enum</em> repeatedly
<em>n</em> times or forever if none or <tt>nil</tt> is given.  If a
non-positive number is given or the collection is empty, does nothing. 
Returns <tt>nil</tt> if the loop has finished without getting interrupted.</p>

<p><a href="Enumerable.html#method-i-cycle">Enumerable#cycle</a> saves
elements in an internal array so changes to <em>enum</em> after the first
pass have no effect.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.</pre>
            

            
            <div class="method-source-code" id="cycle-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(obj, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC(ary)-&gt;klass = 0;
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            rb_yield(RARRAY_PTR(ary)[i]);
        }
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- cycle-source -->
            
          </div>

          

          
        </div><!-- cycle-method -->

      
        <div id="detect-method" class="method-detail ">
          <a name="method-i-detect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">detect(ifnone = nil) {| obj | block }  &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find(ifnone = nil)   {| obj | block }  &rarr; obj or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">detect(ifnone = nil)                   &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find(ifnone = nil)                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<tt>nil</tt> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
(1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35</pre>
            

            
            <div class="method-source-code" id="detect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
        return memo;
    }
    if (!NIL_P(if_none)) {
        return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- detect-source -->
            
          </div>

          

          
        </div><!-- detect-method -->

      
        <div id="drop-method" class="method-detail ">
          <a name="method-i-drop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop(n)               &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Drops first n elements from <em>enum</em>, and returns rest elements in an
array.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.drop(3)             #=&gt; [4, 5, 0]</pre>
            

            
            <div class="method-source-code" id="drop-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    args[1] = len;
    args[0] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)args);
    return args[0];
}</code>
</pre> 
            </div><!-- drop-source -->
            
          </div>

          

          
        </div><!-- drop-method -->

      
        <div id="drop_while-method" class="method-detail ">
          <a name="method-i-drop_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop_while {|arr| block }   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">drop_while                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Drops elements up to, but not including, the first element for which the
block returns <tt>nil</tt> or <tt>false</tt> and returns an array
containing the remaining elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.drop_while {|i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]</pre>
            

            
            <div class="method-source-code" id="drop_while-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_drop_while(VALUE obj)
{
    VALUE args[2];

    RETURN_ENUMERATOR(obj, 0, 0);
    args[0] = rb_ary_new();
    args[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)args);
    return args[0];
}</code>
</pre> 
            </div><!-- drop_while-source -->
            
          </div>

          

          
        </div><!-- drop_while-method -->

      
        <div id="each_cons-method" class="method-detail ">
          <a name="method-i-each_cons"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_cons(n) {...}   &rarr;  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_cons(n)         &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Iterates the given block for each array of consecutive &lt;n&gt; elements. 
If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre>(1..10).each_cons(3) {|a| p a}
# outputs below
[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 10]</pre>
            

            
            <div class="method-source-code" id="each_cons-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE args[2];

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)args);

    return Qnil;
}</code>
</pre> 
            </div><!-- each_cons-source -->
            
          </div>

          

          
        </div><!-- each_cons-method -->

      
        <div id="each_entry-method" class="method-detail ">
          <a name="method-i-each_entry"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_entry {|obj| block}  &rarr; enum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_entry                &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> once for each element in <tt>self</tt>, passing that
element as a parameter, converting multiple values from yield to an array.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>class Foo
  include Enumerable
  def each
    yield 1
    yield 1,2
  end
end
Foo.new.each_entry{|o| print o, &quot; -- &quot;}</pre>

<p>produces:</p>

<pre>1 -- [1, 2] --</pre>
            

            
            <div class="method-source-code" id="each_entry-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</code>
</pre> 
            </div><!-- each_entry-source -->
            
          </div>

          

          
        </div><!-- each_entry-method -->

      
        <div id="each_slice-method" class="method-detail ">
          <a name="method-i-each_slice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_slice(n) {...}  &rarr;  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_slice(n)        &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Iterates the given block for each slice of &lt;n&gt; elements.  If no block
is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre>(1..10).each_slice(3) {|a| p a}
# outputs below
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[10]</pre>
            

            
            <div class="method-source-code" id="each_slice-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE args[2], ary;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid slice size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)args);

    ary = args[0];
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}</code>
</pre> 
            </div><!-- each_slice-source -->
            
          </div>

          

          
        </div><!-- each_slice-method -->

      
        <div id="each_with_index-method" class="method-detail ">
          <a name="method-i-each_with_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_with_index(*args) {|obj, i| block }   &rarr;  enum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_with_index(*args)                     &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> with two arguments, the item and its index, for each
item in <em>enum</em>.  Given arguments are passed through to each().</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>hash = Hash.new
%w(cat dog wombat).each_with_index {|item, index|
  hash[item] = index
}
hash   #=&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}</pre>
            

            
            <div class="method-source-code" id="each_with_index-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    long memo;

    RETURN_ENUMERATOR(obj, argc, argv);

    memo = 0;
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)&amp;memo);
    return obj;
}</code>
</pre> 
            </div><!-- each_with_index-source -->
            
          </div>

          

          
        </div><!-- each_with_index-method -->

      
        <div id="each_with_object-method" class="method-detail ">
          <a name="method-i-each_with_object"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_with_object(obj) {|(*args), memo_obj| ... }  &rarr;  obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_with_object(obj)                             &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Iterates the given block for each element with an arbitrary object given,
and returns the initially given object.</p>

<p>If no block is given, returns an enumerator.</p>

<p>e.g.:</p>

<pre>evens = (1..10).each_with_object([]) {|i, a| a &lt;&lt; i*2 }
#=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</pre>
            

            
            <div class="method-source-code" id="each_with_object-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_ENUMERATOR(obj, 1, &amp;memo);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</code>
</pre> 
            </div><!-- each_with_object-source -->
            
          </div>

          

          
        </div><!-- each_with_object-method -->

      
        <div id="entries-method" class="method-detail ">
          <a name="method-i-entries"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a      &rarr;    array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">entries   &rarr;    array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing the items in <em>enum</em>.</p>

<pre>(1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
{ 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</pre>
            

            
            <div class="method-source-code" id="entries-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</code>
</pre> 
            </div><!-- entries-source -->
            
          </div>

          

          
        </div><!-- entries-method -->

      
        <div id="find-method" class="method-detail ">
          <a name="method-i-find"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">detect(ifnone = nil) {| obj | block }  &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find(ifnone = nil)   {| obj | block }  &rarr; obj or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">detect(ifnone = nil)                   &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find(ifnone = nil)                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<tt>nil</tt> otherwise.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
(1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35</pre>
            

            
            <div class="method-source-code" id="find-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
        return memo;
    }
    if (!NIL_P(if_none)) {
        return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- find-source -->
            
          </div>

          

          
        </div><!-- find-method -->

      
        <div id="find_all-method" class="method-detail ">
          <a name="method-i-find_all"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find_all {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select   {| obj | block }  &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_all                   &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <tt>false</tt> (see also <tt><a
href="Enumerable.html#method-i-reject">Enumerable#reject</a></tt>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]</pre>
            

            
            <div class="method-source-code" id="find_all-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- find_all-source -->
            
          </div>

          

          
        </div><!-- find_all-method -->

      
        <div id="find_index-method" class="method-detail ">
          <a name="method-i-find_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find_index(value)            &rarr; int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_index {| obj | block }  &rarr; int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_index                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Compares each entry in <em>enum</em> with <em>value</em> or passes to
<em>block</em>.  Returns the index for the first for which the evaluated
value is non-false.  If no object matches, returns <tt>nil</tt></p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre>(1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
(1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 34
(1..100).find_index(50)                                #=&gt; 49</pre>
            

            
            <div class="method-source-code" id="find_index-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[3];      /* [return value, current index, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[2]);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        func = find_index_i;
    }

    memo[0] = Qnil;
    memo[1] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo[0];
}</code>
</pre> 
            </div><!-- find_index-source -->
            
          </div>

          

          
        </div><!-- find_index-method -->

      
        <div id="first-method" class="method-detail ">
          <a name="method-i-first"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">first       &rarr;  obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">first(n)    &rarr;  an_array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the first element, or the first <tt>n</tt> elements, of the
enumerable. If the enumerable is empty, the first form returns
<tt>nil</tt>, and the second form returns an empty array.</p>
            

            
            <div class="method-source-code" id="first-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    VALUE n, params[2];

    if (argc == 0) {
        params[0] = params[1] = Qnil;
    }
    else {
        long len;

        rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
        len = NUM2LONG(n);
        if (len == 0) return rb_ary_new2(0);
        if (len &lt; 0) {
            rb_raise(rb_eArgError, &quot;negative length&quot;);
        }
        params[0] = len;
        params[1] = rb_ary_new2(len);
    }
    rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)params);

    return params[1];
}</code>
</pre> 
            </div><!-- first-source -->
            
          </div>

          

          
        </div><!-- first-method -->

      
        <div id="flat_map-method" class="method-detail ">
          <a name="method-i-flat_map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flat_map       {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect_concat {| obj | block }  &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flat_map                         &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect_concat                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>[[1,2],[3,4]].flat_map {|i| i }   #=&gt; [1, 2, 3, 4]</pre>
            

            
            <div class="method-source-code" id="flat_map-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- flat_map-source -->
            
          </div>

          

          
        </div><!-- flat_map-method -->

      
        <div id="grep-method" class="method-detail ">
          <a name="method-i-grep"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">grep(pattern)                   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">grep(pattern) {| obj | block }  &rarr; array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array of every element in <em>enum</em> for which <tt>Pattern
=== element</tt>. If the optional <em>block</em> is supplied, each matching
element is passed to it, and the block’s result is stored in the output
array.</p>

<pre>(1..100).grep 38..44   #=&gt; [38, 39, 40, 41, 42, 43, 44]
c = IO.constants
c.grep(/SEEK/)         #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]
res = c.grep(/SEEK/) {|v| IO.const_get(v) }
res                    #=&gt; [0, 1, 2]</pre>
            

            
            <div class="method-source-code" id="grep-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    VALUE arg[2];

    arg[0] = pat;
    arg[1] = ary;

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)arg);

    return ary;
}</code>
</pre> 
            </div><!-- grep-source -->
            
          </div>

          

          
        </div><!-- grep-method -->

      
        <div id="group_by-method" class="method-detail ">
          <a name="method-i-group_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">group_by {| obj | block }  &rarr; a_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">group_by                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a hash, which keys are evaluated result from the block, and values
are arrays of elements in <em>enum</em> corresponding to the key.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..6).group_by {|i| i%3}   #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</pre>
            

            
            <div class="method-source-code" id="group_by-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_group_by(VALUE obj)
{
    VALUE hash;

    RETURN_ENUMERATOR(obj, 0, 0);

    hash = rb_hash_new();
    rb_block_call(obj, id_each, 0, 0, group_by_i, hash);
    OBJ_INFECT(hash, obj);

    return hash;
}</code>
</pre> 
            </div><!-- group_by-source -->
            
          </div>

          

          
        </div><!-- group_by-method -->

      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(obj)     &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">member?(obj)      &rarr; true or false</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>true</tt> if any member of <em>enum</em> equals <em>obj</em>.
Equality is tested using <tt>==</tt>.</p>

<pre>IO.constants.include? :SEEK_SET          #=&gt; true
IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_member(VALUE obj, VALUE val)
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo[1];
}</code>
</pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->

      
        <div id="inject-method" class="method-detail ">
          <a name="method-i-inject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inject(initial, sym) &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject(sym)          &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject(initial) {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject          {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq"></span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(initial, sym) &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(sym)          &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(initial) {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce          {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value fo the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then uses the first element of collection is used as the
initial value of <em>memo</em>.</p>

<p>Examples:</p>

<pre># Sum some numbers
(5..10).reduce(:+)                            #=&gt; 45
# Same using a block and inject
(5..10).inject {|sum, n| sum + n }            #=&gt; 45
# Multiply some numbers
(5..10).reduce(1, :*)                         #=&gt; 151200
# Same using a block
(5..10).inject(1) {|product, n| product * n } #=&gt; 151200
# find the longest word
longest = %w{ cat sheep bear }.inject do |memo,word|
   memo.length &gt; word.length ? memo : word
end
longest                                       #=&gt; &quot;sheep&quot;</pre>
            

            
            <div class="method-source-code" id="inject-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
        memo[0] = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        memo[1] = (VALUE)rb_to_id(memo[0]);
        memo[0] = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        memo[1] = (VALUE)rb_to_id(memo[1]);
        iter = inject_op_i;
        break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</code>
</pre> 
            </div><!-- inject-source -->
            
          </div>

          

          
        </div><!-- inject-method -->

      
        <div id="map-method" class="method-detail ">
          <a name="method-i-map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map     {| obj | block }  &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                   &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                       &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
(1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</pre>
            

            
            <div class="method-source-code" id="map-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- map-source -->
            
          </div>

          

          
        </div><!-- map-method -->

      
        <div id="max-method" class="method-detail ">
          <a name="method-i-max"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">max                   &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max {|a,b| block }    &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the object in <em>enum</em> with the maximum value. The first form
assumes all objects implement <tt><a
href="Comparable.html">Comparable</a></tt>; the second uses the block to
return <em>a &lt;=&gt; b</em>.</p>

<pre>a = %w(albatross dog horse)
a.max                                  #=&gt; &quot;horse&quot;
a.max {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;albatross&quot;</pre>
            

            
            <div class="method-source-code" id="max-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_max(VALUE obj)
{
    VALUE result = Qundef;

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)&amp;result);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)&amp;result);
    }
    if (result == Qundef) return Qnil;
    return result;
}</code>
</pre> 
            </div><!-- max-source -->
            
          </div>

          

          
        </div><!-- max-method -->

      
        <div id="max_by-method" class="method-detail ">
          <a name="method-i-max_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">max_by {|obj| block }   &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">max_by                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the object in <em>enum</em> that gives the maximum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = %w(albatross dog horse)
a.max_by {|x| x.length }   #=&gt; &quot;albatross&quot;</pre>
            

            
            <div class="method-source-code" id="max_by-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_max_by(VALUE obj)
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo[1];
}</code>
</pre> 
            </div><!-- max_by-source -->
            
          </div>

          

          
        </div><!-- max_by-method -->

      
        <div id="member-3F-method" class="method-detail ">
          <a name="method-i-member-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(obj)     &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">member?(obj)      &rarr; true or false</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>true</tt> if any member of <em>enum</em> equals <em>obj</em>.
Equality is tested using <tt>==</tt>.</p>

<pre>IO.constants.include? :SEEK_SET          #=&gt; true
IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false</pre>
            

            
            <div class="method-source-code" id="member-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_member(VALUE obj, VALUE val)
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo[1];
}</code>
</pre> 
            </div><!-- member-3F-source -->
            
          </div>

          

          
        </div><!-- member-3F-method -->

      
        <div id="min-method" class="method-detail ">
          <a name="method-i-min"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">min                    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min {| a,b | block }   &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the object in <em>enum</em> with the minimum value. The first form
assumes all objects implement <tt><a
href="Comparable.html">Comparable</a></tt>; the second uses the block to
return <em>a &lt;=&gt; b</em>.</p>

<pre>a = %w(albatross dog horse)
a.min                                  #=&gt; &quot;albatross&quot;
a.min {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;dog&quot;</pre>
            

            
            <div class="method-source-code" id="min-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_min(VALUE obj)
{
    VALUE result = Qundef;

    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, (VALUE)&amp;result);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, (VALUE)&amp;result);
    }
    if (result == Qundef) return Qnil;
    return result;
}</code>
</pre> 
            </div><!-- min-source -->
            
          </div>

          

          
        </div><!-- min-method -->

      
        <div id="min_by-method" class="method-detail ">
          <a name="method-i-min_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">min_by {|obj| block }   &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">min_by                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the object in <em>enum</em> that gives the minimum value from the
given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = %w(albatross dog horse)
a.min_by {|x| x.length }   #=&gt; &quot;dog&quot;</pre>
            

            
            <div class="method-source-code" id="min_by-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_min_by(VALUE obj)
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo[1];
}</code>
</pre> 
            </div><!-- min_by-source -->
            
          </div>

          

          
        </div><!-- min_by-method -->

      
        <div id="minmax-method" class="method-detail ">
          <a name="method-i-minmax"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">minmax                   &rarr; [min,max]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">minmax {|a,b| block }    &rarr; [min,max]</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns two elements array which contains the minimum and the maximum value
in the enumerable.  The first form assumes all objects implement <tt><a
href="Comparable.html">Comparable</a></tt>; the second uses the block to
return <em>a &lt;=&gt; b</em>.</p>

<pre>a = %w(albatross dog horse)
a.minmax                                  #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
a.minmax {|a,b| a.length &lt;=&gt; b.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</pre>
            

            
            <div class="method-source-code" id="minmax-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_minmax(VALUE obj)
{
    struct minmax_t memo;
    VALUE ary = rb_ary_new3(2, Qnil, Qnil);

    memo.min = Qundef;
    memo.last = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, (VALUE)&amp;memo);
        if (memo.last != Qundef)
            minmax_ii_update(memo.last, memo.last, &amp;memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, (VALUE)&amp;memo);
        if (memo.last != Qundef)
            minmax_i_update(memo.last, memo.last, &amp;memo);
    }
    if (memo.min != Qundef) {
        rb_ary_store(ary, 0, memo.min);
        rb_ary_store(ary, 1, memo.max);
    }
    return ary;
}</code>
</pre> 
            </div><!-- minmax-source -->
            
          </div>

          

          
        </div><!-- minmax-method -->

      
        <div id="minmax_by-method" class="method-detail ">
          <a name="method-i-minmax_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">minmax_by {|obj| block }   &rarr; [min, max]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">minmax_by                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns two elements array array containing the objects in <em>enum</em>
that gives the minimum and maximum values respectively from the given
block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = %w(albatross dog horse)
a.minmax_by {|x| x.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</pre>
            

            
            <div class="method-source-code" id="minmax_by-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_minmax_by(VALUE obj)
{
    struct minmax_by_t memo;

    RETURN_ENUMERATOR(obj, 0, 0);

    memo.min_bv = Qundef;
    memo.max_bv = Qundef;
    memo.min = Qnil;
    memo.max = Qnil;
    memo.last_bv = Qundef;
    memo.last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, (VALUE)&amp;memo);
    if (memo.last_bv != Qundef)
        minmax_by_i_update(memo.last_bv, memo.last_bv, memo.last, memo.last, &amp;memo);
    return rb_assoc_new(memo.min, memo.max);
}</code>
</pre> 
            </div><!-- minmax_by-source -->
            
          </div>

          

          
        </div><!-- minmax_by-method -->

      
        <div id="none-3F-method" class="method-detail ">
          <a name="method-i-none-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">none? [{|obj| block }]   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block never returns <tt>true</tt> for all
elements. If the block is not given, <tt>none?</tt> will return
<tt>true</tt> only if none of the collection members is true.</p>

<pre>%w{ant bear cat}.none? {|word| word.length == 5}  #=&gt; true
%w{ant bear cat}.none? {|word| word.length &gt;= 4}  #=&gt; false
[].none?                                          #=&gt; true
[nil].none?                                       #=&gt; true
[nil,false].none?                                 #=&gt; true</pre>
            

            
            <div class="method-source-code" id="none-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_none(VALUE obj)
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)&amp;result);
    return result;
}</code>
</pre> 
            </div><!-- none-3F-source -->
            
          </div>

          

          
        </div><!-- none-3F-method -->

      
        <div id="one-3F-method" class="method-detail ">
          <a name="method-i-one-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">one? [{|obj| block }]   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block returns <tt>true</tt> exactly once. If
the block is not given, <tt>one?</tt> will return <tt>true</tt> only if
exactly one of the collection members is true.</p>

<pre>%w{ant bear cat}.one? {|word| word.length == 4}   #=&gt; true
%w{ant bear cat}.one? {|word| word.length &gt; 4}    #=&gt; false
%w{ant bear cat}.one? {|word| word.length &lt; 4}    #=&gt; false
[ nil, true, 99 ].one?                            #=&gt; false
[ nil, true, false ].one?                         #=&gt; true</pre>
            

            
            <div class="method-source-code" id="one-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_one(VALUE obj)
{
    VALUE result = Qundef;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)&amp;result);
    if (result == Qundef) return Qfalse;
    return result;
}</code>
</pre> 
            </div><!-- one-3F-source -->
            
          </div>

          

          
        </div><!-- one-3F-method -->

      
        <div id="partition-method" class="method-detail ">
          <a name="method-i-partition"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">partition {| obj | block }  &rarr; [ true_array, false_array ]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">partition                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns two arrays, the first containing the elements of <em>enum</em> for
which the block evaluates to true, the second containing the rest.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..6).partition {|i| (i&amp;1).zero?}   #=&gt; [[2, 4, 6], [1, 3, 5]]</pre>
            

            
            <div class="method-source-code" id="partition-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_partition(VALUE obj)
{
    VALUE ary[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    ary[0] = rb_ary_new();
    ary[1] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)ary);

    return rb_assoc_new(ary[0], ary[1]);
}</code>
</pre> 
            </div><!-- partition-source -->
            
          </div>

          

          
        </div><!-- partition-method -->

      
        <div id="reduce-method" class="method-detail ">
          <a name="method-i-reduce"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inject(initial, sym) &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject(sym)          &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject(initial) {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inject          {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq"></span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(initial, sym) &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(sym)          &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce(initial) {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reduce          {| memo, obj | block }  &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.</p>

<p>If you specify a block, then for each element in <em>enum</em> the block is
passed an accumulator value (<em>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value fo the method.</p>

<p>If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then uses the first element of collection is used as the
initial value of <em>memo</em>.</p>

<p>Examples:</p>

<pre># Sum some numbers
(5..10).reduce(:+)                            #=&gt; 45
# Same using a block and inject
(5..10).inject {|sum, n| sum + n }            #=&gt; 45
# Multiply some numbers
(5..10).reduce(1, :*)                         #=&gt; 151200
# Same using a block
(5..10).inject(1) {|product, n| product * n } #=&gt; 151200
# find the longest word
longest = %w{ cat sheep bear }.inject do |memo,word|
   memo.length &gt; word.length ? memo : word
end
longest                                       #=&gt; &quot;sheep&quot;</pre>
            

            
            <div class="method-source-code" id="reduce-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
        memo[0] = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        memo[1] = (VALUE)rb_to_id(memo[0]);
        memo[0] = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        memo[1] = (VALUE)rb_to_id(memo[1]);
        iter = inject_op_i;
        break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</code>
</pre> 
            </div><!-- reduce-source -->
            
          </div>

          

          
        </div><!-- reduce-method -->

      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array for all elements of <em>enum</em> for which <em>block</em>
is false (see also <tt><a
href="Enumerable.html#method-i-find_all">Enumerable#find_all</a></tt>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..10).reject {|i|  i % 3 == 0 }   #=&gt; [1, 2, 4, 5, 7, 8, 10]</pre>
            

            
            <div class="method-source-code" id="reject-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->

      
        <div id="reverse_each-method" class="method-detail ">
          <a name="method-i-reverse_each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each(*args) {|item| block }   &rarr;  enum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each(*args)                   &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Builds a temporary array and traverses that array in reverse order.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="reverse_each-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, argc, argv);

    ary = enum_to_a(argc, argv, obj);

    for (i = RARRAY_LEN(ary); --i &gt;= 0; ) {
        rb_yield(RARRAY_PTR(ary)[i]);
    }

    return obj;
}</code>
</pre> 
            </div><!-- reverse_each-source -->
            
          </div>

          

          
        </div><!-- reverse_each-method -->

      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">find_all {| obj | block }  &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select   {| obj | block }  &rarr; array</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">find_all                   &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <tt>false</tt> (see also <tt><a
href="Enumerable.html#method-i-reject">Enumerable#reject</a></tt>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>(1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]</pre>
            

            
            <div class="method-source-code" id="select-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</code>
</pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->

      
        <div id="slice_before-method" class="method-detail ">
          <a name="method-i-slice_before"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice_before(pattern)                            &rarr; an_enumerator</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice_before {|elt| bool }                       &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice_before(initial_state) {|elt, state| bool } &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <pre>Creates an enumerator for each chunked elements.
The beginnings of chunks are defined by _pattern_ and the block.
If _pattern_ === _elt_ returns true or
the block returns true for the element,
the element is beginning of a chunk.

The === and block is called from the first element to the last element
of _enum_.
The result for the first element is ignored.

The result enumerator yields the chunked elements as an array for +each+
method.
+each+ method can be called as follows.

  enum.slice_before(pattern).each {|ary| ... }
  enum.slice_before {|elt| bool }.each {|ary| ... }
  enum.slice_before(initial_state) {|elt, state| bool }.each {|ary| ... }

Other methods of Enumerator class and Enumerable module,
such as map, etc., are also usable.

For example, iteration over ChangeLog entries can be implemented as
follows.

  # iterate over ChangeLog entries.
  open(&quot;ChangeLog&quot;) {|f|
    f.slice_before(/\A\S/).each {|e| pp e}
  }

  # same as above.  block is used instead of pattern argument.
  open(&quot;ChangeLog&quot;) {|f|
    f.slice_before {|line| /\A\S/ === line }.each {|e| pp e}
  }</pre>

<p>"svn proplist -R" produces multiline output for each file. They can be
chunked as follows:</p>

<pre>  IO.popen([{&quot;LC_ALL&quot;=&gt;&quot;C&quot;}, &quot;svn&quot;, &quot;proplist&quot;, &quot;-R&quot;]) {|f|
    f.lines.slice_before(/\AProp/).each {|lines| p lines }
  }
  #=&gt; [&quot;Properties on '.':\n&quot;, &quot;  svn:ignore\n&quot;, &quot;  svk:merge\n&quot;]
  #   [&quot;Properties on 'goruby.c':\n&quot;, &quot;  svn:eol-style\n&quot;]
  #   [&quot;Properties on 'complex.c':\n&quot;, &quot;  svn:mime-type\n&quot;, &quot;  svn:eol-style\n&quot;]
  #   [&quot;Properties on 'regparse.c':\n&quot;, &quot;  svn:eol-style\n&quot;]
  #   ...

If the block needs to maintain state over multiple elements,
local variables can be used.
For example, three or more consecutive increasing numbers can be squashed
as follows:

  a = [0,2,3,4,6,7,9]
  prev = a[0]
  p a.slice_before {|e|
    prev, prev2 = e, prev
    prev2 + 1 != e
  }.map {|es|
    es.length &lt;= 2 ? es.join(&quot;,&quot;) : &quot;#{es.first}-#{es.last}&quot;
  }.join(&quot;,&quot;)
  #=&gt; &quot;0,2-4,6,7,9&quot;

However local variables are not appropriate to maintain state
if the result enumerator is used twice or more.
In such case, the last state of the 1st +each+ is used in 2nd +each+.
_initial_state_ argument can be used to avoid this problem.
If non-nil value is given as _initial_state_,
it is duplicated for each &quot;each&quot; method invocation of the enumerator.
The duplicated object is passed to 2nd argument of the block for
+slice_before+ method.

  # word wrapping.
  # this assumes all characters have same width.
  def wordwrap(words, maxwidth)
    # if cols is a local variable, 2nd &quot;each&quot; may start with non-zero cols.
    words.slice_before(cols: 0) {|w, h|
      h[:cols] += 1 if h[:cols] != 0
      h[:cols] += w.length
      if maxwidth &lt; h[:cols]
        h[:cols] = w.length
        true
      else
        false
      end
    }
  end
  text = (1..20).to_a.join(&quot; &quot;)
  enum = wordwrap(text.split(/\s+/), 10)
  puts &quot;-&quot;*10
  enum.each {|ws| puts ws.join(&quot; &quot;) }
  puts &quot;-&quot;*10
  #=&gt; ----------
  #   1 2 3 4 5
  #   6 7 8 9 10
  #   11 12 13
  #   14 15 16
  #   17 18 19
  #   20
  #   ----------</pre>

<p>mbox contains series of mails which start with Unix From line. So each mail
can be extracted by slice before Unix From line.</p>

<pre># parse mbox
open(&quot;mbox&quot;) {|f|
  f.slice_before {|line|
    line.start_with? &quot;From &quot;
  }.each {|mail|
    unix_from = mail.shift
    i = mail.index(&quot;\n&quot;)
    header = mail[0...i]
    body = mail[(i+1)..-1]
    body.pop if body.last == &quot;\n&quot;
    fields = header.slice_before {|line| !&quot; \t&quot;.include?(line[0]) }.to_a
    p unix_from
    pp fields
    pp body
  }
}

# split mails in mbox (slice before Unix From line after an empty line)
open(&quot;mbox&quot;) {|f|
  f.slice_before(emp: true) {|line,h|
    prevemp = h[:emp]
    h[:emp] = line == &quot;\n&quot;
    prevemp &amp;&amp; line.start_with?(&quot;From &quot;)
  }.each {|mail|
    mail.pop if mail.last == &quot;\n&quot;
    pp mail
  }
}</pre>
            

            
            <div class="method-source-code" id="slice_before-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        VALUE initial_state;
        rb_scan_args(argc, argv, &quot;01&quot;, &amp;initial_state);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pred&quot;), rb_block_proc());
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_initial_state&quot;), initial_state);
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pat&quot;), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_enumerable&quot;), enumerable);
    rb_block_call(enumerator, rb_intern(&quot;initialize&quot;), 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</code>
</pre> 
            </div><!-- slice_before-source -->
            
          </div>

          

          
        </div><!-- slice_before-method -->

      
        <div id="sort-method" class="method-detail ">
          <a name="method-i-sort"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort                     &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort {| a, b | block }   &rarr; array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing the items in <em>enum</em> sorted, either
according to their own <tt>&lt;=&gt;</tt> method, or by using the results
of the supplied block. The block should return -1, 0, or +1 depending on
the comparison between <em>a</em> and <em>b</em>. As of Ruby 1.8, the
method <tt><a
href="Enumerable.html#method-i-sort_by">Enumerable#sort_by</a></tt>
implements a built-in Schwartzian Transform, useful when key computation or
comparison is expensive.</p>

<pre>%w(rhea kea flea).sort         #=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]
(1..10).sort {|a,b| b &lt;=&gt; a}   #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</pre>
            

            
            <div class="method-source-code" id="sort-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort(enum_to_a(0, 0, obj));
}</code>
</pre> 
            </div><!-- sort-source -->
            
          </div>

          

          
        </div><!-- sort-method -->

      
        <div id="sort_by-method" class="method-detail ">
          <a name="method-i-sort_by"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort_by {| obj | block }    &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort_by                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Sorts <em>enum</em> using a set of keys generated by mapping the values in
<em>enum</em> through the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>%w{ apple pear fig }.sort_by {|word| word.length}
              #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]</pre>

<p>The current implementation of <tt><a
href="Enumerable.html#method-i-sort_by">sort_by</a></tt> generates an array
of tuples containing the original collection element and the mapped value.
This makes <tt><a href="Enumerable.html#method-i-sort_by">sort_by</a></tt>
fairly expensive when the keysets are simple</p>

<pre>require 'benchmark'

a = (1..100000).map {rand(100000)}

Benchmark.bm(10) do |b|
  b.report(&quot;Sort&quot;)    { a.sort }
  b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }
end</pre>

<p><em>produces:</em></p>

<pre>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</pre>

<p>However, consider the case where comparing the keys is a non-trivial
operation. The following code sorts some files on modification time using
the basic <tt>sort</tt> method.</p>

<pre>files = Dir[&quot;*&quot;]
sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</pre>

<p>This sort is inefficient: it generates two new <tt><a
href="File.html">File</a></tt> objects during every comparison. A slightly
better technique is to use the <tt><a
href="Kernel.html#method-i-test">Kernel#test</a></tt> method to generate
the modification times directly.</p>

<pre>files = Dir[&quot;*&quot;]
sorted = files.sort { |a,b|
  test(?M, a) &lt;=&gt; test(?M, b)
}
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</pre>

<p>This still generates many unnecessary <tt><a href="Time.html">Time</a></tt>
objects. A more efficient technique is to cache the sort keys (modification
times in this case) before the sort. Perl users often call this approach a
Schwartzian Transform, after Randal Schwartz. We construct a temporary
array, where each element is an array containing our sort key along with
the filename. We sort this array, and then extract the filename from the
result.</p>

<pre>sorted = Dir[&quot;*&quot;].collect { |f|
   [test(?M, f), f]
}.sort.collect { |f| f[1] }
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</pre>

<p>This is exactly what <tt><a
href="Enumerable.html#method-i-sort_by">sort_by</a></tt> does internally.</p>

<pre>sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}
sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</pre>
            

            
            <div class="method-source-code" id="sort_by-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, 0, 0);

    if (TYPE(obj) == T_ARRAY) {
        ary  = rb_ary_new2(RARRAY_LEN(obj));
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC(ary)-&gt;klass = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, ary);
    if (RARRAY_LEN(ary) &gt; 1) {
        ruby_qsort(RARRAY_PTR(ary), RARRAY_LEN(ary), sizeof(VALUE),
                   sort_by_cmp, (void *)ary);
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        RARRAY_PTR(ary)[i] = RNODE(RARRAY_PTR(ary)[i])-&gt;u2.value;
    }
    RBASIC(ary)-&gt;klass = rb_cArray;
    OBJ_INFECT(ary, obj);

    return ary;
}</code>
</pre> 
            </div><!-- sort_by-source -->
            
          </div>

          

          
        </div><!-- sort_by-method -->

      
        <div id="take-method" class="method-detail ">
          <a name="method-i-take"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take(n)               &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns first n elements from <em>enum</em>.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.take(3)             #=&gt; [1, 2, 3]</pre>
            

            
            <div class="method-source-code" id="take-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_take(VALUE obj, VALUE n)
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    if (len == 0) return rb_ary_new2(0);
    args[0] = rb_ary_new();
    args[1] = len;
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)args);
    return args[0];
}</code>
</pre> 
            </div><!-- take-source -->
            
          </div>

          

          
        </div><!-- take-method -->

      
        <div id="take_while-method" class="method-detail ">
          <a name="method-i-take_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take_while {|arr| block }   &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">take_while                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes elements to the block until the block returns <tt>nil</tt> or
<tt>false</tt>, then stops iterating and returns an array of all prior
elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.take_while {|i| i &lt; 3 }   #=&gt; [1, 2]</pre>
            

            
            <div class="method-source-code" id="take_while-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, (VALUE)&amp;ary);
    return ary;
}</code>
</pre> 
            </div><!-- take_while-source -->
            
          </div>

          

          
        </div><!-- take_while-method -->

      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a      &rarr;    array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">entries   &rarr;    array</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing the items in <em>enum</em>.</p>

<pre>(1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
{ 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</pre>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</code>
</pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->

      
        <div id="zip-method" class="method-detail ">
          <a name="method-i-zip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...)                   &rarr; an_array_of_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...) {|arr| block }    &rarr; nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Takes one element from <em>enum</em> and merges corresponding elements from
each <em>args</em>.  This generates a sequence of <em>n</em>-element
arrays, where <em>n</em> is one more than the count of arguments.  The
length of the resulting sequence will be <tt>enumsize</tt>.  If the size of
any argument is less than <tt>enumsize</tt>, <tt>nil</tt> values are
supplied. If a block is given, it is invoked for each output array,
otherwise an array of arrays is returned.</p>

<pre>a = [ 4, 5, 6 ]
b = [ 7, 8, 9 ]

[1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
[1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
a.zip([1,2],[8])       #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</pre>
            

            
            <div class="method-source-code" id="zip-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    NODE *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        CONST_ID(conv, &quot;to_enum&quot;);
        for (i=0; i&lt;argc; i++) {
            argv[i] = rb_funcall(argv[i], conv, 1, ID2SYM(id_each));
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }
    /* use NODE_DOT2 as memo(v, v, -) */
    memo = rb_node_newnode(NODE_DOT2, result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</code>
</pre> 
            </div><!-- zip-source -->
            
          </div>

          

          
        </div><!-- zip-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
 <div class='info'>
  <p>Commenting is here to help enhance the documentation.  For example, sample code, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href='http://www.ruby-lang.org/en/community/mailing-lists/'>Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href='http://bugs.ruby-lang.org/projects/ruby/wiki/HowtoReport' >file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  </div>

  </div><!-- documentation -->
 
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.2</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is hosted by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>, an <a href="http://www.neurogami.com"> avant garage research + development in Scottsdale, AZ</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Ruby-doc Rdoc Generator</a> 0.9.5</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>
</body>
</html>

