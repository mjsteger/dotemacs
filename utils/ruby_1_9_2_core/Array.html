<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <!-- RD version: 0.9.5  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <title>Class: Array (Ruby 1.9.2) </title>
  <!-- raw_prefix  = '.'   -->
  <link rel="stylesheet" href="css/obf.css" >

  <script src="js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
</head>

<body id="top" class="class">
<div id='actionbar' >
<div class='wrapper'>
<ul class='grids g0'>
  <li class='grid-2' ><a href='/' target='_top' >Home</a></li>
  <li class='grid-2' ><a href='/core' target='_top' >Core</a></li>
  <li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib</a></li>
  <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
  <li class='grid-7 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="index.html">Home</a>
          <a href="index.html#classes">Classes</a>
          <a href="index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="array_c.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="array.c">array.c</a></li>
          
            <li><a href="pack_c.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="pack.c">pack.c</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-5B-5D">::[]</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-try_convert">::try_convert</a></li>
          
          <li><a href="#method-i-26">#&</a></li>
          
          <li><a href="#method-i-2A">#*</a></li>
          
          <li><a href="#method-i-2B">#+</a></li>
          
          <li><a href="#method-i-2D">#-</a></li>
          
          <li><a href="#method-i-3C-3C">#<<</a></li>
          
          <li><a href="#method-i-3C-3D-3E">#<=></a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-assoc">#assoc</a></li>
          
          <li><a href="#method-i-at">#at</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-collect">#collect</a></li>
          
          <li><a href="#method-i-collect-21">#collect!</a></li>
          
          <li><a href="#method-i-combination">#combination</a></li>
          
          <li><a href="#method-i-compact">#compact</a></li>
          
          <li><a href="#method-i-compact-21">#compact!</a></li>
          
          <li><a href="#method-i-concat">#concat</a></li>
          
          <li><a href="#method-i-count">#count</a></li>
          
          <li><a href="#method-i-cycle">#cycle</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_at">#delete_at</a></li>
          
          <li><a href="#method-i-delete_if">#delete_if</a></li>
          
          <li><a href="#method-i-drop">#drop</a></li>
          
          <li><a href="#method-i-drop_while">#drop_while</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_index">#each_index</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-fetch">#fetch</a></li>
          
          <li><a href="#method-i-fill">#fill</a></li>
          
          <li><a href="#method-i-find_index">#find_index</a></li>
          
          <li><a href="#method-i-first">#first</a></li>
          
          <li><a href="#method-i-flatten">#flatten</a></li>
          
          <li><a href="#method-i-flatten-21">#flatten!</a></li>
          
          <li><a href="#method-i-frozen-3F">#frozen?</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-index">#index</a></li>
          
          <li><a href="#method-i-initialize_copy">#initialize_copy</a></li>
          
          <li><a href="#method-i-insert">#insert</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-join">#join</a></li>
          
          <li><a href="#method-i-keep_if">#keep_if</a></li>
          
          <li><a href="#method-i-last">#last</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-map">#map</a></li>
          
          <li><a href="#method-i-map-21">#map!</a></li>
          
          <li><a href="#method-i-pack">#pack</a></li>
          
          <li><a href="#method-i-permutation">#permutation</a></li>
          
          <li><a href="#method-i-pop">#pop</a></li>
          
          <li><a href="#method-i-product">#product</a></li>
          
          <li><a href="#method-i-push">#push</a></li>
          
          <li><a href="#method-i-rassoc">#rassoc</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reject-21">#reject!</a></li>
          
          <li><a href="#method-i-repeated_combination">#repeated_combination</a></li>
          
          <li><a href="#method-i-repeated_permutation">#repeated_permutation</a></li>
          
          <li><a href="#method-i-replace">#replace</a></li>
          
          <li><a href="#method-i-reverse">#reverse</a></li>
          
          <li><a href="#method-i-reverse-21">#reverse!</a></li>
          
          <li><a href="#method-i-reverse_each">#reverse_each</a></li>
          
          <li><a href="#method-i-rindex">#rindex</a></li>
          
          <li><a href="#method-i-rotate">#rotate</a></li>
          
          <li><a href="#method-i-rotate-21">#rotate!</a></li>
          
          <li><a href="#method-i-sample">#sample</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-select-21">#select!</a></li>
          
          <li><a href="#method-i-shift">#shift</a></li>
          
          <li><a href="#method-i-shuffle">#shuffle</a></li>
          
          <li><a href="#method-i-shuffle-21">#shuffle!</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-slice">#slice</a></li>
          
          <li><a href="#method-i-slice-21">#slice!</a></li>
          
          <li><a href="#method-i-sort">#sort</a></li>
          
          <li><a href="#method-i-sort-21">#sort!</a></li>
          
          <li><a href="#method-i-sort_by-21">#sort_by!</a></li>
          
          <li><a href="#method-i-take">#take</a></li>
          
          <li><a href="#method-i-take_while">#take_while</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_ary">#to_ary</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-transpose">#transpose</a></li>
          
          <li><a href="#method-i-uniq">#uniq</a></li>
          
          <li><a href="#method-i-uniq-21">#uniq!</a></li>
          
          <li><a href="#method-i-unshift">#unshift</a></li>
          
          <li><a href="#method-i-values_at">#values_at</a></li>
          
          <li><a href="#method-i-zip">#zip</a></li>
          
          <li><a href="#method-i-7C">#|</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="Encoding.html">Encoding</a></li>
        
          <li><a href="Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          <li><a href="Encoding/Converter.html">Encoding::Converter</a></li>
        
          <li><a href="Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          <li><a href="Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          <li><a href="Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          <li><a href="Process.html">Process</a></li>
        
          <li><a href="Process/GID.html">Process::GID</a></li>
        
          <li><a href="Process/Status.html">Process::Status</a></li>
        
          <li><a href="Process/Sys.html">Process::Sys</a></li>
        
          <li><a href="Process/UID.html">Process::UID</a></li>
        
          <li><a href="Enumerator.html">Enumerator</a></li>
        
          <li><a href="Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          <li><a href="Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          <li><a href="File.html">File</a></li>
        
          <li><a href="File/Constants.html">File::Constants</a></li>
        
          <li><a href="File/Stat.html">File::Stat</a></li>
        
          <li><a href="IO.html">IO</a></li>
        
          <li><a href="IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          <li><a href="IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          <li><a href="RubyVM.html">RubyVM</a></li>
        
          <li><a href="RubyVM/Env.html">RubyVM::Env</a></li>
        
          <li><a href="RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          <li><a href="GC.html">GC</a></li>
        
          <li><a href="GC/Profiler.html">GC::Profiler</a></li>
        
          <li><a href="Math.html">Math</a></li>
        
          <li><a href="Math/DomainError.html">Math::DomainError</a></li>
        
          <li><a href="NameError.html">NameError</a></li>
        
          <li><a href="NameError/message.html">NameError::message</a></li>
        
          <li><a href="ARGF.html">ARGF</a></li>
        
          <li><a href="ArgumentError.html">ArgumentError</a></li>
        
          <li><a href="Array.html">Array</a></li>
        
          <li><a href="BasicObject.html">BasicObject</a></li>
        
          <li><a href="Bignum.html">Bignum</a></li>
        
          <li><a href="Binding.html">Binding</a></li>
        
          <li><a href="Class.html">Class</a></li>
        
          <li><a href="Comparable.html">Comparable</a></li>
        
          <li><a href="Complex.html">Complex</a></li>
        
          <li><a href="Continuation.html">Continuation</a></li>
        
          <li><a href="Data.html">Data</a></li>
        
          <li><a href="Dir.html">Dir</a></li>
        
          <li><a href="EOFError.html">EOFError</a></li>
        
          <li><a href="EncodingError.html">EncodingError</a></li>
        
          <li><a href="Enumerable.html">Enumerable</a></li>
        
          <li><a href="Errno.html">Errno</a></li>
        
          <li><a href="Exception.html">Exception</a></li>
        
          <li><a href="FalseClass.html">FalseClass</a></li>
        
          <li><a href="Fiber.html">Fiber</a></li>
        
          <li><a href="FiberError.html">FiberError</a></li>
        
          <li><a href="FileTest.html">FileTest</a></li>
        
          <li><a href="Fixnum.html">Fixnum</a></li>
        
          <li><a href="Float.html">Float</a></li>
        
          <li><a href="FloatDomainError.html">FloatDomainError</a></li>
        
          <li><a href="Hash.html">Hash</a></li>
        
          <li><a href="IOError.html">IOError</a></li>
        
          <li><a href="IndexError.html">IndexError</a></li>
        
          <li><a href="Integer.html">Integer</a></li>
        
          <li><a href="Interrupt.html">Interrupt</a></li>
        
          <li><a href="Kernel.html">Kernel</a></li>
        
          <li><a href="KeyError.html">KeyError</a></li>
        
          <li><a href="LoadError.html">LoadError</a></li>
        
          <li><a href="LocalJumpError.html">LocalJumpError</a></li>
        
          <li><a href="Marshal.html">Marshal</a></li>
        
          <li><a href="MatchData.html">MatchData</a></li>
        
          <li><a href="Method.html">Method</a></li>
        
          <li><a href="Module.html">Module</a></li>
        
          <li><a href="Mutex.html">Mutex</a></li>
        
          <li><a href="NilClass.html">NilClass</a></li>
        
          <li><a href="NoMemoryError.html">NoMemoryError</a></li>
        
          <li><a href="NoMethodError.html">NoMethodError</a></li>
        
          <li><a href="NotImplementedError.html">NotImplementedError</a></li>
        
          <li><a href="Numeric.html">Numeric</a></li>
        
          <li><a href="Object.html">Object</a></li>
        
          <li><a href="ObjectSpace.html">ObjectSpace</a></li>
        
          <li><a href="Proc.html">Proc</a></li>
        
          <li><a href="Random.html">Random</a></li>
        
          <li><a href="Range.html">Range</a></li>
        
          <li><a href="RangeError.html">RangeError</a></li>
        
          <li><a href="Rational.html">Rational</a></li>
        
          <li><a href="Regexp.html">Regexp</a></li>
        
          <li><a href="RegexpError.html">RegexpError</a></li>
        
          <li><a href="RuntimeError.html">RuntimeError</a></li>
        
          <li><a href="ScriptError.html">ScriptError</a></li>
        
          <li><a href="SecurityError.html">SecurityError</a></li>
        
          <li><a href="Signal.html">Signal</a></li>
        
          <li><a href="SignalException.html">SignalException</a></li>
        
          <li><a href="StandardError.html">StandardError</a></li>
        
          <li><a href="StopIteration.html">StopIteration</a></li>
        
          <li><a href="String.html">String</a></li>
        
          <li><a href="Struct.html">Struct</a></li>
        
          <li><a href="Symbol.html">Symbol</a></li>
        
          <li><a href="SyntaxError.html">SyntaxError</a></li>
        
          <li><a href="SystemCallError.html">SystemCallError</a></li>
        
          <li><a href="SystemExit.html">SystemExit</a></li>
        
          <li><a href="SystemStackError.html">SystemStackError</a></li>
        
          <li><a href="Thread.html">Thread</a></li>
        
          <li><a href="ThreadError.html">ThreadError</a></li>
        
          <li><a href="ThreadGroup.html">ThreadGroup</a></li>
        
          <li><a href="Time.html">Time</a></li>
        
          <li><a href="TrueClass.html">TrueClass</a></li>
        
          <li><a href="TypeError.html">TypeError</a></li>
        
          <li><a href="UnboundMethod.html">UnboundMethod</a></li>
        
          <li><a href="ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          <li><a href="fatal.html">fatal</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Array</h1>

    <div id="description" class="description">
      
<p>Arrays are ordered, integer-indexed collections of any object. <a
href="Array.html">Array</a> indexing starts at 0, as in C or Java.  A
negative index is assumed to be relative to the end of the array—that is,
an index of -1 indicates the last element of the array, -2 is the next to
last element in the array, and so on.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-c-5B-5D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a new array populated with the given objects.</p>

<pre>Array.[]( 1, 'a', /^A/ )
Array[ 1, 'a', /^A/ ]
[ 1, 'a', /^A/ ]</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        MEMCPY(RARRAY_PTR(ary), argv, VALUE, argc);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}</code>
</pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(size=0, obj=nil)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(array)</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new(size) {|index| block }</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array. In the first form, the new array is empty. In the
second it is created with <em>size</em> copies of <em>obj</em> (that is,
<em>size</em> references to the same <em>obj</em>). The third form creates
a copy of the array passed as a parameter (the array is generated by
calling <a href="Array.html#method-i-to_ary">to_ary</a>  on the parameter).
In the last form, an array of the given size is created. Each element in
this array is calculated by passing the element’s index to the given block
and storing the return value.</p>

<pre>Array.new
Array.new(2)
Array.new(5, &quot;A&quot;)

# only one copy of the object is created
a = Array.new(2, Hash.new)
a[0]['cat'] = 'feline'
a
a[1]['cat'] = 'Felix'
a

# here multiple copies are created
a = Array.new(2) { Hash.new }
a[0]['cat'] = 'feline'
a

squares = Array.new(5) {|i| i*i}
squares

copy = Array.new(squares)</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        if (ARY_OWNS_HEAP_P(ary) &amp;&amp; RARRAY_PTR(ary)) {
            xfree(RARRAY_PTR(ary));
        }
        rb_ary_unshare_safe(ary);
        FL_SET_EMBED(ary);
        ARY_SET_EMBED_LEN(ary, 0);
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        return ary;
    }
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn(&quot;block supersedes default value argument&quot;);
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        memfill(RARRAY_PTR(ary), len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}</code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="try_convert-method" class="method-detail ">
          <a name="method-c-try_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">try_convert(obj) &rarr; array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Try to convert <em>obj</em> into an array, using <tt><a
href="Array.html#method-i-to_ary">to_ary</a></tt> method. Returns converted
array or <tt>nil</tt> if <em>obj</em> cannot be converted for any reason.
This method can be used to check if an argument is an array.</p>

<pre>Array.try_convert([1])   #=&gt; [1]
Array.try_convert(&quot;1&quot;)   #=&gt; nil

if tmp = Array.try_convert(arg)
  # the argument is an array
elsif tmp = String.try_convert(arg)
  # the argument is a string
end</pre>
            

            
            <div class="method-source-code" id="try_convert-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}</code>
</pre> 
            </div><!-- try_convert-source -->
            
          </div>

          

          
        </div><!-- try_convert-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="26-method" class="method-detail ">
          <a name="method-i-26"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary & other_ary      &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Set Intersection—Returns a new array containing elements common to the two
arrays, with no duplicates.</p>

<pre>[ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ]   #=&gt; [ 1, 3 ]</pre>
            

            
            <div class="method-source-code" id="26-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY_LEN(ary1) &lt; RARRAY_LEN(ary2) ?
            RARRAY_LEN(ary1) : RARRAY_LEN(ary2));
    hash = ary_make_hash(ary2);

    if (RHASH_EMPTY_P(hash))
        return ary3;

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = vv = rb_ary_elt(ary1, i);
        if (st_delete(RHASH_TBL(hash), (st_data_t*)&amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    ary_recycle_hash(hash);

    return ary3;
}</code>
</pre> 
            </div><!-- 26-source -->
            
          </div>

          

          
        </div><!-- 26-method -->

      
        <div id="2A-method" class="method-detail ">
          <a name="method-i-2A"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary * int     &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary * str     &rarr; new_string</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Repetition—With a <a href="String.html">String</a> argument, equivalent to
self.join(str). Otherwise, returns a new array built by concatenating the
<em>int</em> copies of <tt>self</tt>.</p>

<pre>[ 1, 2, 3 ] * 3    #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
[ 1, 2, 3 ] * &quot;,&quot;  #=&gt; &quot;1,2,3&quot;</pre>
            

            
            <div class="method-source-code" id="2A-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp, *ptr, *ptr2;
    long i, t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
        ary2 = ary_new(rb_obj_class(ary), 0);
        goto out;
    }
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_obj_class(ary), len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_PTR(ary);
    ptr2 = RARRAY_PTR(ary2);
    t = RARRAY_LEN(ary);
    for (i=0; i&lt;len; i+=t) {
        MEMCPY(ptr2+i, ptr, VALUE, t);
    }
  out:
    OBJ_INFECT(ary2, ary);

    return ary2;
}</code>
</pre> 
            </div><!-- 2A-source -->
            
          </div>

          

          
        </div><!-- 2A-method -->

      
        <div id="2B-method" class="method-detail ">
          <a name="method-i-2B"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary + other_ary   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Concatenation—Returns a new array built by concatenating the two arrays
together to produce a third array.</p>

<pre>[ 1, 2, 3 ] + [ 4, 5 ]    #=&gt; [ 1, 2, 3, 4, 5 ]</pre>
            

            
            <div class="method-source-code" id="2B-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len;

    y = to_ary(y);
    len = RARRAY_LEN(x) + RARRAY_LEN(y);
    z = rb_ary_new2(len);
    MEMCPY(RARRAY_PTR(z), RARRAY_PTR(x), VALUE, RARRAY_LEN(x));
    MEMCPY(RARRAY_PTR(z) + RARRAY_LEN(x), RARRAY_PTR(y), VALUE, RARRAY_LEN(y));
    ARY_SET_LEN(z, len);
    return z;
}</code>
</pre> 
            </div><!-- 2B-source -->
            
          </div>

          

          
        </div><!-- 2B-method -->

      
        <div id="2D-method" class="method-detail ">
          <a name="method-i-2D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary - other_ary    &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p><a href="Array.html">Array</a> Difference---Returns a new array that is a
copy of the original array, removing any items that also appear in
<em>other_ary</em>. (If you need set-like behavior, see the library class
Set.)</p>

<pre>[ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=&gt;  [ 3, 3, 5 ]</pre>
            

            
            <div class="method-source-code" id="2D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    volatile VALUE hash;
    long i;

    hash = ary_make_hash(to_ary(ary2));
    ary3 = rb_ary_new();

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        if (st_lookup(RHASH_TBL(hash), RARRAY_PTR(ary1)[i], 0)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }
    ary_recycle_hash(hash);
    return ary3;
}</code>
</pre> 
            </div><!-- 2D-source -->
            
          </div>

          

          
        </div><!-- 2D-method -->

      
        <div id="3C-3C-method" class="method-detail ">
          <a name="method-i-3C-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary << obj            &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Append—Pushes the given object on to the end of this array. This expression
returns the array itself, so several appends may be chained together.</p>

<pre>[ 1, 2 ] &lt;&lt; &quot;c&quot; &lt;&lt; &quot;d&quot; &lt;&lt; [ 3, 4 ]
        #=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]</pre>
            

            
            <div class="method-source-code" id="3C-3C-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    rb_ary_modify(ary);
    return rb_ary_push_1(ary, item);
}</code>
</pre> 
            </div><!-- 3C-3C-source -->
            
          </div>

          

          
        </div><!-- 3C-3C-method -->

      
        <div id="3C-3D-3E-method" class="method-detail ">
          <a name="method-i-3C-3D-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary <=> other_ary   &rarr;  -1, 0, +1 or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Comparison—Returns an integer (-1, 0, or +1) if this array is less than,
equal to, or greater than <em>other_ary</em>.  Each object in each array is
compared (using &lt;=&gt;). If any value isn’t equal, then that inequality
is the return value. If all the values found are equal, then the return is
based on a comparison of the array lengths.  Thus, two arrays are “equal”
according to <tt>Array#&lt;=&gt;</tt> if and only if they have the same
length and the value of each element is equal to the value of the
corresponding element in the other array.</p>

<pre>[ &quot;a&quot;, &quot;a&quot;, &quot;c&quot; ]    &lt;=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]   #=&gt; -1
[ 1, 2, 3, 4, 5, 6 ] &lt;=&gt; [ 1, 2 ]            #=&gt; +1</pre>
            

            
            <div class="method-source-code" id="3C-3D-3E-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (v != Qundef) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</code>
</pre> 
            </div><!-- 3C-3D-3E-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-3E-method -->

      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary == other_ary   &rarr;   bool</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Equality—Two arrays are equal if they contain the same number of elements
and if each element is equal to (according to <a
href="Object.html">Object</a>.==) the corresponding element in the other
array.</p>

<pre>[ &quot;a&quot;, &quot;c&quot; ]    == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; false
[ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; true
[ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;d&quot;, &quot;f&quot; ]   #=&gt; false</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) {
        if (!rb_respond_to(ary2, rb_intern(&quot;to_ary&quot;))) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}</code>
</pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary[index]                &rarr; obj     or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[start, length]        &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[range]                &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(index)          &rarr; obj     or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(start, length)  &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(range)          &rarr; new_ary or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Element Reference—Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>. Negative
indices count backward from the end of the array (-1 is the last element).
Returns <tt>nil</tt> if the index (or starting index) are out of range.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
a[6]                   #=&gt; nil
a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a[4..7]                #=&gt; [ &quot;e&quot; ]
a[6..10]               #=&gt; nil
a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
# special cases
a[5]                   #=&gt; nil
a[5, 1]                #=&gt; []
a[5..10]               #=&gt; []</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_aref(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg &lt; 0) {
            beg += RARRAY_LEN(ary);
        }
        return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
        rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
        return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qfalse:
        break;
      case Qnil:
        return Qnil;
      default:
        return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}</code>
</pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->

      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary[index]         = obj                      &rarr;  obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[start, length] = obj or other_ary or nil  &rarr;  obj or other_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[range]         = obj or other_ary or nil  &rarr;  obj or other_ary or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Element Assignment—Sets the element at <em>index</em>, or replaces a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or replaces a subarray specified by <em>range</em>.  If indices
are greater than the current capacity of the array, the array grows
automatically. A negative indices will count backward from the end of the
array. Inserts elements if <em>length</em> is zero. An <tt><a
href="IndexError.html">IndexError</a></tt> is raised if a negative index
points past the beginning of the array. See also <tt><a
href="Array.html#method-i-push">Array#push</a></tt>, and <tt><a
href="Array.html#method-i-unshift">Array#unshift</a></tt>.</p>

<pre>a = Array.new
a[4] = &quot;4&quot;;                 #=&gt; [nil, nil, nil, nil, &quot;4&quot;]
a[0, 3] = [ 'a', 'b', 'c' ] #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]
a[1..2] = [ 1, 2 ]          #=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]
a[0, 2] = &quot;?&quot;               #=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]
a[0..2] = &quot;A&quot;               #=&gt; [&quot;A&quot;, &quot;4&quot;]
a[-1]   = &quot;Z&quot;               #=&gt; [&quot;A&quot;, &quot;Z&quot;]
a[1..-1] = nil              #=&gt; [&quot;A&quot;, nil]
a[1..-1] = []               #=&gt; [&quot;A&quot;]</pre>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    if (argc == 3) {
        rb_ary_modify_check(ary);
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        rb_ary_splice(ary, beg, len, argv[2]);
        return argv[2];
    }
    if (argc != 2) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
    }
    rb_ary_modify_check(ary);
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        goto fixnum;
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        /* check if idx is Range */
        rb_ary_splice(ary, beg, len, argv[1]);
        return argv[1];
    }

    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(ary, offset, argv[1]);
    return argv[1];
}</code>
</pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->

      
        <div id="assoc-method" class="method-detail ">
          <a name="method-i-assoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">assoc(obj)   &rarr; new_ary  or  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Searches through an array whose elements are also arrays comparing
<em>obj</em> with the first element of each contained array using obj.==.
Returns the first contained array that matches (that is, the first
associated array), or <tt>nil</tt> if no match is found. See also <tt><a
href="Array.html#method-i-rassoc">Array#rassoc</a></tt>.</p>

<pre>s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]
s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
s3 = &quot;foo&quot;
a  = [ s1, s2, s3 ]
a.assoc(&quot;letters&quot;)  #=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.assoc(&quot;foo&quot;)      #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="assoc-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_PTR(ary)[i]);
        if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
            rb_equal(RARRAY_PTR(v)[0], key))
            return v;
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- assoc-source -->
            
          </div>

          

          
        </div><!-- assoc-method -->

      
        <div id="at-method" class="method-detail ">
          <a name="method-i-at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">at(index)   &rarr;   obj  or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the element at <em>index</em>. A negative index counts from the end
of <tt>self</tt>.  Returns <tt>nil</tt> if the index is out of range. See
also <tt>Array#[]</tt>.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
a.at(0)     #=&gt; &quot;a&quot;
a.at(-1)    #=&gt; &quot;e&quot;</pre>
            

            
            <div class="method-source-code" id="at-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}</code>
</pre> 
            </div><!-- at-source -->
            
          </div>

          

          
        </div><!-- at-method -->

      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">clear    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Removes all elements from <tt>self</tt>.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
a.clear    #=&gt; [ ]</pre>
            

            
            <div class="method-source-code" id="clear-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
        ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
    }
    return ary;
}</code>
</pre> 
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->

      
        <div id="collect-method" class="method-detail ">
          <a name="method-i-collect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect {|item| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map     {|item| block }  &rarr; new_ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                  &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                      &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes <em>block</em> once for each element of <tt>self</tt>. Creates a
new array containing the values returned by the block. See also <tt><a
href="Enumerable.html#method-i-collect">Enumerable#collect</a></tt>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>
            

            
            <div class="method-source-code" id="collect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_ENUMERATOR(ary, 0, 0);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return collect;
}</code>
</pre> 
            </div><!-- collect-source -->
            
          </div>

          

          
        </div><!-- collect-method -->

      
        <div id="collect-21-method" class="method-detail ">
          <a name="method-i-collect-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect! {|item| block }   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map!     {|item| block }   &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                    &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                        &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes the block once for each element of <tt>self</tt>, replacing the
element with the value returned by <em>block</em>. See also <tt><a
href="Enumerable.html#method-i-collect">Enumerable#collect</a></tt>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.collect! {|x| x + &quot;!&quot; }
a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</pre>
            

            
            <div class="method-source-code" id="collect-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return ary;
}</code>
</pre> 
            </div><!-- collect-21-source -->
            
          </div>

          

          
        </div><!-- collect-21-method -->

      
        <div id="combination-method" class="method-detail ">
          <a name="method-i-combination"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">combination(n) { |c| block }    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">combination(n)                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>When invoked with a block, yields all combinations of length <em>n</em> of
elements from <em>ary</em> and then returns <em>ary</em> itself. The
implementation makes no guarantees about the order in which the
combinations are yielded.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<p>Examples:</p>

<pre>a = [1, 2, 3, 4]
a.combination(1).to_a  #=&gt; [[1],[2],[3],[4]]
a.combination(2).to_a  #=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
a.combination(3).to_a  #=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
a.combination(4).to_a  #=&gt; [[1,2,3,4]]
a.combination(0).to_a  #=&gt; [[]] # one combination of length 0
a.combination(5).to_a  #=&gt; []   # no combinations of length 5</pre>
            

            
            <div class="method-source-code" id="combination-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);
    RETURN_ENUMERATOR(ary, 1, &amp;num);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
        }
    }
    else {
        volatile VALUE t0 = tmpbuf(n+1, sizeof(long));
        long *stack = (long*)RSTRING_PTR(t0);
        volatile VALUE cc = tmpary(n);
        VALUE *chosen = RARRAY_PTR(cc);
        long lev = 0;

        MEMZERO(stack, long, n);
        stack[0] = -1;
        for (;;) {
            chosen[lev] = RARRAY_PTR(ary)[stack[lev+1]];
            for (lev++; lev &lt; n; lev++) {
                chosen[lev] = RARRAY_PTR(ary)[stack[lev+1] = stack[lev]+1];
            }
            rb_yield(rb_ary_new4(n, chosen));
            if (RBASIC(t0)-&gt;klass) {
                rb_raise(rb_eRuntimeError, &quot;combination reentered&quot;);
            }
            do {
                if (lev == 0) goto done;
                stack[lev--]++;
            } while (stack[lev+1]+n == len+lev+1);
        }
    done:
        tmpbuf_discard(t0);
        tmpary_discard(cc);
    }
    return ary;
}</code>
</pre> 
            </div><!-- combination-source -->
            
          </div>

          

          
        </div><!-- combination-method -->

      
        <div id="compact-method" class="method-detail ">
          <a name="method-i-compact"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact     &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a copy of <tt>self</tt> with all <tt>nil</tt> elements removed.</p>

<pre>[ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact
                  #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</pre>
            

            
            <div class="method-source-code" id="compact-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}</code>
</pre> 
            </div><!-- compact-source -->
            
          </div>

          

          
        </div><!-- compact-method -->

      
        <div id="compact-21-method" class="method-detail ">
          <a name="method-i-compact-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact!    &rarr; ary  or  nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Removes <tt>nil</tt> elements from the array. Returns <tt>nil</tt> if no
changes were made, otherwise returns &lt;/i&gt;ary&lt;/i&gt;.</p>

<pre>[ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="compact-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = RARRAY_PTR(ary);
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    n = p - RARRAY_PTR(ary);
    if (RARRAY_LEN(ary) == n) {
        return Qnil;
    }
    ARY_SET_LEN(ary, n);
    if (n * 2 &lt; ARY_CAPA(ary) &amp;&amp; ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
        ary_resize_capa(ary, n * 2);
    }

    return ary;
}</code>
</pre> 
            </div><!-- compact-21-source -->
            
          </div>

          

          
        </div><!-- compact-21-method -->

      
        <div id="concat-method" class="method-detail ">
          <a name="method-i-concat"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">concat(other_ary)   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Appends the elements of <em>other_ary</em> to <tt>self</tt>.</p>

<pre>[ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</pre>
            

            
            <div class="method-source-code" id="concat-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_concat(VALUE x, VALUE y)
{
    rb_ary_modify_check(x);
    y = to_ary(y);
    if (RARRAY_LEN(y) &gt; 0) {
        rb_ary_splice(x, RARRAY_LEN(x), 0, y);
    }
    return x;
}</code>
</pre> 
            </div><!-- concat-source -->
            
          </div>

          

          
        </div><!-- concat-method -->

      
        <div id="count-method" class="method-detail ">
          <a name="method-i-count"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">count      &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count(obj) &rarr; int</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">count { |item| block }  &rarr; int</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the number of elements.  If an argument is given, counts the number
of elements which equals to <em>obj</em>.  If a block is given, counts the
number of elements yielding a true value.</p>

<pre>ary = [1, 2, 4, 2]
ary.count             #=&gt; 4
ary.count(2)          #=&gt; 2
ary.count{|x|x%2==0}  #=&gt; 3</pre>
            

            
            <div class="method-source-code" id="count-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long n = 0;

    if (argc == 0) {
        VALUE *p, *pend;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
            if (RTEST(rb_yield(*p))) n++;
        }
    }
    else {
        VALUE obj, *p, *pend;

        rb_scan_args(argc, argv, &quot;1&quot;, &amp;obj);
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
            if (rb_equal(*p, obj)) n++;
        }
    }

    return LONG2NUM(n);
}</code>
</pre> 
            </div><!-- count-source -->
            
          </div>

          

          
        </div><!-- count-method -->

      
        <div id="cycle-method" class="method-detail ">
          <a name="method-i-cycle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil) {|obj| block }  &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">cycle(n=nil)                 &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> for each element repeatedly <em>n</em> times or
forever if none or <tt>nil</tt> is given.  If a non-positive number is
given or the array is empty, does nothing.  Returns <tt>nil</tt> if the
loop has finished without getting interrupted.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.</pre>
            

            
            <div class="method-source-code" id="cycle-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;
    VALUE nv = Qnil;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(ary, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_PTR(ary)[i]);
        }
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- cycle-source -->
            
          </div>

          

          
        </div><!-- cycle-method -->

      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete(obj)            &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete(obj) { block }  &rarr; obj or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Deletes items from <tt>self</tt> that are equal to <em>obj</em>. If any
items are found, returns <em>obj</em>.   If the item is not found, returns
<tt>nil</tt>. If the optional code block is given, returns the result of
<em>block</em> if the item is not found.  (To remove <tt>nil</tt> elements
and get an informative return value, use <a
href="Array.html#method-i-compact-21">compact!</a>)</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
a.delete(&quot;b&quot;)                   #=&gt; &quot;b&quot;
a                               #=&gt; [&quot;a&quot;, &quot;c&quot;]
a.delete(&quot;z&quot;)                   #=&gt; nil
a.delete(&quot;z&quot;) { &quot;not found&quot; }   #=&gt; &quot;not found&quot;</pre>
            

            
            <div class="method-source-code" id="delete-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE e = RARRAY_PTR(ary)[i1];

        if (rb_equal(e, item)) {
            v = e;
            continue;
        }
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    rb_ary_modify(ary);
    if (RARRAY_LEN(ary) &gt; i2) {
        ARY_SET_LEN(ary, i2);
        if (i2 * 2 &lt; ARY_CAPA(ary) &amp;&amp;
            ARY_CAPA(ary) &gt; ARY_DEFAULT_SIZE) {
            ary_resize_capa(ary, i2*2);
        }
    }

    return v;
}</code>
</pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->

      
        <div id="delete_at-method" class="method-detail ">
          <a name="method-i-delete_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_at(index)  &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Deletes the element at the specified index, returning that element, or
<tt>nil</tt> if the index is out of range. See also <tt><a
href="Array.html#method-i-slice-21">Array#slice!</a></tt>.</p>

<pre>a = %w( ant bat cat dog )
a.delete_at(2)    #=&gt; &quot;cat&quot;
a                 #=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]
a.delete_at(99)   #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="delete_at-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}</code>
</pre> 
            </div><!-- delete_at-source -->
            
          </div>

          

          
        </div><!-- delete_at-method -->

      
        <div id="delete_if-method" class="method-detail ">
          <a name="method-i-delete_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_if {|item| block }  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete_if                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Deletes every element of <tt>self</tt> for which <em>block</em> evaluates
to true. See also <tt><a
href="Array.html#method-i-reject-21">Array#reject!</a></tt></p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.delete_if {|x| x &gt;= &quot;b&quot; }   #=&gt; [&quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="delete_if-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_delete_if(VALUE ary)
{
    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_reject_bang(ary);
    return ary;
}</code>
</pre> 
            </div><!-- delete_if-source -->
            
          </div>

          

          
        </div><!-- delete_if-method -->

      
        <div id="drop-method" class="method-detail ">
          <a name="method-i-drop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop(n)               &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Drops first n elements from <em>ary</em>, and returns rest elements in an
array.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.drop(3)             #=&gt; [4, 5, 0]</pre>
            

            
            <div class="method-source-code" id="drop-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (result == Qnil) result = rb_ary_new();
    return result;
}</code>
</pre> 
            </div><!-- drop-source -->
            
          </div>

          

          
        </div><!-- drop-method -->

      
        <div id="drop_while-method" class="method-detail ">
          <a name="method-i-drop_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">drop_while {|arr| block }   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">drop_while                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Drops elements up to, but not including, the first element for which the
block returns <tt>nil</tt> or <tt>false</tt> and returns an array
containing the remaining elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.drop_while {|i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]</pre>
            

            
            <div class="method-source-code" id="drop_while-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_PTR(ary)[i]))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}</code>
</pre> 
            </div><!-- drop_while-source -->
            
          </div>

          

          
        </div><!-- drop_while-method -->

      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each {|item| block }   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Calls <em>block</em> once for each element in <tt>self</tt>, passing that
element as a parameter.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.each {|x| print x, &quot; -- &quot; }</pre>

<p>produces:</p>

<pre>a -- b -- c --</pre>
            

            
            <div class="method-source-code" id="each-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_each(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(RARRAY_PTR(ary)[i]);
    }
    return ary;
}</code>
</pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->

      
        <div id="each_index-method" class="method-detail ">
          <a name="method-i-each_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_index {|index| block }  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_index                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Same as <tt><a href="Array.html#method-i-each">Array#each</a></tt>, but
passes the index of the element instead of the element itself.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.each_index {|x| print x, &quot; -- &quot; }</pre>

<p>produces:</p>

<pre>0 -- 1 -- 2 --</pre>
            

            
            <div class="method-source-code" id="each_index-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_ENUMERATOR(ary, 0, 0);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}</code>
</pre> 
            </div><!-- each_index-source -->
            
          </div>

          

          
        </div><!-- each_index-method -->

      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">empty?   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>true</tt> if <tt>self</tt> contains no elements.</p>

<pre>[].empty?   #=&gt; true</pre>
            

            
            <div class="method-source-code" id="empty-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_empty_p(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0)
        return Qtrue;
    return Qfalse;
}</code>
</pre> 
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->

      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eql?(other)  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>true</tt> if <tt>self</tt> and <em>other</em> are the same
object, or are both arrays with the same content.</p>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}</code>
</pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->

      
        <div id="fetch-method" class="method-detail ">
          <a name="method-i-fetch"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index)                    &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index, default )          &rarr; obj</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(index) {|index| block }   &rarr; obj</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Tries to return the element at position <em>index</em>. If the index lies
outside the array, the first form throws an <tt><a
href="IndexError.html">IndexError</a></tt> exception, the second form
returns <em>default</em>, and the third form returns the value of invoking
the block, passing in the index. Negative values of <em>index</em> count
from the end of the array.</p>

<pre>a = [ 11, 22, 33, 44 ]
a.fetch(1)               #=&gt; 22
a.fetch(-1)              #=&gt; 44
a.fetch(4, 'cat')        #=&gt; &quot;cat&quot;
a.fetch(4) { |i| i*i }   #=&gt; 16</pre>
            

            
            <div class="method-source-code" id="fetch-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, &quot;index %ld outside of array bounds: %ld...%ld&quot;,
                        idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
        }
        return ifnone;
    }
    return RARRAY_PTR(ary)[idx];
}</code>
</pre> 
            </div><!-- fetch-source -->
            
          </div>

          

          
        </div><!-- fetch-method -->

      
        <div id="fill-method" class="method-detail ">
          <a name="method-i-fill"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj)                                &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj, start [, length])              &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(obj, range )                        &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill {|index| block }                    &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(start [, length] ) {|index| block } &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fill(range) {|index| block }             &rarr; ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>The first three forms set the selected elements of <tt>self</tt> (which may
be the entire array) to <em>obj</em>. A <em>start</em> of <tt>nil</tt> is
equivalent to zero. A <em>length</em> of <tt>nil</tt> is equivalent to
<em>self.length</em>. The last three forms fill the array with the value of
the block. The block is passed the absolute index of each element to be
filled. Negative values of <em>start</em> count from the end of the array.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.fill(&quot;x&quot;)              #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]
a.fill(&quot;z&quot;, 2, 2)        #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]
a.fill(&quot;y&quot;, 0..1)        #=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]
a.fill {|i| i*i}         #=&gt; [0, 1, 4, 9]
a.fill(-2) {|i| i*i*i}   #=&gt; [0, 1, 8, 27]</pre>
            

            
            <div class="method-source-code" id="fill-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item, arg1, arg2;
    long beg = 0, end = 0, len = 0;
    VALUE *p, *pend;
    int block_p = FALSE;

    if (rb_block_given_p()) {
        block_p = TRUE;
        rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
        argc += 1;             /* hackish */
    }
    else {
        rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY_LEN(ary);
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY_LEN(ary) + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
        if (end &gt;= ARY_CAPA(ary)) {
            ary_resize_capa(ary, end);
        }
        rb_mem_clear(RARRAY_PTR(ary) + RARRAY_LEN(ary), end - RARRAY_LEN(ary));
        ARY_SET_LEN(ary, end);
    }

    if (block_p) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY_LEN(ary)) break;
            RARRAY_PTR(ary)[i] = v;
        }
    }
    else {
        p = RARRAY_PTR(ary) + beg;
        pend = p + len;
        while (p &lt; pend) {
            *p++ = item;
        }
    }
    return ary;
}</code>
</pre> 
            </div><!-- fill-source -->
            
          </div>

          

          
        </div><!-- fill-method -->

      
        <div id="find_index-method" class="method-detail ">
          <a name="method-i-find_index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">index(obj)           &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index {|item| block} &rarr;  int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index                &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the index of the first object in <tt>self</tt> such that is
<tt>==</tt> to <em>obj</em>. If a block is given instead of an argument,
returns first object for which <em>block</em> is true. Returns <tt>nil</tt>
if no match is found. See also <tt><a
href="Array.html#method-i-rindex">Array#rindex</a></tt>.</p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.index(&quot;b&quot;)        #=&gt; 1
a.index(&quot;z&quot;)        #=&gt; nil
a.index{|x|x==&quot;b&quot;}  #=&gt; 1</pre>

<p>This is an alias of <tt><a
href="Array.html#method-i-find_index">find_index</a></tt>.</p>
            

            
            <div class="method-source-code" id="find_index-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;val);
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        if (rb_equal(RARRAY_PTR(ary)[i], val))
            return LONG2NUM(i);
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- find_index-source -->
            
          </div>

          

          
        </div><!-- find_index-method -->

      
        <div id="first-method" class="method-detail ">
          <a name="method-i-first"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">first     &rarr;   obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">first(n)  &rarr;   new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the first element, or the first <tt>n</tt> elements, of the array.
If the array is empty, the first form returns <tt>nil</tt>, and the second
form returns an empty array.</p>

<pre>a = [ &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot; ]
a.first     #=&gt; &quot;q&quot;
a.first(2)  #=&gt; [&quot;q&quot;, &quot;r&quot;]</pre>
            

            
            <div class="method-source-code" id="first-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_first(int argc, VALUE *argv, VALUE ary)
{
    if (argc == 0) {
        if (RARRAY_LEN(ary) == 0) return Qnil;
        return RARRAY_PTR(ary)[0];
    }
    else {
        return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    }
}</code>
</pre> 
            </div><!-- first-source -->
            
          </div>

          

          
        </div><!-- first-method -->

      
        <div id="flatten-method" class="method-detail ">
          <a name="method-i-flatten"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten(level) &rarr; new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array that is a one-dimensional flattening of this array
(recursively). That is, for every element that is an array, extract its
elements into the new array.  If the optional <em>level</em> argument
determines the level of recursion to flatten.</p>

<pre>s = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
t = [ 4, 5, 6, [7, 8] ]   #=&gt; [4, 5, 6, [7, 8]]
a = [ s, t, 9, 10 ]       #=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
a.flatten                 #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a = [ 1, 2, [3, [4, 5] ] ]
a.flatten(1)              #=&gt; [1, 2, 3, [4, 5]]</pre>
            

            
            <div class="method-source-code" id="flatten-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary_make_shared_copy(ary);

    result = flatten(ary, level, &amp;mod);
    OBJ_INFECT(result, ary);

    return result;
}</code>
</pre> 
            </div><!-- flatten-source -->
            
          </div>

          

          
        </div><!-- flatten-method -->

      
        <div id="flatten-21-method" class="method-detail ">
          <a name="method-i-flatten-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten!        &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten!(level) &rarr; array or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Flattens <tt>self</tt> in place. Returns <tt>nil</tt> if no modifications
were made (i.e., <em>ary</em> contains no subarrays.)  If the optional
<em>level</em> argument determines the level of recursion to flatten.</p>

<pre>a = [ 1, 2, [3, [4, 5] ] ]
a.flatten!   #=&gt; [1, 2, 3, 4, 5]
a.flatten!   #=&gt; nil
a            #=&gt; [1, 2, 3, 4, 5]
a = [ 1, 2, [3, [4, 5] ] ]
a.flatten!(1) #=&gt; [1, 2, 3, [4, 5]]</pre>
            

            
            <div class="method-source-code" id="flatten-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level, &amp;mod);
    if (mod == 0) {
        ary_discard(result);
        return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_obj_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}</code>
</pre> 
            </div><!-- flatten-21-source -->
            
          </div>

          

          
        </div><!-- flatten-21-method -->

      
        <div id="frozen-3F-method" class="method-detail ">
          <a name="method-i-frozen-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">frozen?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Return <tt>true</tt> if this array is frozen (or temporarily frozen while
being sorted).</p>
            

            
            <div class="method-source-code" id="frozen-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_frozen_p(VALUE ary)
{
    if (OBJ_FROZEN(ary)) return Qtrue;
    return Qfalse;
}</code>
</pre> 
            </div><!-- frozen-3F-source -->
            
          </div>

          

          
        </div><!-- frozen-3F-method -->

      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash   &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Compute a hash-code for this array. Two arrays with the same content will
have the same hash code (and will compare using <tt>eql?</tt>).</p>
            

            
            <div class="method-source-code" id="hash-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_hash(VALUE ary)
{
    return rb_exec_recursive_outer(recursive_hash, ary, 0);
}</code>
</pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->

      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(obj)   &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>true</tt> if the given object is present in <tt>self</tt> (that
is, if any object <tt>==</tt> <em>an<a href="Object.html">Object</a></em>),
<tt>false</tt> otherwise.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.include?(&quot;b&quot;)   #=&gt; true
a.include?(&quot;z&quot;)   #=&gt; false</pre>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        if (rb_equal(RARRAY_PTR(ary)[i], item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}</code>
</pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->

      
        <div id="index-method" class="method-detail ">
          <a name="method-i-index"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">index(obj)           &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index {|item| block} &rarr;  int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">index                &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the index of the first object in <tt>self</tt> such that is
<tt>==</tt> to <em>obj</em>. If a block is given instead of an argument,
returns first object for which <em>block</em> is true. Returns <tt>nil</tt>
if no match is found. See also <tt><a
href="Array.html#method-i-rindex">Array#rindex</a></tt>.</p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.index(&quot;b&quot;)        #=&gt; 1
a.index(&quot;z&quot;)        #=&gt; nil
a.index{|x|x==&quot;b&quot;}  #=&gt; 1</pre>

<p>This is an alias of <tt><a
href="Array.html#method-i-find_index">find_index</a></tt>.</p>
            

            
            <div class="method-source-code" id="index-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
                return LONG2NUM(i);
            }
        }
        return Qnil;
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;val);
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        if (rb_equal(RARRAY_PTR(ary)[i], val))
            return LONG2NUM(i);
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- index-source -->
            
          </div>

          

          
        </div><!-- index-method -->

      
        <div id="initialize_copy-method" class="method-detail ">
          <a name="method-i-initialize_copy"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_ary)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Replaces the contents of <tt>self</tt> with the contents of
<em>other_ary</em>, truncating or expanding if necessary.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</pre>
            

            
            <div class="method-source-code" id="initialize_copy-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE *ptr;
        VALUE shared = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else if (ARY_SHARED_P(copy)) {
            shared = ARY_SHARED(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ptr = RARRAY_PTR(orig);
        MEMCPY(RARRAY_PTR(copy), ptr, VALUE, RARRAY_LEN(orig));
        if (shared) {
            rb_ary_decrement_share(shared);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, RARRAY_PTR(orig));
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
        rb_ary_set_shared(copy, shared);
    }
    return copy;
}</code>
</pre> 
            </div><!-- initialize_copy-source -->
            
          </div>

          

          
        </div><!-- initialize_copy-method -->

      
        <div id="insert-method" class="method-detail ">
          <a name="method-i-insert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">insert(index, obj...)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Inserts the given values before the element with the given index (which may
be negative).</p>

<pre>a = %w{ a b c d }
a.insert(2, 99)         #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]
a.insert(-2, 1, 2, 3)   #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]</pre>
            

            
            <div class="method-source-code" id="insert-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    if (argc &lt; 1) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
    }
    rb_ary_modify_check(ary);
    if (argc == 1) return ary;
    pos = NUM2LONG(argv[0]);
    if (pos == -1) {
        pos = RARRAY_LEN(ary);
    }
    if (pos &lt; 0) {
        pos++;
    }
    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
    return ary;
}</code>
</pre> 
            </div><!-- insert-source -->
            
          </div>

          

          
        </div><!-- insert-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">inspect  &rarr; string</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Creates a string representation of <tt>self</tt>.</p>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2(&quot;[]&quot;);
    return rb_exec_recursive(inspect_ary, ary, 0);
}</code>
</pre> 
            </div><!-- inspect-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Array.html#method-i-to_s">to_s</a>
          </div>
          

          
        </div><!-- inspect-method -->

      
        <div id="join-method" class="method-detail ">
          <a name="method-i-join"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">join(sep=$,)    &rarr; str</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a string created by converting each element of the array to a
string, separated by <em>sep</em>.</p>

<pre>[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        #=&gt; &quot;abc&quot;
[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   #=&gt; &quot;a-b-c&quot;</pre>
            

            
            <div class="method-source-code" id="join-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;sep);
    if (NIL_P(sep)) sep = rb_output_fs;

    return rb_ary_join(ary, sep);
}</code>
</pre> 
            </div><!-- join-source -->
            
          </div>

          

          
        </div><!-- join-method -->

      
        <div id="keep_if-method" class="method-detail ">
          <a name="method-i-keep_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">keep_if {|item| block } &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">keep_if                 &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Deletes every element of <tt>self</tt> for which <em>block</em> evaluates
to false. See also <tt><a
href="Array.html#method-i-select-21">Array#select!</a></tt></p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = %w{ a b c d e f }
a.keep_if {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]</pre>
            

            
            <div class="method-source-code" id="keep_if-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_select_bang(ary);
    return ary;
}</code>
</pre> 
            </div><!-- keep_if-source -->
            
          </div>

          

          
        </div><!-- keep_if-method -->

      
        <div id="last-method" class="method-detail ">
          <a name="method-i-last"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">last     &rarr;  obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">last(n)  &rarr;  new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the last element(s) of <tt>self</tt>. If the array is empty, the
first form returns <tt>nil</tt>.</p>

<pre>a = [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ]
a.last     #=&gt; &quot;z&quot;
a.last(2)  #=&gt; [&quot;y&quot;, &quot;z&quot;]</pre>
            

            
            <div class="method-source-code" id="last-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_last(int argc, VALUE *argv, VALUE ary)
{
    if (argc == 0) {
        if (RARRAY_LEN(ary) == 0) return Qnil;
        return RARRAY_PTR(ary)[RARRAY_LEN(ary)-1];
    }
    else {
        return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    }
}</code>
</pre> 
            </div><!-- last-source -->
            
          </div>

          

          
        </div><!-- last-method -->

      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length &rarr; int</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the number of elements in <tt>self</tt>. May be zero.</p>

<pre>[ 1, 2, 3, 4, 5 ].length   #=&gt; 5</pre>
            

            
            <div class="method-source-code" id="length-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}</code>
</pre> 
            </div><!-- length-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Array.html#method-i-size">size</a>
          </div>
          

          
        </div><!-- length-method -->

      
        <div id="map-method" class="method-detail ">
          <a name="method-i-map"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect {|item| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map     {|item| block }  &rarr; new_ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                  &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                      &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes <em>block</em> once for each element of <tt>self</tt>. Creates a
new array containing the values returned by the block. See also <tt><a
href="Enumerable.html#method-i-collect">Enumerable#collect</a></tt>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>
            

            
            <div class="method-source-code" id="map-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_ENUMERATOR(ary, 0, 0);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return collect;
}</code>
</pre> 
            </div><!-- map-source -->
            
          </div>

          

          
        </div><!-- map-method -->

      
        <div id="map-21-method" class="method-detail ">
          <a name="method-i-map-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">collect! {|item| block }   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map!     {|item| block }   &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">collect                    &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">map                        &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes the block once for each element of <tt>self</tt>, replacing the
element with the value returned by <em>block</em>. See also <tt><a
href="Enumerable.html#method-i-collect">Enumerable#collect</a></tt>.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.collect! {|x| x + &quot;!&quot; }
a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</pre>
            

            
            <div class="method-source-code" id="map-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return ary;
}</code>
</pre> 
            </div><!-- map-21-source -->
            
          </div>

          

          
        </div><!-- map-21-method -->

      
        <div id="pack-method" class="method-detail ">
          <a name="method-i-pack"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pack ( aTemplateString ) &rarr; aBinaryString</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Packs the contents of <em>arr</em> into a binary sequence according to the
directives in <em>aTemplateString</em> (see the table below) Directives
“A,” “a,” and “Z” may be followed by a count, which gives the width of the
resulting field. The remaining directives also may take a count, indicating
the number of array elements to convert. If the count is an asterisk
(“<tt>*</tt>”), all remaining array elements will be converted. Any of the
directives “<tt>sSiIlL</tt>” may be followed by an underscore
(“<tt>_</tt>”) or exclamation mark (“<tt>!</tt>”) to use the underlying
platform’s native size for the specified type; otherwise, they use a
platform-independent size. Spaces are ignored in the template string. See
also <tt><a href="String.html#method-i-unpack">String#unpack</a></tt>.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
n = [ 65, 66, 67 ]
a.pack(&quot;A3A3A3&quot;)   #=&gt; &quot;a  b  c  &quot;
a.pack(&quot;a3a3a3&quot;)   #=&gt; &quot;a\000\000b\000\000c\000\000&quot;
n.pack(&quot;ccc&quot;)      #=&gt; &quot;ABC&quot;</pre>

<p>Directives for <tt>pack</tt>.</p>

<pre>Integer      | Array   |
Directive    | Element | Meaning
---------------------------------------------------------------------------
   C         | Integer | 8-bit unsigned integer (unsigned char)
   S         | Integer | 16-bit unsigned integer, native endian (uint16_t)
   L         | Integer | 32-bit unsigned integer, native endian (uint32_t)
   Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)
             |         |
   c         | Integer | 8-bit signed integer (char)
   s         | Integer | 16-bit signed integer, native endian (int16_t)
   l         | Integer | 32-bit signed integer, native endian (int32_t)
   q         | Integer | 64-bit signed integer, native endian (int64_t)
             |         |
   S_, S!    | Integer | unsigned short, native endian
   I, I_, I! | Integer | unsigned int, native endian
   L_, L!    | Integer | unsigned long, native endian
             |         |
   s_, s!    | Integer | signed short, native endian
   i, i_, i! | Integer | signed int, native endian
   l_, l!    | Integer | signed long, native endian
             |         |
   n         | Integer | 16-bit unsigned integer, network (big-endian) byte order
   N         | Integer | 32-bit unsigned integer, network (big-endian) byte order
   v         | Integer | 16-bit unsigned integer, VAX (little-endian) byte order
   V         | Integer | 32-bit unsigned integer, VAX (little-endian) byte order
             |         |
   U         | Integer | UTF-8 character
   w         | Integer | BER-compressed integer

Float        |         |
Directive    |         | Meaning
---------------------------------------------------------------------------
   D, d      | Float   | double-precision float, native format
   F, f      | Float   | single-precision float, native format
   E         | Float   | double-precision float, little-endian byte order
   e         | Float   | single-precision float, little-endian byte order
   G         | Float   | double-precision float, network (big-endian) byte order
   g         | Float   | single-precision float, network (big-endian) byte order

String       |         |
Directive    |         | Meaning
---------------------------------------------------------------------------
   A         | String  | arbitrary binary string (space padded, count is width)
   a         | String  | arbitrary binary string (null padded, count is width)
   Z         | String  | same as ``a'', except that null is added with *
   B         | String  | bit string (MSB first)
   b         | String  | bit string (LSB first)
   H         | String  | hex string (high nibble first)
   h         | String  | hex string (low nibble first)
   u         | String  | UU-encoded string
   M         | String  | quoted printable, MIME encoding (see RFC2045)
   m         | String  | base64 encoded string (see RFC 2045, count is width)
             |         | (if count is 0, no line feed are added, see RFC 4648)
   P         | String  | pointer to a structure (fixed-length string)
   p         | String  | pointer to a null-terminated string

Misc.        |         |
Directive    |         | Meaning
---------------------------------------------------------------------------
   @         | ---     | moves to absolute position
   X         | ---     | back up a byte
   x         | ---     | null byte</pre>
            

            
            <div class="method-source-code" id="pack-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
pack_pack(VALUE ary, VALUE fmt)
{
    static const char nul10[] = &quot;\0\0\0\0\0\0\0\0\0\0&quot;;
    static const char spc10[] = &quot;          &quot;;
    const char *p, *pend;
    VALUE res, from, associates = 0;
    char type;
    long items, len, idx, plen;
    const char *ptr;
    int enc_info = 1;           /* 0 - BINARY, 1 - US-ASCII, 2 - UTF-8 */
#ifdef NATINT_PACK
    int natint;         /* native integer */
#endif
    int signed_p, integer_size, bigendian_p;

    StringValue(fmt);
    p = RSTRING_PTR(fmt);
    pend = p + RSTRING_LEN(fmt);
    res = rb_str_buf_new(0);

    items = RARRAY_LEN(ary);
    idx = 0;

#define TOO_FEW (rb_raise(rb_eArgError, toofew), 0)
#define THISFROM (items &gt; 0 ? RARRAY_PTR(ary)[idx] : TOO_FEW)
#define NEXTFROM (items-- &gt; 0 ? RARRAY_PTR(ary)[idx++] : TOO_FEW)

    while (p &lt; pend) {
        if (RSTRING_PTR(fmt) + RSTRING_LEN(fmt) != pend) {
            rb_raise(rb_eRuntimeError, &quot;format string modified&quot;);
        }
        type = *p++;           /* get data type */
#ifdef NATINT_PACK
        natint = 0;
#endif

        if (ISSPACE(type)) continue;
        if (type == '#') {
            while ((p &lt; pend) &amp;&amp; (*p != '\n')) {
                p++;
            }
            continue;
        }
        if (*p == '_' || *p == '!') {
            static const char natstr[] = &quot;sSiIlL&quot;;

            if (strchr(natstr, type)) {
#ifdef NATINT_PACK
                natint = 1;
#endif
                p++;
            }
            else {
                rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, natstr);
            }
        }
        if (*p == '*') {       /* set data length */
            len = strchr(&quot;@Xxu&quot;, type) ? 0
                : strchr(&quot;PMm&quot;, type) ? 1
                : items;
            p++;
        }
        else if (ISDIGIT(*p)) {
            errno = 0;
            len = STRTOUL(p, (char**)&amp;p, 10);
            if (errno) {
                rb_raise(rb_eRangeError, &quot;pack length too big&quot;);
            }
        }
        else {
            len = 1;
        }

        switch (type) {
          case 'U':
            /* if encoding is US-ASCII, upgrade to UTF-8 */
            if (enc_info == 1) enc_info = 2;
            break;
          case 'm': case 'M': case 'u':
            /* keep US-ASCII (do nothing) */
            break;
          default:
            /* fall back to BINARY */
            enc_info = 0;
            break;
        }
        switch (type) {
          case 'A': case 'a': case 'Z':
          case 'B': case 'b':
          case 'H': case 'h':
            from = NEXTFROM;
            if (NIL_P(from)) {
                ptr = &quot;&quot;;
                plen = 0;
            }
            else {
                StringValue(from);
                ptr = RSTRING_PTR(from);
                plen = RSTRING_LEN(from);
                OBJ_INFECT(res, from);
            }

            if (p[-1] == '*')
                len = plen;

            switch (type) {
              case 'a':                /* arbitrary binary string (null padded)  */
              case 'A':         /* arbitrary binary string (ASCII space padded) */
              case 'Z':         /* null terminated string  */
                if (plen &gt;= len) {
                    rb_str_buf_cat(res, ptr, len);
                    if (p[-1] == '*' &amp;&amp; type == 'Z')
                        rb_str_buf_cat(res, nul10, 1);
                }
                else {
                    rb_str_buf_cat(res, ptr, plen);
                    len -= plen;
                    while (len &gt;= 10) {
                        rb_str_buf_cat(res, (type == 'A')?spc10:nul10, 10);
                        len -= 10;
                    }
                    rb_str_buf_cat(res, (type == 'A')?spc10:nul10, len);
                }
                break;

              case 'b':                /* bit string (ascending) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len - plen + 1)/2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (*ptr &amp; 1)
                            byte |= 128;
                        if (i &amp; 7)
                            byte &gt;&gt;= 1;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 7) {
                        char c;
                        byte &gt;&gt;= 7 - (len &amp; 7);
                        c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'B':                /* bit string (descending) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len - plen + 1)/2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        byte |= *ptr &amp; 1;
                        if (i &amp; 7)
                            byte &lt;&lt;= 1;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 7) {
                        char c;
                        byte &lt;&lt;= 7 - (len &amp; 7);
                        c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'h':                /* hex string (low nibble first) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len + 1) / 2 - (plen + 1) / 2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (ISALPHA(*ptr))
                            byte |= (((*ptr &amp; 15) + 9) &amp; 15) &lt;&lt; 4;
                        else
                            byte |= (*ptr &amp; 15) &lt;&lt; 4;
                        if (i &amp; 1)
                            byte &gt;&gt;= 4;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 1) {
                        char c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;

              case 'H':                /* hex string (high nibble first) */
                {
                    int byte = 0;
                    long i, j = 0;

                    if (len &gt; plen) {
                        j = (len + 1) / 2 - (plen + 1) / 2;
                        len = plen;
                    }
                    for (i=0; i++ &lt; len; ptr++) {
                        if (ISALPHA(*ptr))
                            byte |= ((*ptr &amp; 15) + 9) &amp; 15;
                        else
                            byte |= *ptr &amp; 15;
                        if (i &amp; 1)
                            byte &lt;&lt;= 4;
                        else {
                            char c = byte &amp; 0xff;
                            rb_str_buf_cat(res, &amp;c, 1);
                            byte = 0;
                        }
                    }
                    if (len &amp; 1) {
                        char c = byte &amp; 0xff;
                        rb_str_buf_cat(res, &amp;c, 1);
                    }
                    len = j;
                    goto grow;
                }
                break;
            }
            break;

          case 'c':            /* signed char */
          case 'C':            /* unsigned char */
            while (len-- &gt; 0) {
                char c;

                from = NEXTFROM;
                c = (char)num2i32(from);
                rb_str_buf_cat(res, &amp;c, sizeof(char));
            }
            break;

          case 's':            /* signed short */
            signed_p = 1;
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'S':            /* unsigned short */
            signed_p = 0;
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'i':            /* signed int */
            signed_p = 1;
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'I':            /* unsigned int */
            signed_p = 0;
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'l':            /* signed long */
            signed_p = 1;
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'L':            /* unsigned long */
            signed_p = 0;
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'q':            /* signed quad (64bit) int */
            signed_p = 1;
            integer_size = 8;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'Q':            /* unsigned quad (64bit) int */
            signed_p = 0;
            integer_size = 8;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

          case 'n':            /* unsigned short (network byte-order)  */
            signed_p = 0;
            integer_size = 2;
            bigendian_p = 1;
            goto pack_integer;

          case 'N':            /* unsigned long (network byte-order) */
            signed_p = 0;
            integer_size = 4;
            bigendian_p = 1;
            goto pack_integer;

          case 'v':            /* unsigned short (VAX byte-order) */
            signed_p = 0;
            integer_size = 2;
            bigendian_p = 0;
            goto pack_integer;

          case 'V':            /* unsigned long (VAX byte-order) */
            signed_p = 0;
            integer_size = 4;
            bigendian_p = 0;
            goto pack_integer;

          pack_integer:
            switch (integer_size) {
#if defined(HAVE_INT16_T) &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT16_T:
                while (len-- &gt; 0) {
                    union {
                        int16_t i;
                        char a[sizeof(int16_t)];
                    } v;

                    from = NEXTFROM;
                    v.i = (int16_t)num2i32(from);
                    if (bigendian_p != BIGENDIAN_P()) v.i = swap16(v.i);
                    rb_str_buf_cat(res, v.a, sizeof(int16_t));
                }
                break;
#endif

#if defined(HAVE_INT32_T) &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT32_T:
                while (len-- &gt; 0) {
                    union {
                        int32_t i;
                        char a[sizeof(int32_t)];
                    } v;

                    from = NEXTFROM;
                    v.i = (int32_t)num2i32(from);
                    if (bigendian_p != BIGENDIAN_P()) v.i = swap32(v.i);
                    rb_str_buf_cat(res, v.a, sizeof(int32_t));
                }
                break;
#endif

#if defined(HAVE_INT64_T) &amp;&amp; SIZEOF_LONG == SIZEOF_INT64_T &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT64_T:
                while (len-- &gt; 0) {
                    union {
                        int64_t i;
                        char a[sizeof(int64_t)];
                    } v;

                    from = NEXTFROM;
                    v.i = num2i32(from); /* can return 64bit value if SIZEOF_LONG == SIZEOF_INT64_T */
                    if (bigendian_p != BIGENDIAN_P()) v.i = swap64(v.i);
                    rb_str_buf_cat(res, v.a, sizeof(int64_t));
                }
                break;
#endif

              default:
                if (integer_size &gt; MAX_INTEGER_PACK_SIZE)
                    rb_bug(&quot;unexpected intger size for pack: %d&quot;, integer_size);
                while (len-- &gt; 0) {
                    union {
                        unsigned long i[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG-1)/SIZEOF_LONG];
                        char a[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG-1)/SIZEOF_LONG*SIZEOF_LONG];
                    } v;
                    int num_longs = (integer_size+SIZEOF_LONG-1)/SIZEOF_LONG;
                    int i;

                    from = NEXTFROM;
                    rb_big_pack(from, v.i, num_longs);
                    if (bigendian_p) {
                        for (i = 0; i &lt; num_longs/2; i++) {
                            unsigned long t = v.i[i];
                            v.i[i] = v.i[num_longs-1-i];
                            v.i[num_longs-1-i] = t;
                        }
                    }
                    if (bigendian_p != BIGENDIAN_P()) {
                        for (i = 0; i &lt; num_longs; i++)
                            v.i[i] = swapl(v.i[i]);
                    }
                    rb_str_buf_cat(res,
                                   bigendian_p ?
                                     v.a + sizeof(long)*num_longs - integer_size :
                                     v.a,
                                   integer_size);
                }
                break;
            }
            break;

          case 'f':            /* single precision float in native format */
          case 'F':            /* ditto */
            while (len-- &gt; 0) {
                float f;

                from = NEXTFROM;
                f = (float)RFLOAT_VALUE(rb_to_float(from));
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'e':            /* single precision float in VAX byte-order */
            while (len-- &gt; 0) {
                float f;
                FLOAT_CONVWITH(ftmp);

                from = NEXTFROM;
                f = (float)RFLOAT_VALUE(rb_to_float(from));
                f = HTOVF(f,ftmp);
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'E':            /* double precision float in VAX byte-order */
            while (len-- &gt; 0) {
                double d;
                DOUBLE_CONVWITH(dtmp);

                from = NEXTFROM;
                d = RFLOAT_VALUE(rb_to_float(from));
                d = HTOVD(d,dtmp);
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'd':            /* double precision float in native format */
          case 'D':            /* ditto */
            while (len-- &gt; 0) {
                double d;

                from = NEXTFROM;
                d = RFLOAT_VALUE(rb_to_float(from));
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'g':            /* single precision float in network byte-order */
            while (len-- &gt; 0) {
                float f;
                FLOAT_CONVWITH(ftmp);

                from = NEXTFROM;
                f = (float)RFLOAT_VALUE(rb_to_float(from));
                f = HTONF(f,ftmp);
                rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
            }
            break;

          case 'G':            /* double precision float in network byte-order */
            while (len-- &gt; 0) {
                double d;
                DOUBLE_CONVWITH(dtmp);

                from = NEXTFROM;
                d = RFLOAT_VALUE(rb_to_float(from));
                d = HTOND(d,dtmp);
                rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
            }
            break;

          case 'x':            /* null byte */
          grow:
            while (len &gt;= 10) {
                rb_str_buf_cat(res, nul10, 10);
                len -= 10;
            }
            rb_str_buf_cat(res, nul10, len);
            break;

          case 'X':            /* back up byte */
          shrink:
            plen = RSTRING_LEN(res);
            if (plen &lt; len)
                rb_raise(rb_eArgError, &quot;X outside of string&quot;);
            rb_str_set_len(res, plen - len);
            break;

          case '@':            /* null fill to absolute position */
            len -= RSTRING_LEN(res);
            if (len &gt; 0) goto grow;
            len = -len;
            if (len &gt; 0) goto shrink;
            break;

          case '%':
            rb_raise(rb_eArgError, &quot;%% is not supported&quot;);
            break;

          case 'U':            /* Unicode character */
            while (len-- &gt; 0) {
                SIGNED_VALUE l;
                char buf[8];
                int le;

                from = NEXTFROM;
                from = rb_to_int(from);
                l = NUM2LONG(from);
                if (l &lt; 0) {
                    rb_raise(rb_eRangeError, &quot;pack(U): value out of range&quot;);
                }
                le = rb_uv_to_utf8(buf, l);
                rb_str_buf_cat(res, (char*)buf, le);
            }
            break;

          case 'u':            /* uuencoded string */
          case 'm':            /* base64 encoded string */
            from = NEXTFROM;
            StringValue(from);
            ptr = RSTRING_PTR(from);
            plen = RSTRING_LEN(from);

            if (len == 0 &amp;&amp; type == 'm') {
                encodes(res, ptr, plen, type, 0);
                ptr += plen;
                break;
            }
            if (len &lt;= 2)
                len = 45;
            else
                len = len / 3 * 3;
            while (plen &gt; 0) {
                long todo;

                if (plen &gt; len)
                    todo = len;
                else
                    todo = plen;
                encodes(res, ptr, todo, type, 1);
                plen -= todo;
                ptr += todo;
            }
            break;

          case 'M':            /* quoted-printable encoded string */
            from = rb_obj_as_string(NEXTFROM);
            if (len &lt;= 1)
                len = 72;
            qpencode(res, from, len);
            break;

          case 'P':            /* pointer to packed byte string */
            from = THISFROM;
            if (!NIL_P(from)) {
                StringValue(from);
                if (RSTRING_LEN(from) &lt; len) {
                    rb_raise(rb_eArgError, &quot;too short buffer for P(%ld for %ld)&quot;,
                             RSTRING_LEN(from), len);
                }
            }
            len = 1;
            /* FALL THROUGH */
          case 'p':            /* pointer to string */
            while (len-- &gt; 0) {
                char *t;
                from = NEXTFROM;
                if (NIL_P(from)) {
                    t = 0;
                }
                else {
                    t = StringValuePtr(from);
                }
                if (!associates) {
                    associates = rb_ary_new();
                }
                rb_ary_push(associates, from);
                rb_obj_taint(from);
                rb_str_buf_cat(res, (char*)&amp;t, sizeof(char*));
            }
            break;

          case 'w':            /* BER compressed integer  */
            while (len-- &gt; 0) {
                unsigned long ul;
                VALUE buf = rb_str_new(0, 0);
                char c, *bufs, *bufe;

                from = NEXTFROM;
                if (TYPE(from) == T_BIGNUM) {
                    VALUE big128 = rb_uint2big(128);
                    while (TYPE(from) == T_BIGNUM) {
                        from = rb_big_divmod(from, big128);
                        c = NUM2INT(RARRAY_PTR(from)[1]) | 0x80; /* mod */
                        rb_str_buf_cat(buf, &amp;c, sizeof(char));
                        from = RARRAY_PTR(from)[0]; /* div */
                    }
                }

                {
                    long l = NUM2LONG(from);
                    if (l &lt; 0) {
                        rb_raise(rb_eArgError, &quot;can't compress negative numbers&quot;);
                    }
                    ul = l;
                }

                while (ul) {
                    c = (char)(ul &amp; 0x7f) | 0x80;
                    rb_str_buf_cat(buf, &amp;c, sizeof(char));
                    ul &gt;&gt;=  7;
                }

                if (RSTRING_LEN(buf)) {
                    bufs = RSTRING_PTR(buf);
                    bufe = bufs + RSTRING_LEN(buf) - 1;
                    *bufs &amp;= 0x7f; /* clear continue bit */
                    while (bufs &lt; bufe) { /* reverse */
                        c = *bufs;
                        *bufs++ = *bufe;
                        *bufe-- = c;
                    }
                    rb_str_buf_cat(res, RSTRING_PTR(buf), RSTRING_LEN(buf));
                }
                else {
                    c = 0;
                    rb_str_buf_cat(res, &amp;c, sizeof(char));
                }
            }
            break;

          default:
            break;
        }
    }

    if (associates) {
        rb_str_associate(res, associates);
    }
    OBJ_INFECT(res, fmt);
    switch (enc_info) {
      case 1:
        ENCODING_CODERANGE_SET(res, rb_usascii_encindex(), ENC_CODERANGE_7BIT);
        break;
      case 2:
        rb_enc_set_index(res, rb_utf8_encindex());
        break;
      default:
        /* do nothing, keep ASCII-8BIT */
        break;
    }
    return res;
}</code>
</pre> 
            </div><!-- pack-source -->
            
          </div>

          

          
        </div><!-- pack-method -->

      
        <div id="permutation-method" class="method-detail ">
          <a name="method-i-permutation"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">permutation { |p| block }          &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation                        &rarr; an_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation(n) { |p| block }       &rarr; ary</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">permutation(n)                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>When invoked with a block, yield all permutations of length <em>n</em> of
the elements of <em>ary</em>, then return the array itself. If <em>n</em>
is not specified, yield all permutations of all elements. The
implementation makes no guarantees about the order in which the
permutations are yielded.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<p>Examples:</p>

<pre>a = [1, 2, 3]
a.permutation.to_a     #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
a.permutation(1).to_a  #=&gt; [[1],[2],[3]]
a.permutation(2).to_a  #=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
a.permutation(3).to_a  #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
a.permutation(0).to_a  #=&gt; [[]] # one permutation of length 0
a.permutation(4).to_a  #=&gt; []   # no permutations of length 4</pre>
            

            
            <div class="method-source-code" id="permutation-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    VALUE num;
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_ENUMERATOR(ary, argc, argv);   /* Return enumerator if no block */
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);
    r = NIL_P(num) ? n : NUM2LONG(num);   /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0 = tmpbuf(n,sizeof(long));
        long *p = (long*)RSTRING_PTR(t0);
        volatile VALUE t1 = tmpbuf(n,sizeof(char));
        char *used = (char*)RSTRING_PTR(t1);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC(ary0)-&gt;klass = 0;

        MEMZERO(used, char, n); /* initialize array */

        permute0(n, r, p, 0, used, ary0); /* compute and yield permutations */
        tmpbuf_discard(t0);
        tmpbuf_discard(t1);
        RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</code>
</pre> 
            </div><!-- permutation-source -->
            
          </div>

          

          
        </div><!-- permutation-method -->

      
        <div id="pop-method" class="method-detail ">
          <a name="method-i-pop"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pop    &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">pop(n) &rarr; new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Removes the last element from <tt>self</tt> and returns it, or <tt>nil</tt>
if the array is empty.</p>

<p>If a number <em>n</em> is given, returns an array of the last n elements
(or less) just like <tt>array.slice!(-n, n)</tt> does.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.pop     #=&gt; &quot;d&quot;
a.pop(2)  #=&gt; [&quot;b&quot;, &quot;c&quot;]
a         #=&gt; [&quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="pop-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    return result;
}</code>
</pre> 
            </div><!-- pop-source -->
            
          </div>

          

          
        </div><!-- pop-method -->

      
        <div id="product-method" class="method-detail ">
          <a name="method-i-product"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">product(other_ary, ...)                &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">product(other_ary, ...) { |p| block }  &rarr; ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array of all combinations of elements from all arrays, The
length of the returned array is the product of the length of <tt>self</tt>
and the argument arrays. If given a block, <em>product</em> will yield all
combinations and return <tt>self</tt> instead.</p>

<pre>[1,2,3].product([4,5])     #=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
[1,2].product([1,2])       #=&gt; [[1,1],[1,2],[2,1],[2,2]]
[1,2].product([3,4],[5,6]) #=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
                           #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
[1,2].product()            #=&gt; [[1],[2]]
[1,2].product([])          #=&gt; []</pre>
            

            
            <div class="method-source-code" id="product-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = tmpary(n);
    volatile VALUE t1 = tmpbuf(n, sizeof(int));
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we're computing the product of */
    int *counters = (int*)RSTRING_PTR(t1); /* The current position in each one */
    VALUE result = Qnil;      /* The array we'll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC(t0)-&gt;klass = 0;
    RBASIC(t1)-&gt;klass = 0;

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
        /* Make defensive copies of arrays; exit if any is empty */
        for (i = 0; i &lt; n; i++) {
            if (RARRAY_LEN(arrays[i]) == 0) goto done;
            arrays[i] = ary_make_shared_copy(arrays[i]);
        }
    }
    else {
        /* Compute the length of the result array; return [] if any is empty */
        for (i = 0; i &lt; n; i++) {
            long k = RARRAY_LEN(arrays[i]), l = resultlen;
            if (k == 0) {
                result = rb_ary_new2(0);
                goto done;
            }
            resultlen *= k;
            if (resultlen &lt; k || resultlen &lt; l || resultlen / k != l) {
                rb_raise(rb_eRangeError, &quot;too big to product&quot;);
            }
        }
        result = rb_ary_new2(resultlen);
    }
    for (;;) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        if(NIL_P(result)) {
            FL_SET(t0, FL_USER5);
            rb_yield(subarray);
            if (! FL_TEST(t0, FL_USER5)) {
                rb_raise(rb_eRuntimeError, &quot;product reentered&quot;);
            }
            else {
                FL_UNSET(t0, FL_USER5);
            }
        }
        else {
            rb_ary_push(result, subarray);
        }

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (counters[m] == RARRAY_LEN(arrays[m])) {
            counters[m] = 0;
            /* If the first counter overlows, we are done */
            if (--m &lt; 0) goto done;
            counters[m]++;
        }
    }
done:
    tmpary_discard(t0);
    tmpbuf_discard(t1);

    return NIL_P(result) ? ary : result;
}</code>
</pre> 
            </div><!-- product-source -->
            
          </div>

          

          
        </div><!-- product-method -->

      
        <div id="push-method" class="method-detail ">
          <a name="method-i-push"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">push(obj, ... )   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Append—Pushes the given object(s) on to the end of this array. This
expression returns the array itself, so several appends may be chained
together.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)
        #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</pre>
            

            
            <div class="method-source-code" id="push-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    rb_ary_modify(ary);
    while (argc--) {
        rb_ary_push_1(ary, *argv++);
    }
    return ary;
}</code>
</pre> 
            </div><!-- push-source -->
            
          </div>

          

          
        </div><!-- push-method -->

      
        <div id="rassoc-method" class="method-detail ">
          <a name="method-i-rassoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rassoc(obj) &rarr; new_ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Searches through the array whose elements are also arrays. Compares
<em>obj</em> with the second element of each contained array using
<tt>==</tt>. Returns the first contained array that matches. See also
<tt><a href="Array.html#method-i-assoc">Array#assoc</a></tt>.</p>

<pre>a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]
a.rassoc(&quot;two&quot;)    #=&gt; [2, &quot;two&quot;]
a.rassoc(&quot;four&quot;)   #=&gt; nil</pre>
            

            
            <div class="method-source-code" id="rassoc-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = RARRAY_PTR(ary)[i];
        if (TYPE(v) == T_ARRAY &amp;&amp;
            RARRAY_LEN(v) &gt; 1 &amp;&amp;
            rb_equal(RARRAY_PTR(v)[1], value))
            return v;
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- rassoc-source -->
            
          </div>

          

          
        </div><!-- rassoc-method -->

      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject {|item| block }  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array containing the items in <tt>self</tt> for which the
block is not true. See also <tt><a
href="Array.html#method-i-delete_if">Array#delete_if</a></tt></p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="reject-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_reject(VALUE ary)
{
    RETURN_ENUMERATOR(ary, 0, 0);
    ary = rb_ary_dup(ary);
    rb_ary_reject_bang(ary);
    return ary;
}</code>
</pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->

      
        <div id="reject-21-method" class="method-detail ">
          <a name="method-i-reject-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject! {|item| block }  &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject!                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Equivalent to <tt><a
href="Array.html#method-i-delete_if">Array#delete_if</a></tt>, deleting
elements from <tt>self</tt> for which the block evaluates to true, but
returns <tt>nil</tt> if no changes were made. See also <tt><a
href="Enumerable.html#method-i-reject">Enumerable#reject</a></tt> and
<tt><a href="Array.html#method-i-delete_if">Array#delete_if</a></tt>.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="reject-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_reject_bang(VALUE ary)
{
    long i1, i2;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE v = RARRAY_PTR(ary)[i1];
        if (RTEST(rb_yield(v))) continue;
        if (i1 != i2) {
            rb_ary_store(ary, i2, v);
        }
        i2++;
    }

    if (RARRAY_LEN(ary) == i2) return Qnil;
    if (i2 &lt; RARRAY_LEN(ary))
        ARY_SET_LEN(ary, i2);
    return ary;
}</code>
</pre> 
            </div><!-- reject-21-source -->
            
          </div>

          

          
        </div><!-- reject-21-method -->

      
        <div id="repeated_combination-method" class="method-detail ">
          <a name="method-i-repeated_combination"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">repeated_combination(n) { |c| block } &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">repeated_combination(n)               &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>When invoked with a block, yields all repeated combinations of length
<em>n</em> of elements from <em>ary</em> and then returns <em>ary</em>
itself. The implementation makes no guarantees about the order in which the
repeated combinations are yielded.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<p>Examples:</p>

<pre>a = [1, 2, 3]
a.repeated_combination(1).to_a  #=&gt; [[1], [2], [3]]
a.repeated_combination(2).to_a  #=&gt; [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
a.repeated_combination(3).to_a  #=&gt; [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],
                                #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
a.repeated_combination(4).to_a  #=&gt; [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],
                                #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],
                                #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]
a.repeated_combination(0).to_a  #=&gt; [[]] # one combination of length 0</pre>
            

            
            <div class="method-source-code" id="repeated_combination-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_ENUMERATOR(ary, 1, &amp;num);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; len; i++) {
            rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
        }
    }
    else if (len == 0) {
        /* yield nothing */
    }
    else {
        volatile VALUE t0 = tmpbuf(n, sizeof(long));
        long *p = (long*)RSTRING_PTR(t0);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC(ary0)-&gt;klass = 0;

        rcombinate0(len, n, p, 0, n, ary0); /* compute and yield repeated combinations */
        tmpbuf_discard(t0);
        RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</code>
</pre> 
            </div><!-- repeated_combination-source -->
            
          </div>

          

          
        </div><!-- repeated_combination-method -->

      
        <div id="repeated_permutation-method" class="method-detail ">
          <a name="method-i-repeated_permutation"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">repeated_permutation(n) { |p| block } &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">repeated_permutation(n)               &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>When invoked with a block, yield all repeated permutations of length
<em>n</em> of the elements of <em>ary</em>, then return the array itself.
The implementation makes no guarantees about the order in which the
repeated permutations are yielded.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<p>Examples:</p>

<pre>a = [1, 2]
a.repeated_permutation(1).to_a  #=&gt; [[1], [2]]
a.repeated_permutation(2).to_a  #=&gt; [[1,1],[1,2],[2,1],[2,2]]
a.repeated_permutation(3).to_a  #=&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],
                                #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]
a.repeated_permutation(0).to_a  #=&gt; [[]] # one permutation of length 0</pre>
            

            
            <div class="method-source-code" id="repeated_permutation-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_ENUMERATOR(ary, 1, &amp;num);      /* Return enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0 = tmpbuf(r, sizeof(long));
        long *p = (long*)RSTRING_PTR(t0);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC(ary0)-&gt;klass = 0;

        rpermute0(n, r, p, 0, ary0); /* compute and yield repeated permutations */
        tmpbuf_discard(t0);
        RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</code>
</pre> 
            </div><!-- repeated_permutation-source -->
            
          </div>

          

          
        </div><!-- repeated_permutation-method -->

      
        <div id="replace-method" class="method-detail ">
          <a name="method-i-replace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_ary)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Replaces the contents of <tt>self</tt> with the contents of
<em>other_ary</em>, truncating or expanding if necessary.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</pre>
            

            
            <div class="method-source-code" id="replace-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE *ptr;
        VALUE shared = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else if (ARY_SHARED_P(copy)) {
            shared = ARY_SHARED(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ptr = RARRAY_PTR(orig);
        MEMCPY(RARRAY_PTR(copy), ptr, VALUE, RARRAY_LEN(orig));
        if (shared) {
            rb_ary_decrement_share(shared);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, RARRAY_PTR(orig));
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
        rb_ary_set_shared(copy, shared);
    }
    return copy;
}</code>
</pre> 
            </div><!-- replace-source -->
            
          </div>

          

          
        </div><!-- replace-method -->

      
        <div id="reverse-method" class="method-detail ">
          <a name="method-i-reverse"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array containing <tt>self</tt>‘s elements in reverse order.</p>

<pre>[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
[ 1 ].reverse               #=&gt; [1]</pre>
            

            
            <div class="method-source-code" id="reverse-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_reverse_m(VALUE ary)
{
    VALUE dup = rb_ary_dup_setup(ary);
    long len = RARRAY_LEN(ary);

    if (len &gt; 0) {
        VALUE *p1 = RARRAY_PTR(ary);
        VALUE *p2 = RARRAY_PTR(dup) + len - 1;
        do *p2-- = *p1++; while (--len &gt; 0);
    }
    return dup;
}</code>
</pre> 
            </div><!-- reverse-source -->
            
          </div>

          

          
        </div><!-- reverse-method -->

      
        <div id="reverse-21-method" class="method-detail ">
          <a name="method-i-reverse-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse!   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Reverses <tt>self</tt> in place.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.reverse!       #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
a                #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="reverse-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}</code>
</pre> 
            </div><!-- reverse-21-source -->
            
          </div>

          

          
        </div><!-- reverse-21-method -->

      
        <div id="reverse_each-method" class="method-detail ">
          <a name="method-i-reverse_each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each {|item| block }   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reverse_each                   &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Same as <tt><a href="Array.html#method-i-each">Array#each</a></tt>, but
traverses <tt>self</tt> in reverse order.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.reverse_each {|x| print x, &quot; &quot; }</pre>

<p>produces:</p>

<pre>c b a</pre>
            

            
            <div class="method-source-code" id="reverse_each-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_ENUMERATOR(ary, 0, 0);
    len = RARRAY_LEN(ary);
    while (len--) {
        rb_yield(RARRAY_PTR(ary)[len]);
        if (RARRAY_LEN(ary) &lt; len) {
            len = RARRAY_LEN(ary);
        }
    }
    return ary;
}</code>
</pre> 
            </div><!-- reverse_each-source -->
            
          </div>

          

          
        </div><!-- reverse_each-method -->

      
        <div id="rindex-method" class="method-detail ">
          <a name="method-i-rindex"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rindex(obj)           &rarr;  int or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">rindex {|item| block} &rarr;  int or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">rindex                &rarr;  an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the index of the last object in <tt>self</tt> <tt>==</tt> to
<em>obj</em>. If a block is given instead of an argument, returns first
object for which <em>block</em> is true, starting from the last object.
Returns <tt>nil</tt> if no match is found. See also <tt><a
href="Array.html#method-i-index">Array#index</a></tt>.</p>

<p>If neither block nor argument is given, an enumerator is returned instead.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
a.rindex(&quot;b&quot;)        #=&gt; 3
a.rindex(&quot;z&quot;)        #=&gt; nil
a.rindex{|x|x==&quot;b&quot;}  #=&gt; 3</pre>
            

            
            <div class="method-source-code" id="rindex-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i = RARRAY_LEN(ary);

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY_PTR(ary)[i])))
                return LONG2NUM(i);
            if (i &gt; RARRAY_LEN(ary)) {
                i = RARRAY_LEN(ary);
            }
        }
        return Qnil;
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;val);
    if (rb_block_given_p())
        rb_warn(&quot;given block not used&quot;);
    while (i--) {
        if (rb_equal(RARRAY_PTR(ary)[i], val))
            return LONG2NUM(i);
        if (i &gt; RARRAY_LEN(ary)) {
            i = RARRAY_LEN(ary);
        }
    }
    return Qnil;
}</code>
</pre> 
            </div><!-- rindex-source -->
            
          </div>

          

          
        </div><!-- rindex-method -->

      
        <div id="rotate-method" class="method-detail ">
          <a name="method-i-rotate"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rotate([n = 1]) &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns new array by rotating <tt>self</tt>, whose first element is the
element at <tt>cnt</tt> in <tt>self</tt>.  If <tt>cnt</tt> is negative then
it rotates in counter direction.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.rotate         #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
a                #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
a.rotate(2)      #=&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]
a.rotate(-3)     #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="rotate-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated, *ptr, *ptr2;
    long len, cnt = 1;

    switch (argc) {
      case 1: cnt = NUM2LONG(argv[0]);
      case 0: break;
      default: rb_scan_args(argc, argv, &quot;01&quot;, NULL);
    }

    len = RARRAY_LEN(ary);
    rotated = rb_ary_dup_setup(ary);
    if (len &gt; 0) {
        cnt = rotate_count(cnt, len);
        ptr = RARRAY_PTR(ary);
        ptr2 = RARRAY_PTR(rotated);
        len -= cnt;
        MEMCPY(ptr2, ptr + cnt, VALUE, len);
        MEMCPY(ptr2 + len, ptr, VALUE, cnt);
    }
    return rotated;
}</code>
</pre> 
            </div><!-- rotate-source -->
            
          </div>

          

          
        </div><!-- rotate-method -->

      
        <div id="rotate-21-method" class="method-detail ">
          <a name="method-i-rotate-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rotate!(cnt=1) &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Rotates <tt>self</tt> in place so that the element at <tt>cnt</tt> comes
first, and returns <tt>self</tt>.  If <tt>cnt</tt> is negative then it
rotates in counter direction.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.rotate!        #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
a                #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
a.rotate!(2)     #=&gt; [&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
a.rotate!(-3)    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>
            

            
            <div class="method-source-code" id="rotate-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = 1;

    switch (argc) {
      case 1: n = NUM2LONG(argv[0]);
      case 0: break;
      default: rb_scan_args(argc, argv, &quot;01&quot;, NULL);
    }
    rb_ary_rotate(ary, n);
    return ary;
}</code>
</pre> 
            </div><!-- rotate-21-source -->
            
          </div>

          

          
        </div><!-- rotate-21-method -->

      
        <div id="sample-method" class="method-detail ">
          <a name="method-i-sample"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sample        &rarr; obj</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sample(n)     &rarr; new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Choose a random element or <tt>n</tt> random elements from the array. The
elements are chosen by using random and unique indices into the array in
order to ensure that an element doesn’t repeat itself unless the array
already contained duplicate elements. If the array is empty the first form
returns <tt>nil</tt> and the second form returns an empty array.</p>
            

            
            <div class="method-source-code" id="sample-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_sample(int argc, VALUE *argv, VALUE ary)
{
    VALUE nv, result, *ptr;
    long n, len, i, j, k, idx[10];

    len = RARRAY_LEN(ary);
    if (argc == 0) {
        if (len == 0) return Qnil;
        i = len == 1 ? 0 : (long)(rb_genrand_real()*len);
        return RARRAY_PTR(ary)[i];
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;nv);
    n = NUM2LONG(nv);
    if (n &lt; 0) rb_raise(rb_eArgError, &quot;negative sample number&quot;);
    ptr = RARRAY_PTR(ary);
    len = RARRAY_LEN(ary);
    if (n &gt; len) n = len;
    switch (n) {
      case 0: return rb_ary_new2(0);
      case 1:
        return rb_ary_new4(1, &amp;ptr[(long)(rb_genrand_real()*len)]);
      case 2:
        i = (long)(rb_genrand_real()*len);
        j = (long)(rb_genrand_real()*(len-1));
        if (j &gt;= i) j++;
        return rb_ary_new3(2, ptr[i], ptr[j]);
      case 3:
        i = (long)(rb_genrand_real()*len);
        j = (long)(rb_genrand_real()*(len-1));
        k = (long)(rb_genrand_real()*(len-2));
        {
            long l = j, g = i;
            if (j &gt;= i) l = i, g = ++j;
            if (k &gt;= l &amp;&amp; (++k &gt;= g)) ++k;
        }
        return rb_ary_new3(3, ptr[i], ptr[j], ptr[k]);
    }
    if ((size_t)n &lt; sizeof(idx)/sizeof(idx[0])) {
        VALUE *ptr_result;
        long sorted[sizeof(idx)/sizeof(idx[0])];
        sorted[0] = idx[0] = (long)(rb_genrand_real()*len);
        for (i=1; i&lt;n; i++) {
            k = (long)(rb_genrand_real()*--len);
            for (j = 0; j &lt; i; ++j) {
                if (k &lt; sorted[j]) break;
                ++k;
            }
            memmove(&amp;sorted[j+1], &amp;sorted[j], sizeof(sorted[0])*(i-j));
            sorted[j] = idx[i] = k;
        }
        result = rb_ary_new2(n);
        ptr_result = RARRAY_PTR(result);
        for (i=0; i&lt;n; i++) {
            ptr_result[i] = ptr[idx[i]];
        }
    }
    else {
        VALUE *ptr_result;
        result = rb_ary_new4(len, ptr);
        ptr_result = RARRAY_PTR(result);
        RB_GC_GUARD(ary);
        for (i=0; i&lt;n; i++) {
            j = (long)(rb_genrand_real()*(len-i)) + i;
            nv = ptr_result[j];
            ptr_result[j] = ptr_result[i];
            ptr_result[i] = nv;
        }
    }
    ARY_SET_LEN(result, n);

    return result;
}</code>
</pre> 
            </div><!-- sample-source -->
            
          </div>

          

          
        </div><!-- sample-method -->

      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select {|item| block } &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select                 &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes the block passing in successive elements from <tt>self</tt>,
returning an array containing those elements for which the block returns a
true value (equivalent to <tt><a
href="Enumerable.html#method-i-select">Enumerable#select</a></tt>).</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = %w{ a b c d e f }
a.select {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]</pre>
            

            
            <div class="method-source-code" id="select-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}</code>
</pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->

      
        <div id="select-21-method" class="method-detail ">
          <a name="method-i-select-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select! {|item| block } &rarr; new_ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select!                 &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Invokes the block passing in successive elements from <tt>self</tt>,
deleting elements for which the block returns a false value. It returns
<tt>self</tt> if changes were made, otherwise it returns <tt>nil</tt>. See
also <tt><a href="Array.html#method-i-keep_if">Array#keep_if</a></tt></p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="select-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_select_bang(VALUE ary)
{
    long i1, i2;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE v = RARRAY_PTR(ary)[i1];
        if (!RTEST(rb_yield(v))) continue;
        if (i1 != i2) {
            rb_ary_store(ary, i2, v);
        }
        i2++;
    }

    if (RARRAY_LEN(ary) == i2) return Qnil;
    if (i2 &lt; RARRAY_LEN(ary))
        ARY_SET_LEN(ary, i2);
    return ary;
}</code>
</pre> 
            </div><!-- select-21-source -->
            
          </div>

          

          
        </div><!-- select-21-method -->

      
        <div id="shift-method" class="method-detail ">
          <a name="method-i-shift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shift    &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">shift(n) &rarr; new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns the first element of <tt>self</tt> and removes it (shifting all
other elements down by one). Returns <tt>nil</tt> if the array is empty.</p>

<p>If a number <em>n</em> is given, returns an array of the first n elements
(or less) just like <tt>array.slice!(0, n)</tt> does.</p>

<pre>args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
args.shift     #=&gt; &quot;-m&quot;
args           #=&gt; [&quot;-q&quot;, &quot;filename&quot;]

args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
args.shift(2)  #=&gt; [&quot;-m&quot;, &quot;-q&quot;]
args           #=&gt; [&quot;filename&quot;]</pre>
            

            
            <div class="method-source-code" id="shift-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    if (ARY_SHARED_P(ary)) {
        if (ARY_SHARED_NUM(ARY_SHARED(ary)) == 1) {
            rb_mem_clear(RARRAY_PTR(ary), n);
        }
        ARY_INCREASE_PTR(ary, n);
    }
    else {
        MEMMOVE(RARRAY_PTR(ary), RARRAY_PTR(ary)+n, VALUE, RARRAY_LEN(ary)-n);
    }
    ARY_INCREASE_LEN(ary, -n);

    return result;
}</code>
</pre> 
            </div><!-- shift-source -->
            
          </div>

          

          
        </div><!-- shift-method -->

      
        <div id="shuffle-method" class="method-detail ">
          <a name="method-i-shuffle"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shuffle &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array with elements of this array shuffled.</p>

<pre>a = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
a.shuffle                 #=&gt; [2, 3, 1]</pre>
            

            
            <div class="method-source-code" id="shuffle-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_shuffle(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_shuffle_bang(ary);
    return ary;
}</code>
</pre> 
            </div><!-- shuffle-source -->
            
          </div>

          

          
        </div><!-- shuffle-method -->

      
        <div id="shuffle-21-method" class="method-detail ">
          <a name="method-i-shuffle-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shuffle!        &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Shuffles elements in <tt>self</tt> in place.</p>
            

            
            <div class="method-source-code" id="shuffle-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_shuffle_bang(VALUE ary)
{
    VALUE *ptr;
    long i = RARRAY_LEN(ary);

    rb_ary_modify(ary);
    ptr = RARRAY_PTR(ary);
    while (i) {
        long j = (long)(rb_genrand_real()*i);
        VALUE tmp = ptr[--i];
        ptr[i] = ptr[j];
        ptr[j] = tmp;
    }
    return ary;
}</code>
</pre> 
            </div><!-- shuffle-21-source -->
            
          </div>

          

          
        </div><!-- shuffle-21-method -->

      
        <div id="size-method" class="method-detail method-alias">
          <a name="method-i-size"></a>

          
          <div class="method-heading">
            <span class="method-name">size</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Array.html#method-i-length">length</a>
          </div>
          
        </div><!-- size-method -->

      
        <div id="slice-method" class="method-detail ">
          <a name="method-i-slice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary[index]                &rarr; obj     or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[start, length]        &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">ary[range]                &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(index)          &rarr; obj     or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(start, length)  &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice(range)          &rarr; new_ary or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Element Reference—Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>. Negative
indices count backward from the end of the array (-1 is the last element).
Returns <tt>nil</tt> if the index (or starting index) are out of range.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
a[6]                   #=&gt; nil
a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a[4..7]                #=&gt; [ &quot;e&quot; ]
a[6..10]               #=&gt; nil
a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
# special cases
a[5]                   #=&gt; nil
a[5, 1]                #=&gt; []
a[5..10]               #=&gt; []</pre>
            

            
            <div class="method-source-code" id="slice-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_aref(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg &lt; 0) {
            beg += RARRAY_LEN(ary);
        }
        return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
        rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
        return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qfalse:
        break;
      case Qnil:
        return Qnil;
      default:
        return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}</code>
</pre> 
            </div><!-- slice-source -->
            
          </div>

          

          
        </div><!-- slice-method -->

      
        <div id="slice-21-method" class="method-detail ">
          <a name="method-i-slice-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice!(index)         &rarr; obj or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice!(start, length) &rarr; new_ary or nil</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">slice!(range)         &rarr; new_ary or nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Deletes the element(s) given by an index (optionally with a length) or by a
range. Returns the deleted object (or objects), or <tt>nil</tt> if the
index is out of range.</p>

<pre>a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
a.slice!(1)     #=&gt; &quot;b&quot;
a               #=&gt; [&quot;a&quot;, &quot;c&quot;]
a.slice!(-1)    #=&gt; &quot;c&quot;
a               #=&gt; [&quot;a&quot;]
a.slice!(100)   #=&gt; nil
a               #=&gt; [&quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="slice-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1, arg2;
    long pos, len, orig_len;

    rb_ary_modify_check(ary);
    if (argc == 2) {
        pos = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
      delete_pos_len:
        if (len &lt; 0) return Qnil;
        orig_len = RARRAY_LEN(ary);
        if (pos &lt; 0) {
            pos += orig_len;
            if (pos &lt; 0) return Qnil;
        }
        else if (orig_len &lt; pos) return Qnil;
        if (orig_len &lt; pos + len) {
            len = orig_len - pos;
        }
        if (len == 0) return rb_ary_new2(0);
        arg2 = rb_ary_new4(len, RARRAY_PTR(ary)+pos);
        RBASIC(arg2)-&gt;klass = rb_obj_class(ary);
        rb_ary_splice(ary, pos, len, Qundef);
        return arg2;
    }

    if (argc != 1) {
        /* error report */
        rb_scan_args(argc, argv, &quot;11&quot;, NULL, NULL);
    }
    arg1 = argv[0];

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            goto delete_pos_len;
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}</code>
</pre> 
            </div><!-- slice-21-source -->
            
          </div>

          

          
        </div><!-- slice-21-method -->

      
        <div id="sort-method" class="method-detail ">
          <a name="method-i-sort"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort                   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort {| a,b | block }  &rarr; new_ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array created by sorting <tt>self</tt>. Comparisons for the
sort will be done using the <tt>&lt;=&gt;</tt> operator or using an
optional code block. The block implements a comparison between <em>a</em>
and <em>b</em>, returning -1, 0, or +1. See also <tt><a
href="Enumerable.html#method-i-sort_by">Enumerable#sort_by</a></tt>.</p>

<pre>a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="sort-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}</code>
</pre> 
            </div><!-- sort-source -->
            
          </div>

          

          
        </div><!-- sort-method -->

      
        <div id="sort-21-method" class="method-detail ">
          <a name="method-i-sort-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort!                   &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort! {| a,b | block }  &rarr; ary</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Sorts <tt>self</tt>. Comparisons for the sort will be done using the
<tt>&lt;=&gt;</tt> operator or using an optional code block. The block
implements a comparison between <em>a</em> and <em>b</em>, returning -1, 0,
or +1. See also <tt><a
href="Enumerable.html#method-i-sort_by">Enumerable#sort_by</a></tt>.</p>

<pre>a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</pre>
            

            
            <div class="method-source-code" id="sort-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    assert(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
        VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
        struct ary_sort_data data;

        RBASIC(tmp)-&gt;klass = 0;
        data.ary = tmp;
        data.opt_methods = 0;
        data.opt_inited = 0;
        ruby_qsort(RARRAY_PTR(tmp), RARRAY_LEN(tmp), sizeof(VALUE),
                   rb_block_given_p()?sort_1:sort_2, &amp;data);

        if (ARY_EMBED_P(tmp)) {
            assert(ARY_EMBED_P(tmp));
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
            }
            FL_SET_EMBED(ary);
            MEMCPY(RARRAY_PTR(ary), ARY_EMBED_PTR(tmp), VALUE, ARY_EMBED_LEN(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            assert(!ARY_EMBED_P(tmp));
            if (ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                assert(!ARY_EMBED_P(ary));
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, ARY_CAPA(tmp));
            }
            else {
                assert(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    xfree(ARY_HEAP_PTR(ary));
                }
                ARY_SET_PTR(ary, RARRAY_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, RARRAY_LEN(tmp));
                ARY_SET_CAPA(ary, ARY_CAPA(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
        }
        /* tmp will be GC'ed. */
        RBASIC(tmp)-&gt;klass = rb_cArray;
    }
    return ary;
}</code>
</pre> 
            </div><!-- sort-21-source -->
            
          </div>

          

          
        </div><!-- sort-21-method -->

      
        <div id="sort_by-21-method" class="method-detail ">
          <a name="method-i-sort_by-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sort_by! {| obj | block }    &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">sort_by!                     &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Sorts <tt>self</tt> in place using a set of keys generated by mapping the
values in <tt>self</tt> through the given block.</p>

<p>If no block is given, an enumerator is returned instead.</p>
            

            
            <div class="method-source-code" id="sort_by-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern(&quot;sort_by&quot;), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}</code>
</pre> 
            </div><!-- sort_by-21-source -->
            
          </div>

          

          
        </div><!-- sort_by-21-method -->

      
        <div id="take-method" class="method-detail ">
          <a name="method-i-take"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take(n)               &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns first n elements from <em>ary</em>.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.take(3)             #=&gt; [1, 2, 3]</pre>
            

            
            <div class="method-source-code" id="take-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }
    return rb_ary_subseq(obj, 0, len);
}</code>
</pre> 
            </div><!-- take-source -->
            
          </div>

          

          
        </div><!-- take-method -->

      
        <div id="take_while-method" class="method-detail ">
          <a name="method-i-take_while"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">take_while {|arr| block }   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">take_while                  &rarr; an_enumerator</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Passes elements to the block until the block returns <tt>nil</tt> or
<tt>false</tt>, then stops iterating and returns an array of all prior
elements.</p>

<p>If no block is given, an enumerator is returned instead.</p>

<pre>a = [1, 2, 3, 4, 5, 0]
a.take_while {|i| i &lt; 3 }   #=&gt; [1, 2]</pre>
            

            
            <div class="method-source-code" id="take_while-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_PTR(ary)[i]))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}</code>
</pre> 
            </div><!-- take_while-source -->
            
          </div>

          

          
        </div><!-- take_while-method -->

      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a     &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>self</tt>. If called on a subclass of <a
href="Array.html">Array</a>, converts the receiver to an <a
href="Array.html">Array</a> object.</p>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}</code>
</pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->

      
        <div id="to_ary-method" class="method-detail ">
          <a name="method-i-to_ary"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_ary &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns <tt>self</tt>.</p>
            

            
            <div class="method-source-code" id="to_ary-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}</code>
</pre> 
            </div><!-- to_ary-source -->
            
          </div>

          

          
        </div><!-- to_ary-method -->

      
        <div id="to_s-method" class="method-detail method-alias">
          <a name="method-i-to_s"></a>

          
          <div class="method-heading">
            <span class="method-name">to_s</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Array.html#method-i-inspect">inspect</a>
          </div>
          
        </div><!-- to_s-method -->

      
        <div id="transpose-method" class="method-detail ">
          <a name="method-i-transpose"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transpose &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Assumes that <tt>self</tt> is an array of arrays and transposes the rows
and columns.</p>

<pre>a = [[1,2], [3,4], [5,6]]
a.transpose   #=&gt; [[1, 3, 5], [2, 4, 6]]</pre>
            

            
            <div class="method-source-code" id="transpose-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {                /* first element */
            elen = RARRAY_LEN(tmp);
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY_LEN(tmp)) {
            rb_raise(rb_eIndexError, &quot;element size differs (%ld should be %ld)&quot;,
                     RARRAY_LEN(tmp), elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}</code>
</pre> 
            </div><!-- transpose-source -->
            
          </div>

          

          
        </div><!-- transpose-method -->

      
        <div id="uniq-method" class="method-detail ">
          <a name="method-i-uniq"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">uniq   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns a new array by removing duplicate values in <tt>self</tt>.</p>

<pre>a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
a.uniq   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]
c.uniq {|s| s[/^\w+/]}  #=&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]</pre>
            

            
            <div class="method-source-code" id="uniq-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq, v;
    long i;

    if (RARRAY_LEN(ary) &lt;= 1)
        return rb_ary_dup(ary);
    if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        uniq = ary_new(rb_obj_class(ary), RHASH_SIZE(hash));
        st_foreach(RHASH_TBL(hash), push_value, uniq);
    }
    else {
        hash = ary_make_hash(ary);
        uniq = ary_new(rb_obj_class(ary), RHASH_SIZE(hash));
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            st_data_t vv = (st_data_t)(v = rb_ary_elt(ary, i));
            if (st_delete(RHASH_TBL(hash), &amp;vv, 0)) {
                rb_ary_push(uniq, v);
            }
        }
    }
    ary_recycle_hash(hash);

    return uniq;
}</code>
</pre> 
            </div><!-- uniq-source -->
            
          </div>

          

          
        </div><!-- uniq-method -->

      
        <div id="uniq-21-method" class="method-detail ">
          <a name="method-i-uniq-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">uniq! &rarr; ary or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Removes duplicate elements from <tt>self</tt>. Returns <tt>nil</tt> if no
changes are made (that is, no duplicates are found).</p>

<pre>a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
a.uniq!   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
b.uniq!   #=&gt; nil
c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]
c.uniq! {|s| s[/^\w+/]}  #=&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]</pre>
            

            
            <div class="method-source-code" id="uniq-21-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash, v;
    long i, j;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        if (RARRAY_LEN(ary) == (i = RHASH_SIZE(hash))) {
            return Qnil;
        }
        ARY_SET_LEN(ary, 0);
        if (ARY_SHARED_P(ary) &amp;&amp; !ARY_EMBED_P(ary)) {
            rb_ary_unshare(ary);
            FL_SET_EMBED(ary);
        }
        ary_resize_capa(ary, i);
        st_foreach(RHASH_TBL(hash), push_value, ary);
    }
    else {
        hash = ary_make_hash(ary);
        if (RARRAY_LEN(ary) == (long)RHASH_SIZE(hash)) {
            return Qnil;
        }
        for (i=j=0; i&lt;RARRAY_LEN(ary); i++) {
            st_data_t vv = (st_data_t)(v = rb_ary_elt(ary, i));
            if (st_delete(RHASH_TBL(hash), &amp;vv, 0)) {
                rb_ary_store(ary, j++, v);
            }
        }
        ARY_SET_LEN(ary, j);
    }
    ary_recycle_hash(hash);

    return ary;
}</code>
</pre> 
            </div><!-- uniq-21-source -->
            
          </div>

          

          
        </div><!-- uniq-21-method -->

      
        <div id="unshift-method" class="method-detail ">
          <a name="method-i-unshift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">unshift(obj, ...)  &rarr; ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Prepends objects to the front of <tt>self</tt>, moving other elements
upwards.</p>

<pre>a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
a.unshift(&quot;a&quot;)   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
a.unshift(1, 2)  #=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>
            

            
            <div class="method-source-code" id="unshift-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len;

    rb_ary_modify(ary);
    if (argc == 0) return ary;
    if (ARY_CAPA(ary) &lt;= (len = RARRAY_LEN(ary)) + argc) {
        ary_double_capa(ary, len + argc);
    }

    /* sliding items */
    MEMMOVE(RARRAY_PTR(ary) + argc, RARRAY_PTR(ary), VALUE, len);
    MEMCPY(RARRAY_PTR(ary), argv, VALUE, argc);
    ARY_INCREASE_LEN(ary, argc);

    return ary;
}</code>
</pre> 
            </div><!-- unshift-source -->
            
          </div>

          

          
        </div><!-- unshift-method -->

      
        <div id="values_at-method" class="method-detail ">
          <a name="method-i-values_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values_at(selector,... )  &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Returns an array containing the elements in <tt>self</tt> corresponding to
the given selector(s). The selectors may be either integer indices or
ranges. See also <tt><a
href="Array.html#method-i-select">Array#select</a></tt>.</p>

<pre>a = %w{ a b c d e f }
a.values_at(1, 3, 5)
a.values_at(1, 3, 5, 7)
a.values_at(-1, -3, -5, -7)
a.values_at(1..3, 2...5)</pre>
            

            
            <div class="method-source-code" id="values_at-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    return rb_get_values_at(ary, RARRAY_LEN(ary), argc, argv, rb_ary_entry);
}</code>
</pre> 
            </div><!-- values_at-source -->
            
          </div>

          

          
        </div><!-- values_at-method -->

      
        <div id="zip-method" class="method-detail ">
          <a name="method-i-zip"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...)                   &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">zip(arg, ...) {| arr | block }  &rarr; nil</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Converts any arguments to arrays, then merges elements of <tt>self</tt>
with corresponding elements from each argument. This generates a sequence
of <tt>self.size</tt> <em>n</em>-element arrays, where <em>n</em> is one
more that the count of arguments. If the size of any argument is less than
<tt>enumObj.size</tt>, <tt>nil</tt> values are supplied. If a block is
given, it is invoked for each output array, otherwise an array of arrays is
returned.</p>

<pre>a = [ 4, 5, 6 ]
b = [ 7, 8, 9 ]
[1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
[1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
a.zip([1,2],[8])       #=&gt; [[4,1,8], [5,2,nil], [6,nil,nil]]</pre>
            

            
            <div class="method-source-code" id="zip-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len;
    VALUE result = Qnil;

    len = RARRAY_LEN(ary);
    for (i=0; i&lt;argc; i++) {
        argv[i] = take_items(argv[i], len);
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new2(len);
    }

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        VALUE tmp = rb_ary_new2(argc+1);

        rb_ary_push(tmp, rb_ary_elt(ary, i));
        for (j=0; j&lt;argc; j++) {
            rb_ary_push(tmp, rb_ary_elt(argv[j], i));
        }
        if (NIL_P(result)) {
            rb_yield(tmp);
        }
        else {
            rb_ary_push(result, tmp);
        }
    }
    return result;
}</code>
</pre> 
            </div><!-- zip-source -->
            
          </div>

          

          
        </div><!-- zip-method -->

      
        <div id="7C-method" class="method-detail ">
          <a name="method-i-7C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ary | other_ary     &rarr; new_ary</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Set Union—Returns a new array by joining this array with
<em>other_ary</em>, removing duplicates.</p>

<pre>[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] | [ &quot;c&quot;, &quot;d&quot;, &quot;a&quot; ]
       #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</pre>
            

            
            <div class="method-source-code" id="7C-source">
              <pre>
              <code class='cpp'> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3;
    VALUE v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY_LEN(ary1)+RARRAY_LEN(ary2));
    hash = ary_add_hash(ary_make_hash(ary1), ary2);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = vv = rb_ary_elt(ary1, i);
        if (st_delete(RHASH_TBL(hash), (st_data_t*)&amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    for (i=0; i&lt;RARRAY_LEN(ary2); i++) {
        v = vv = rb_ary_elt(ary2, i);
        if (st_delete(RHASH_TBL(hash), (st_data_t*)&amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }
    ary_recycle_hash(hash);
    return ary3;
}</code>
</pre> 
            </div><!-- 7C-source -->
            
          </div>

          

          
        </div><!-- 7C-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
 <div class='info'>
  <p>Commenting is here to help enhance the documentation.  For example, sample code, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href='http://www.ruby-lang.org/en/community/mailing-lists/'>Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href='http://bugs.ruby-lang.org/projects/ruby/wiki/HowtoReport' >file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  </div>

  </div><!-- documentation -->
 
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.2</small></p> 
  
   <p> <a href="http://www.ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>. <a href="http://www.neurogami.com">Maximum R+D</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Ruby-doc Rdoc Generator</a> 0.9.5</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>
</body>
</html>

