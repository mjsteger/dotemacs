This is python.info, produced by makeinfo version 4.8 from
build/texinfo/python.texi.

Generated by Sphinx 1.1pre.
INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY

     Python 2.7.2, April 02, 2012

     Georg Brandl

     Copyright (C) 1990-2012, Python Software Foundation


File: python.info,  Node: Miscellaneous System Information,  Next: Miscellaneous Functions,  Prev: Process Management,  Up: os --- Miscellaneous operating system interfaces

5.15.1.7 Miscellaneous System Information
.........................................

 -- Function: os.confstr (name)
     Return string-valued system configuration values. _name_ specifies
     the configuration value to retrieve; it may be a string which is
     the name of a defined system value; these names are specified in a
     number of standards (POSIX, Unix 95, Unix 98, and others).  Some
     platforms define additional names as well.  The names known to the
     host operating system are given as the keys of the `confstr_names'
     dictionary.  For configuration variables not included in that
     mapping, passing an integer for _name_ is also accepted.

     If the configuration value specified by _name_ isn't defined,
     `None' is returned.

     If _name_ is a string and is not known, *note ValueError: 233. is
     raised.  If a specific value for _name_ is not supported by the
     host system, even if it is included in `confstr_names', an *note
     OSError: 22e. is raised with *note errno.EINVAL: 10bd. for the
     error number.

     Availability: Unix

 -- Data: os.confstr_names
     Dictionary mapping names accepted by *note confstr(): 1143. to the
     integer values defined for those names by the host operating
     system. This can be used to determine the set of names known to
     the system.

     Availability: Unix.

 -- Function: os.getloadavg ()
     Return the number of processes in the system run queue averaged
     over the last 1, 5, and 15 minutes or raises *note OSError: 22e.
     if the load average was unobtainable.

     Availability: Unix.

     New in version 2.3.

 -- Function: os.sysconf (name)
     Return integer-valued system configuration values. If the
     configuration value specified by _name_ isn't defined, `-1' is
     returned.  The comments regarding the _name_ parameter for *note
     confstr(): 1143. apply here as well; the dictionary that provides
     information on the known names is given by `sysconf_names'.

     Availability: Unix.

 -- Data: os.sysconf_names
     Dictionary mapping names accepted by *note sysconf(): 1146. to the
     integer values defined for those names by the host operating
     system. This can be used to determine the set of names known to
     the system.

     Availability: Unix.

  The following data values are used to support path manipulation
operations.  These are defined for all platforms.

  Higher-level operations on pathnames are defined in the *note
os.path: 12a. module.

 -- Data: os.curdir
     The constant string used by the operating system to refer to the
     current directory. This is `'.'' for Windows and POSIX. Also
     available via *note os.path: 12a.

 -- Data: os.pardir
     The constant string used by the operating system to refer to the
     parent directory. This is `'..'' for Windows and POSIX. Also
     available via *note os.path: 12a.

 -- Data: os.sep
     The character used by the operating system to separate pathname
     components.  This is `'/'' for POSIX and `'\\'' for Windows.  Note
     that knowing this is not sufficient to be able to parse or
     concatenate pathnames -- use *note os.path.split(): dca. and *note
     os.path.join(): dc2. -- but it is occasionally useful. Also
     available via *note os.path: 12a.

 -- Data: os.altsep
     An alternative character used by the operating system to separate
     pathname components, or `None' if only one separator character
     exists.  This is set to `'/'' on Windows systems where `sep' is a
     backslash. Also available via *note os.path: 12a.

 -- Data: os.extsep
     The character which separates the base filename from the
     extension; for example, the `'.'' in `os.py'. Also available via
     *note os.path: 12a.

     New in version 2.2.

 -- Data: os.pathsep
     The character conventionally used by the operating system to
     separate search path components (as in `PATH'), such as `':'' for
     POSIX or `';'' for Windows. Also available via *note os.path: 12a.

 -- Data: os.defpath
     The default search path used by `exec*p*()' and `spawn*p*()' if the
     environment doesn't have a `'PATH'' key. Also available via *note
     os.path: 12a.

 -- Data: os.linesep
     The string used to separate (or, rather, terminate) lines on the
     current platform.  This may be a single character, such as `'\n''
     for POSIX, or multiple characters, for example, `'\r\n'' for
     Windows. Do not use _os.linesep_ as a line terminator when writing
     files opened in text mode (the default); use a single `'\n''
     instead, on all platforms.

 -- Data: os.devnull
     The file path of the null device. For example: `'/dev/null'' for
     POSIX, `'nul'' for Windows.  Also available via *note os.path: 12a.

     New in version 2.4.


File: python.info,  Node: Miscellaneous Functions,  Prev: Miscellaneous System Information,  Up: os --- Miscellaneous operating system interfaces

5.15.1.8 Miscellaneous Functions
................................

 -- Function: os.urandom (n)
     Return a string of _n_ random bytes suitable for cryptographic use.

     This function returns random bytes from an OS-specific randomness
     source.  The returned data should be unpredictable enough for
     cryptographic applications, though its exact quality depends on
     the OS implementation.  On a UNIX-like system this will query
     /dev/urandom, and on Windows it will use CryptGenRandom.  If a
     randomness source is not found, *note NotImplementedError: 919.
     will be raised.

     New in version 2.4.


File: python.info,  Node: io --- Core tools for working with streams,  Next: time --- Time access and conversions,  Prev: os --- Miscellaneous operating system interfaces,  Up: Generic Operating System Services

5.15.2 `io' -- Core tools for working with streams
--------------------------------------------------

New in version 2.6.

  The *note io: fa. module provides the Python interfaces to stream
handling.  Under Python 2.x, this is proposed as an alternative to the
built-in *note file: 1f6. object, but in Python 3.x it is the default
interface to access files and streams.

     Note: Since this module has been designed primarily for Python
     3.x, you have to be aware that all uses of "bytes" in this
     document refer to the *note str: 1e7. type (of which `bytes' is an
     alias), and all uses of "text" refer to the *note unicode: 1f2.
     type.  Furthermore, those two types are not interchangeable in the
     *note io: fa. APIs.

  At the top of the I/O hierarchy is the abstract base class *note
IOBase: 1152.  It defines the basic interface to a stream.  Note,
however, that there is no separation between reading and writing to
streams; implementations are allowed to raise an *note IOError: 1f7. if
they do not support a given operation.

  Extending *note IOBase: 1152. is *note RawIOBase: 1153. which deals
simply with the reading and writing of raw bytes to a stream.  *note
FileIO: 22d. subclasses *note RawIOBase: 1153. to provide an interface
to files in the machine's file system.

  *note BufferedIOBase: 225. deals with buffering on a raw byte stream
(*note RawIOBase: 1153.).  Its subclasses, *note BufferedWriter: 1154,
*note BufferedReader: 226, and *note BufferedRWPair: 1155. buffer
streams that are readable, writable, and both readable and writable.
*note BufferedRandom: 1156. provides a buffered interface to random
access streams.  *note BytesIO: 1157. is a simple stream of in-memory
bytes.

  Another *note IOBase: 1152. subclass, *note TextIOBase: 22c, deals
with streams whose bytes represent text, and handles encoding and
decoding from and to *note unicode: 1f2. strings.  *note TextIOWrapper:
1158, which extends it, is a buffered text interface to a buffered raw
stream (*note BufferedIOBase: 225.). Finally, *note StringIO: 165. is
an in-memory stream for unicode text.

  Argument names are not part of the specification, and only the
arguments of *note open(): 1159. are intended to be used as keyword
arguments.

* Menu:

* Module Interface::
* I/O Base Classes::
* Raw File I/O::
* Buffered Streams::
* Text I/O::
* Advanced topics::


File: python.info,  Node: Module Interface,  Next: I/O Base Classes,  Up: io --- Core tools for working with streams

5.15.2.1 Module Interface
.........................

 -- Data: io.DEFAULT_BUFFER_SIZE
     An int containing the default buffer size used by the module's
     buffered I/O classes.  *note open(): 1159. uses the file's blksize
     (as obtained by *note os.stat(): 3b3.) if possible.

 -- Function: io.open (file, mode='r', buffering=-1, encoding=None,
          errors=None, newline=None, closefd=True)
     Open _file_ and return a corresponding stream.  If the file cannot
     be opened, an *note IOError: 1f7. is raised.

     _file_ is either a string giving the pathname (absolute or
     relative to the current working directory) of the file to be
     opened or an integer file descriptor of the file to be wrapped.
     (If a file descriptor is given, it is closed when the returned I/O
     object is closed, unless _closefd_ is set to `False'.)

     _mode_ is an optional string that specifies the mode in which the
     file is opened.  It defaults to `'r'' which means open for reading
     in text mode.  Other common values are `'w'' for writing
     (truncating the file if it already exists), and `'a'' for
     appending (which on _some_ Unix systems, means that _all_ writes
     append to the end of the file regardless of the current seek
     position).  In text mode, if _encoding_ is not specified the
     encoding used is platform dependent. (For reading and writing raw
     bytes use binary mode and leave _encoding_ unspecified.)  The
     available modes are:

     Character     Meaning
     `'r''         open for reading (default)
     `'w''         open for writing, truncating the file first
     `'a''         open for writing, appending to the end of the file if it exists
     `'b''         binary mode
     `'t''         text mode (default)
     `'+''         open a disk file for updating (reading and writing)
     `'U''         universal newline mode (for backwards compatibility; should not be
                   used in new code)

     The default mode is `'rt'' (open for reading text).  For binary
     random access, the mode `'w+b'' opens and truncates the file to 0
     bytes, while `'r+b'' opens the file without truncation.

     Python distinguishes between files opened in binary and text
     modes, even when the underlying operating system doesn't.  Files
     opened in binary mode (including `'b'' in the _mode_ argument)
     return contents as `bytes' objects without any decoding.  In text
     mode (the default, or when `'t'' is included in the _mode_
     argument), the contents of the file are returned as *note unicode:
     1f2. strings, the bytes having been first decoded using a
     platform-dependent encoding or using the specified _encoding_ if
     given.

     _buffering_ is an optional integer used to set the buffering
     policy.  Pass 0 to switch buffering off (only allowed in binary
     mode), 1 to select line buffering (only usable in text mode), and
     an integer > 1 to indicate the size of a fixed-size chunk buffer.
     When no _buffering_ argument is given, the default buffering
     policy works as follows:

        * Binary files are buffered in fixed-size chunks; the size of
          the buffer is chosen using a heuristic trying to determine
          the underlying device's "block size" and falling back on
          *note DEFAULT_BUFFER_SIZE: 115b.  On many systems, the buffer
          will typically be 4096 or 8192 bytes long.

        * "Interactive" text files (files for which `isatty()' returns
          True) use line buffering.  Other text files use the policy
          described above for binary files.

     _encoding_ is the name of the encoding used to decode or encode
     the file.  This should only be used in text mode.  The default
     encoding is platform dependent (whatever *note
     locale.getpreferredencoding(): 115c. returns), but any encoding
     supported by Python can be used.  See the *note codecs: 63. module
     for the list of supported encodings.

     _errors_ is an optional string that specifies how encoding and
     decoding errors are to be handled-this cannot be used in binary
     mode.  Pass `'strict'' to raise a *note ValueError: 233. exception
     if there is an encoding error (the default of `None' has the same
     effect), or pass `'ignore'' to ignore errors.  (Note that ignoring
     encoding errors can lead to data loss.)  `'replace'' causes a
     replacement marker (such as `'?'') to be inserted where there is
     malformed data.  When writing, `'xmlcharrefreplace'' (replace with
     the appropriate XML character reference) or `'backslashreplace''
     (replace with backslashed escape sequences) can be used.  Any
     other error handling name that has been registered with *note
     codecs.register_error(): 42d. is also valid.

     _newline_ controls how universal newlines works (it only applies
     to text mode).  It can be `None', `''', `'\n'', `'\r'', and
     `'\r\n''.  It works as follows:

        * On input, if _newline_ is `None', universal newlines mode is
          enabled.  Lines in the input can end in `'\n'', `'\r'', or
          `'\r\n'', and these are translated into `'\n'' before being
          returned to the caller.  If it is `''', universal newline
          mode is enabled, but line endings are returned to the caller
          untranslated.  If it has any of the other legal values, input
          lines are only terminated by the given string, and the line
          ending is returned to the caller untranslated.

        * On output, if _newline_ is `None', any `'\n'' characters
          written are translated to the system default line separator,
          *note os.linesep: 114c.  If _newline_ is `''', no translation
          takes place.  If _newline_ is any of the other legal values,
          any `'\n'' characters written are translated to the given
          string.

     If _closefd_ is `False' and a file descriptor rather than a
     filename was given, the underlying file descriptor will be kept
     open when the file is closed.  If a filename is given _closefd_
     has no effect and must be `True' (the default).

     The type of file object returned by the *note open(): 1159.
     function depends on the mode.  When *note open(): 1159. is used to
     open a file in a text mode (`'w'', `'r'', `'wt'', `'rt'', etc.),
     it returns a subclass of *note TextIOBase: 22c. (specifically
     *note TextIOWrapper: 1158.).  When used to open a file in a binary
     mode with buffering, the returned class is a subclass of *note
     BufferedIOBase: 225.  The exact class varies: in read binary mode,
     it returns a *note BufferedReader: 226.; in write binary and
     append binary modes, it returns a *note BufferedWriter: 1154, and
     in read/write mode, it returns a *note BufferedRandom: 1156.  When
     buffering is disabled, the raw stream, a subclass of *note
     RawIOBase: 1153, *note FileIO: 22d, is returned.

     It is also possible to use an *note unicode: 1f2. or `bytes' string
     as a file for both reading and writing.  For *note unicode: 1f2.
     strings *note StringIO: 165. can be used like a file opened in
     text mode, and for `bytes' a *note BytesIO: 1157. can be used like
     a file opened in a binary mode.

 -- Exception: io.BlockingIOError
     Error raised when blocking would occur on a non-blocking stream.
     It inherits *note IOError: 1f7.

     In addition to those of *note IOError: 1f7, *note BlockingIOError:
     115d. has one attribute:

      -- Attribute: characters_written
          An integer containing the number of characters written to the
          stream before it blocked.

 -- Exception: io.UnsupportedOperation
     An exception inheriting *note IOError: 1f7. and *note ValueError:
     233. that is raised when an unsupported operation is called on a
     stream.


File: python.info,  Node: I/O Base Classes,  Next: Raw File I/O,  Prev: Module Interface,  Up: io --- Core tools for working with streams

5.15.2.2 I/O Base Classes
.........................

 -- Class: io.IOBase
     The abstract base class for all I/O classes, acting on streams of
     bytes.  There is no public constructor.

     This class provides empty abstract implementations for many methods
     that derived classes can override selectively; the default
     implementations represent a file that cannot be read, written or
     seeked.

     Even though *note IOBase: 1152. does not declare `read()',
     `readinto()', or `write()' because their signatures will vary,
     implementations and clients should consider those methods part of
     the interface.  Also, implementations may raise a *note IOError:
     1f7. when operations they do not support are called.

     The basic type used for binary data read from or written to a file
     is `bytes' (also known as *note str: 1e7.).  *note bytearray:
     1f4.s are accepted too, and in some cases (such as `readinto')
     required.  Text I/O classes work with *note unicode: 1f2. data.

     Note that calling any method (even inquiries) on a closed stream is
     undefined.  Implementations may raise *note IOError: 1f7. in this
     case.

     IOBase (and its subclasses) support the iterator protocol, meaning
     that an *note IOBase: 1152. object can be iterated over yielding
     the lines in a stream.  Lines are defined slightly differently
     depending on whether the stream is a binary stream (yielding
     `bytes'), or a text stream (yielding *note unicode: 1f2. strings).
     See *note readline(): 145. below.

     IOBase is also a context manager and therefore supports the *note
     with: 1bd. statement.  In this example, _file_ is closed after the
     *note with: 1bd. statement's suite is finished--even if an
     exception occurs:

         with io.open('spam.txt', 'w') as file:
             file.write(u'Spam and eggs!')

     *note IOBase: 1152. provides these data attributes and methods:

      -- Method: close ()
          Flush and close this stream. This method has no effect if the
          file is already closed. Once the file is closed, any
          operation on the file (e.g. reading or writing) will raise a
          *note ValueError: 233.

          As a convenience, it is allowed to call this method more than
          once; only the first call, however, will have an effect.

      -- Attribute: closed
          True if the stream is closed.

      -- Method: fileno ()
          Return the underlying file descriptor (an integer) of the
          stream if it exists.  An *note IOError: 1f7. is raised if the
          IO object does not use a file descriptor.

      -- Method: flush ()
          Flush the write buffers of the stream if applicable.  This
          does nothing for read-only and non-blocking streams.

      -- Method: isatty ()
          Return `True' if the stream is interactive (i.e., connected to
          a terminal/tty device).

      -- Method: readable ()
          Return `True' if the stream can be read from.  If False,
          `read()' will raise *note IOError: 1f7.

      -- Method: readline (limit=-1)
          Read and return one line from the stream.  If _limit_ is
          specified, at most _limit_ bytes will be read.

          The line terminator is always `b'\n'' for binary files; for
          text files, the _newlines_ argument to *note open(): 1159.
          can be used to select the line terminator(s) recognized.

      -- Method: readlines (hint=-1)
          Read and return a list of lines from the stream.  _hint_ can
          be specified to control the number of lines read: no more
          lines will be read if the total size (in bytes/characters) of
          all lines so far exceeds _hint_.

      -- Method: seek (offset, whence=SEEK_SET)
          Change the stream position to the given byte _offset_.
          _offset_ is interpreted relative to the position indicated by
          _whence_.  Values for _whence_ are:

             * `SEEK_SET' or `0' - start of the stream (the default);
               _offset_ should be zero or positive

             * `SEEK_CUR' or `1' - current stream position; _offset_ may
               be negative

             * `SEEK_END' or `2' - end of the stream; _offset_ is
               usually negative

          Return the new absolute position.

          New in version 2.7: The `SEEK_*' constants

      -- Method: seekable ()
          Return `True' if the stream supports random access.  If
          `False', *note seek(): 1169, *note tell(): 116b. and *note
          truncate(): 22f. will raise *note IOError: 1f7.

      -- Method: tell ()
          Return the current stream position.

      -- Method: truncate (size=None)
          Resize the stream to the given _size_ in bytes (or the
          current position if _size_ is not specified).  The current
          stream position isn't changed.  This resizing can extend or
          reduce the current file size.  In case of extension, the
          contents of the new file area depend on the platform (on most
          systems, additional bytes are zero-filled, on Windows they're
          undetermined).  The new file size is returned.

      -- Method: writable ()
          Return `True' if the stream supports writing.  If `False',
          `write()' and *note truncate(): 22f. will raise *note
          IOError: 1f7.

      -- Method: writelines (lines)
          Write a list of lines to the stream.  Line separators are not
          added, so it is usual for each of the lines provided to have
          a line separator at the end.

 -- Class: io.RawIOBase
     Base class for raw binary I/O.  It inherits *note IOBase: 1152.
     There is no public constructor.

     Raw binary I/O typically provides low-level access to an
     underlying OS device or API, and does not try to encapsulate it in
     high-level primitives (this is left to Buffered I/O and Text I/O,
     described later in this page).

     In addition to the attributes and methods from *note IOBase: 1152,
     RawIOBase provides the following methods:

      -- Method: read (n=-1)
          Read up to _n_ bytes from the object and return them.  As a
          convenience, if _n_ is unspecified or -1, *note readall():
          116f. is called.  Otherwise, only one system call is ever
          made.  Fewer than _n_ bytes may be returned if the operating
          system call returns fewer than _n_ bytes.

          If 0 bytes are returned, and _n_ was not 0, this indicates
          end of file.  If the object is in non-blocking mode and no
          bytes are available, `None' is returned.

      -- Method: readall ()
          Read and return all the bytes from the stream until EOF,
          using multiple calls to the stream if necessary.

      -- Method: readinto (b)
          Read up to len(b) bytes into bytearray _b_ and return the
          number of bytes read.  If the object is in non-blocking mode
          and no bytes are available, `None' is returned.

      -- Method: write (b)
          Write the given bytes or bytearray object, _b_, to the
          underlying raw stream and return the number of bytes written.
          This can be less than `len(b)', depending on specifics of
          the underlying raw stream, and especially if it is in
          non-blocking mode.  `None' is returned if the raw stream is
          set not to block and no single byte could be readily written
          to it.

 -- Class: io.BufferedIOBase
     Base class for binary streams that support some kind of buffering.
     It inherits *note IOBase: 1152. There is no public constructor.

     The main difference with *note RawIOBase: 1153. is that methods
     *note read(): 1172, *note readinto(): 1173. and *note write():
     1174. will try (respectively) to read as much input as requested
     or to consume all given output, at the expense of making perhaps
     more than one system call.

     In addition, those methods can raise *note BlockingIOError: 115d.
     if the underlying raw stream is in non-blocking mode and cannot
     take or give enough data; unlike their *note RawIOBase: 1153.
     counterparts, they will never return `None'.

     Besides, the *note read(): 1172. method does not have a default
     implementation that defers to *note readinto(): 1173.

     A typical *note BufferedIOBase: 225. implementation should not
     inherit from a *note RawIOBase: 1153. implementation, but wrap
     one, like *note BufferedWriter: 1154. and *note BufferedReader:
     226. do.

     *note BufferedIOBase: 225. provides or overrides these members in
     addition to those from *note IOBase: 1152.:

      -- Attribute: raw
          The underlying raw stream (a *note RawIOBase: 1153. instance)
          that *note BufferedIOBase: 225. deals with.  This is not part
          of the *note BufferedIOBase: 225. API and may not exist on
          some implementations.

      -- Method: detach ()
          Separate the underlying raw stream from the buffer and return
          it.

          After the raw stream has been detached, the buffer is in an
          unusable state.

          Some buffers, like *note BytesIO: 1157, do not have the
          concept of a single raw stream to return from this method.
          They raise *note UnsupportedOperation: 115f.

          New in version 2.7.

      -- Method: read (n=-1)
          Read and return up to _n_ bytes.  If the argument is omitted,
          `None', or negative, data is read and returned until EOF is
          reached.  An empty bytes object is returned if the stream is
          already at EOF.

          If the argument is positive, and the underlying raw stream is
          not interactive, multiple raw reads may be issued to satisfy
          the byte count (unless EOF is reached first).  But for
          interactive raw streams, at most one raw read will be issued,
          and a short result does not imply that EOF is imminent.

          A *note BlockingIOError: 115d. is raised if the underlying
          raw stream is in non blocking-mode, and has no data available
          at the moment.

      -- Method: read1 (n=-1)
          Read and return up to _n_ bytes, with at most one call to the
          underlying raw stream's *note read(): 116e. method.  This can
          be useful if you are implementing your own buffering on top
          of a *note BufferedIOBase: 225.  object.

      -- Method: readinto (b)
          Read up to len(b) bytes into bytearray _b_ and return the
          number of bytes read.

          Like *note read(): 1172, multiple reads may be issued to the
          underlying raw stream, unless the latter is 'interactive'.

          A *note BlockingIOError: 115d. is raised if the underlying
          raw stream is in non blocking-mode, and has no data available
          at the moment.

      -- Method: write (b)
          Write the given bytes or bytearray object, _b_ and return the
          number of bytes written (never less than `len(b)', since if
          the write fails an *note IOError: 1f7. will be raised).
          Depending on the actual implementation, these bytes may be
          readily written to the underlying stream, or held in a buffer
          for performance and latency reasons.

          When in non-blocking mode, a *note BlockingIOError: 115d. is
          raised if the data needed to be written to the raw stream but
          it couldn't accept all the data without blocking.


File: python.info,  Node: Raw File I/O,  Next: Buffered Streams,  Prev: I/O Base Classes,  Up: io --- Core tools for working with streams

5.15.2.3 Raw File I/O
.....................

 -- Class: io.FileIO (name, mode='r', closefd=True)
     *note FileIO: 22d. represents an OS-level file containing bytes
     data.  It implements the *note RawIOBase: 1153. interface (and
     therefore the *note IOBase: 1152. interface, too).

     The _name_ can be one of two things:

        * a string representing the path to the file which will be
          opened;

        * an integer representing the number of an existing OS-level
          file descriptor to which the resulting *note FileIO: 22d.
          object will give access.

     The _mode_ can be `'r'', `'w'' or `'a'' for reading (default),
     writing, or appending.  The file will be created if it doesn't
     exist when opened for writing or appending; it will be truncated
     when opened for writing.  Add a `'+'' to the mode to allow
     simultaneous reading and writing.

     The `read()' (when called with a positive argument), `readinto()'
     and `write()' methods on this class will only make one system call.

     In addition to the attributes and methods from *note IOBase: 1152.
     and *note RawIOBase: 1153, *note FileIO: 22d. provides the
     following data attributes and methods:

      -- Attribute: mode
          The mode as given in the constructor.

      -- Attribute: name
          The file name.  This is the file descriptor of the file when
          no name is given in the constructor.


File: python.info,  Node: Buffered Streams,  Next: Text I/O,  Prev: Raw File I/O,  Up: io --- Core tools for working with streams

5.15.2.4 Buffered Streams
.........................

Buffered I/O streams provide a higher-level interface to an I/O device
than raw I/O does.

 -- Class: io.BytesIO ([initial_bytes])
     A stream implementation using an in-memory bytes buffer.  It
     inherits *note BufferedIOBase: 225.

     The argument _initial_bytes_ is an optional initial `bytes'.

     *note BytesIO: 1157. provides or overrides these methods in
     addition to those from *note BufferedIOBase: 225. and *note
     IOBase: 1152.:

      -- Method: getvalue ()
          Return `bytes' containing the entire contents of the buffer.

      -- Method: read1 ()
          In *note BytesIO: 1157, this is the same as `read()'.

 -- Class: io.BufferedReader (raw, buffer_size=DEFAULT_BUFFER_SIZE)
     A buffer providing higher-level access to a readable, sequential
     *note RawIOBase: 1153. object.  It inherits *note BufferedIOBase:
     225.  When reading data from this object, a larger amount of data
     may be requested from the underlying raw stream, and kept in an
     internal buffer.  The buffered data can then be returned directly
     on subsequent reads.

     The constructor creates a *note BufferedReader: 226. for the given
     readable _raw_ stream and _buffer_size_.  If _buffer_size_ is
     omitted, *note DEFAULT_BUFFER_SIZE: 115b. is used.

     *note BufferedReader: 226. provides or overrides these methods in
     addition to those from *note BufferedIOBase: 225. and *note
     IOBase: 1152.:

      -- Method: peek ([n])
          Return bytes from the stream without advancing the position.
          At most one single read on the raw stream is done to satisfy
          the call. The number of bytes returned may be less or more
          than requested.

      -- Method: read ([n])
          Read and return _n_ bytes, or if _n_ is not given or
          negative, until EOF or if the read call would block in
          non-blocking mode.

      -- Method: read1 (n)
          Read and return up to _n_ bytes with only one call on the raw
          stream.  If at least one byte is buffered, only buffered
          bytes are returned.  Otherwise, one raw stream read call is
          made.

 -- Class: io.BufferedWriter (raw, buffer_size=DEFAULT_BUFFER_SIZE)
     A buffer providing higher-level access to a writeable, sequential
     *note RawIOBase: 1153. object.  It inherits *note BufferedIOBase:
     225.  When writing to this object, data is normally held into an
     internal buffer.  The buffer will be written out to the underlying
     *note RawIOBase: 1153.  object under various conditions, including:

        * when the buffer gets too small for all pending data;

        * when *note flush(): 1181. is called;

        * when a `seek()' is requested (for *note BufferedRandom: 1156.
          objects);

        * when the *note BufferedWriter: 1154. object is closed or
          destroyed.

     The constructor creates a *note BufferedWriter: 1154. for the
     given writeable _raw_ stream.  If the _buffer_size_ is not given,
     it defaults to *note DEFAULT_BUFFER_SIZE: 115b.

     A third argument, _max_buffer_size_, is supported, but unused and
     deprecated.

     *note BufferedWriter: 1154. provides or overrides these methods in
     addition to those from *note BufferedIOBase: 225. and *note
     IOBase: 1152.:

      -- Method: flush ()
          Force bytes held in the buffer into the raw stream.  A *note
          BlockingIOError: 115d. should be raised if the raw stream
          blocks.

      -- Method: write (b)
          Write the bytes or bytearray object, _b_ and return the
          number of bytes written.  When in non-blocking mode, a *note
          BlockingIOError: 115d. is raised if the buffer needs to be
          written out but the raw stream blocks.

 -- Class: io.BufferedRWPair (reader, writer,
          buffer_size=DEFAULT_BUFFER_SIZE)
     A buffered I/O object giving a combined, higher-level access to two
     sequential *note RawIOBase: 1153. objects: one readable, the other
     writeable.  It is useful for pairs of unidirectional communication
     channels (pipes, for instance).  It inherits *note BufferedIOBase:
     225.

     _reader_ and _writer_ are *note RawIOBase: 1153. objects that are
     readable and writeable respectively.  If the _buffer_size_ is
     omitted it defaults to *note DEFAULT_BUFFER_SIZE: 115b.

     A fourth argument, _max_buffer_size_, is supported, but unused and
     deprecated.

     *note BufferedRWPair: 1155. implements all of *note
     BufferedIOBase: 225.'s methods except for *note detach(): 1176,
     which raises *note UnsupportedOperation: 115f.

 -- Class: io.BufferedRandom (raw, buffer_size=DEFAULT_BUFFER_SIZE)
     A buffered interface to random access streams.  It inherits *note
     BufferedReader: 226. and *note BufferedWriter: 1154, and further
     supports `seek()' and `tell()' functionality.

     The constructor creates a reader and writer for a seekable raw
     stream, given in the first argument.  If the _buffer_size_ is
     omitted it defaults to *note DEFAULT_BUFFER_SIZE: 115b.

     A third argument, _max_buffer_size_, is supported, but unused and
     deprecated.

     *note BufferedRandom: 1156. is capable of anything *note
     BufferedReader: 226. or *note BufferedWriter: 1154. can do.


File: python.info,  Node: Text I/O,  Next: Advanced topics,  Prev: Buffered Streams,  Up: io --- Core tools for working with streams

5.15.2.5 Text I/O
.................

 -- Class: io.TextIOBase
     Base class for text streams.  This class provides an unicode
     character and line based interface to stream I/O.  There is no
     `readinto()' method because Python's *note unicode: 1f2. strings
     are immutable.  It inherits *note IOBase: 1152.  There is no
     public constructor.

     *note TextIOBase: 22c. provides or overrides these data attributes
     and methods in addition to those from *note IOBase: 1152.:

      -- Attribute: encoding
          The name of the encoding used to decode the stream's bytes
          into strings, and to encode strings into bytes.

      -- Attribute: errors
          The error setting of the decoder or encoder.

      -- Attribute: newlines
          A string, a tuple of strings, or `None', indicating the
          newlines translated so far.  Depending on the implementation
          and the initial constructor flags, this may not be available.

      -- Attribute: buffer
          The underlying binary buffer (a *note BufferedIOBase: 225.
          instance) that *note TextIOBase: 22c. deals with.  This is
          not part of the *note TextIOBase: 22c. API and may not exist
          on some implementations.

      -- Method: detach ()
          Separate the underlying binary buffer from the *note
          TextIOBase: 22c. and return it.

          After the underlying buffer has been detached, the *note
          TextIOBase: 22c. is in an unusable state.

          Some *note TextIOBase: 22c. implementations, like *note
          StringIO: 165, may not have the concept of an underlying
          buffer and calling this method will raise *note
          UnsupportedOperation: 115f.

          New in version 2.7.

      -- Method: read (n)
          Read and return at most _n_ characters from the stream as a
          single *note unicode: 1f2.  If _n_ is negative or `None',
          reads until EOF.

      -- Method: readline ()
          Read until newline or EOF and return a single `unicode'.  If
          the stream is already at EOF, an empty string is returned.

      -- Method: write (s)
          Write the *note unicode: 1f2. string _s_ to the stream and
          return the number of characters written.

 -- Class: io.TextIOWrapper (buffer, encoding=None, errors=None,
          newline=None, line_buffering=False)
     A buffered text stream over a *note BufferedIOBase: 225. binary
     stream.  It inherits *note TextIOBase: 22c.

     _encoding_ gives the name of the encoding that the stream will be
     decoded or encoded with.  It defaults to *note
     locale.getpreferredencoding(): 115c.

     _errors_ is an optional string that specifies how encoding and
     decoding errors are to be handled.  Pass `'strict'' to raise a
     *note ValueError: 233.  exception if there is an encoding error
     (the default of `None' has the same effect), or pass `'ignore'' to
     ignore errors.  (Note that ignoring encoding errors can lead to
     data loss.)  `'replace'' causes a replacement marker (such as
     `'?'') to be inserted where there is malformed data.  When
     writing, `'xmlcharrefreplace'' (replace with the appropriate XML
     character reference) or `'backslashreplace'' (replace with
     backslashed escape sequences) can be used.  Any other error
     handling name that has been registered with *note
     codecs.register_error(): 42d. is also valid.

     _newline_ can be `None', `''', `'\n'', `'\r'', or `'\r\n''.  It
     controls the handling of line endings.  If it is `None', universal
     newlines is enabled.  With this enabled, on input, the lines
     endings `'\n'', `'\r'', or `'\r\n'' are translated to `'\n''
     before being returned to the caller.  Conversely, on output,
     `'\n'' is translated to the system default line separator, *note
     os.linesep: 114c.  If _newline_ is any other of its legal values,
     that newline becomes the newline when the file is read and it is
     returned untranslated.  On output, `'\n'' is converted to the
     _newline_.

     If _line_buffering_ is `True', `flush()' is implied when a call to
     write contains a newline character.

     *note TextIOWrapper: 1158. provides one attribute in addition to
     those of *note TextIOBase: 22c. and its parents:

      -- Attribute: line_buffering
          Whether line buffering is enabled.

 -- Class: io.StringIO (initial_value=u'', newline=None)
     An in-memory stream for unicode text.  It inherits *note
     TextIOWrapper: 1158.

     The initial value of the buffer (an empty unicode string by
     default) can be set by providing _initial_value_.  The _newline_
     argument works like that of *note TextIOWrapper: 1158.  The
     default is to do no newline translation.

     *note StringIO: 165. provides this method in addition to those from
     *note TextIOWrapper: 1158. and its parents:

      -- Method: getvalue ()
          Return a `unicode' containing the entire contents of the
          buffer at any time before the *note StringIO: 165. object's
          `close()' method is called.

     Example usage:

         import io

         output = io.StringIO()
         output.write(u'First line.\n')
         output.write(u'Second line.\n')

         # Retrieve file contents -- this will be
         # u'First line.\nSecond line.\n'
         contents = output.getvalue()

         # Close object and discard memory buffer --
         # .getvalue() will now raise an exception.
         output.close()



 -- Class: io.IncrementalNewlineDecoder
     A helper codec that decodes newlines for universal newlines mode.
     It inherits *note codecs.IncrementalDecoder: a14.


File: python.info,  Node: Advanced topics,  Prev: Text I/O,  Up: io --- Core tools for working with streams

5.15.2.6 Advanced topics
........................

Here we will discuss several advanced topics pertaining to the concrete
I/O implementations described above.

* Menu:

* Performance::
* Multi-threading: Multi-threading<2>.
* Reentrancy::

Performance

* Binary I/O::
* Text I/O: Text I/O<2>.


File: python.info,  Node: Performance,  Next: Multi-threading<2>,  Up: Advanced topics

5.15.2.7 Performance
....................

* Menu:

* Binary I/O::
* Text I/O: Text I/O<2>.


File: python.info,  Node: Binary I/O,  Next: Text I/O<2>,  Up: Performance

5.15.2.8 Binary I/O
...................

By reading and writing only large chunks of data even when the user asks
for a single byte, buffered I/O is designed to hide any inefficiency in
calling and executing the operating system's unbuffered I/O routines.
The gain will vary very much depending on the OS and the kind of I/O
which is performed (for example, on some contemporary OSes such as
Linux, unbuffered disk I/O can be as fast as buffered I/O).  The bottom
line, however, is that buffered I/O will offer you predictable
performance regardless of the platform and the backing device.
Therefore, it is most always preferable to use buffered I/O rather than
unbuffered I/O.


File: python.info,  Node: Text I/O<2>,  Prev: Binary I/O,  Up: Performance

5.15.2.9 Text I/O
.................

Text I/O over a binary storage (such as a file) is significantly slower
than binary I/O over the same storage, because it implies conversions
from unicode to binary data using a character codec.  This can become
noticeable if you handle huge amounts of text data (for example very
large log files).  Also, `TextIOWrapper.tell()' and
`TextIOWrapper.seek()' are both quite slow due to the reconstruction
algorithm used.

  *note StringIO: 165, however, is a native in-memory unicode container
and will exhibit similar speed to *note BytesIO: 1157.


File: python.info,  Node: Multi-threading<2>,  Next: Reentrancy,  Prev: Performance,  Up: Advanced topics

5.15.2.10 Multi-threading
.........................

*note FileIO: 22d. objects are thread-safe to the extent that the
operating system calls (such as `read(2)' under Unix) they are wrapping
are thread-safe too.

  Binary buffered objects (instances of *note BufferedReader: 226,
*note BufferedWriter: 1154, *note BufferedRandom: 1156. and *note
BufferedRWPair: 1155.)  protect their internal structures using a lock;
it is therefore safe to call them from multiple threads at once.

  *note TextIOWrapper: 1158. objects are not thread-safe.


File: python.info,  Node: Reentrancy,  Prev: Multi-threading<2>,  Up: Advanced topics

5.15.2.11 Reentrancy
....................

Binary buffered objects (instances of *note BufferedReader: 226, *note
BufferedWriter: 1154, *note BufferedRandom: 1156. and *note
BufferedRWPair: 1155.)  are not reentrant.  While reentrant calls will
not happen in normal situations, they can arise if you are doing I/O in
a *note signal: 156. handler.  If it is attempted to enter a buffered
object again while already being accessed _from the same thread_, then
a *note RuntimeError: 38a. is raised.

  The above implicitly extends to text files, since the *note open():
2cb.  function will wrap a buffered object inside a *note
TextIOWrapper: 1158.  This includes standard streams and therefore
affects the built-in function *note print(): 2fc. as well.


File: python.info,  Node: time --- Time access and conversions,  Next: argparse --- Parser for command-line options arguments and sub-commands,  Prev: io --- Core tools for working with streams,  Up: Generic Operating System Services

5.15.3 `time' -- Time access and conversions
--------------------------------------------

This module provides various time-related functions. For related
functionality, see also the *note datetime: 7e. and *note calendar: 1f.
modules.

  Although this module is always available, not all functions are
available on all platforms.  Most of the functions defined in this
module call platform C library functions with the same name.  It may
sometimes be helpful to consult the platform documentation, because the
semantics of these functions varies among platforms.

  An explanation of some terminology and conventions is in order.

   * The _epoch_ is the point where the time starts.  On January 1st of
     that year, at 0 hours, the "time since the epoch" is zero.  For
     Unix, the epoch is 1970.  To find out what the epoch is, look at
     `gmtime(0)'.

   * The functions in this module do not handle dates and times before
     the epoch or far in the future.  The cut-off point in the future
     is determined by the C library; for Unix, it is typically in 2038.

   * *Year 2000 (Y2K) issues*:  Python depends on the platform's C
     library, which generally doesn't have year 2000 issues, since all
     dates and times are represented internally as seconds since the
     epoch.  Functions accepting a *note struct_time: a9b. (see below)
     generally require a 4-digit year.  For backward compatibility,
     2-digit years are supported if the module variable `accept2dyear'
     is a non-zero integer; this variable is initialized to `1' unless
     the environment variable *note PYTHONY2K: 62d. is set to a
     non-empty string, in which case it is initialized to `0'.  Thus,
     you can set *note PYTHONY2K: 62d. to a non-empty string in the
     environment to require 4-digit years for all year input.  When
     2-digit years are accepted, they are converted according to the
     POSIX or X/Open standard: values 69-99 are mapped to 1969-1999,
     and values 0-68 are mapped to 2000-2068. Values 100-1899 are
     always illegal.  Note that this is new as of Python 1.5.2(a2);
     earlier versions, up to Python 1.5.1 and 1.5.2a1, would add 1900
     to year values below 1900.

   * UTC is Coordinated Universal Time (formerly known as Greenwich
     Mean Time, or GMT).  The acronym UTC is not a mistake but a
     compromise between English and French.

   * DST is Daylight Saving Time, an adjustment of the timezone by
     (usually) one hour during part of the year.  DST rules are magic
     (determined by local law) and can change from year to year.  The C
     library has a table containing the local rules (often it is read
     from a system file for flexibility) and is the only source of True
     Wisdom in this respect.

   * The precision of the various real-time functions may be less than
     suggested by the units in which their value or argument is
     expressed. E.g. on most Unix systems, the clock "ticks" only 50 or
     100 times a second.

   * On the other hand, the precision of *note time(): 17b. and *note
     sleep(): 1198. is better than their Unix equivalents: times are
     expressed as floating point numbers, *note time(): 17b. returns
     the most accurate time available (using Unix `gettimeofday()'
     where available), and *note sleep(): 1198. will accept a time with
     a nonzero fraction (Unix `select()' is used to implement this,
     where available).

   * The time value as returned by *note gmtime(): b0b, *note
     localtime(): a9c, and *note strptime(): 3ac, and accepted by *note
     asctime(): 1199, *note mktime(): 119a. and *note strftime(): 3ad,
     may be considered as a sequence of 9 integers.  The return values
     of *note gmtime(): b0b, *note localtime(): a9c, and *note
     strptime(): 3ac. also offer attribute names for individual fields.

     See *note struct_time: a9b. for a description of these objects.

     Changed in version 2.2: The time value sequence was changed from a
     tuple to a *note struct_time: a9b, with the addition of attribute
     names for the fields.

   * Use the following functions to convert between time
     representations:

     From                          To                            Use
     ------------------------------------------------------------------------------------------ 
     seconds since the epoch       *note struct_time: a9b. in    *note gmtime(): b0b.
                                   UTC                           
     seconds since the epoch       *note struct_time: a9b. in    *note localtime(): a9c.
                                   local time                    
     *note struct_time: a9b. in    seconds since the epoch       *note calendar.timegm(): b0a.
     UTC                                                         
     *note struct_time: a9b. in    seconds since the epoch       *note mktime(): 119a.
     local time                                                  


  The module defines the following functions and data items:

 -- Data: time.accept2dyear
     Boolean value indicating whether two-digit year values will be
     accepted.  This is true by default, but will be set to false if
     the environment variable *note PYTHONY2K: 62d. has been set to a
     non-empty string.  It may also be modified at run time.

 -- Data: time.altzone
     The offset of the local DST timezone, in seconds west of UTC, if
     one is defined.  This is negative if the local DST timezone is
     east of UTC (as in Western Europe, including the UK).  Only use
     this if `daylight' is nonzero.

 -- Function: time.asctime ([t])
     Convert a tuple or *note struct_time: a9b. representing a time as
     returned by *note gmtime(): b0b. or *note localtime(): a9c. to a
     24-character string of the following form: `'Sun Jun 20 23:21:05
     1993''.  If _t_ is not provided, the current time as returned by
     *note localtime(): a9c. is used. Locale information is not used by
     *note asctime(): 1199.

          Note: Unlike the C function of the same name, there is no
          trailing newline.

     Changed in version 2.1: Allowed _t_ to be omitted.

 -- Function: time.clock ()
     On Unix, return the current processor time as a floating point
     number expressed in seconds.  The precision, and in fact the very
     definition of the meaning of "processor time", depends on that of
     the C function of the same name, but in any case, this is the
     function to use for benchmarking Python or timing algorithms.

     On Windows, this function returns wall-clock seconds elapsed since
     the first call to this function, as a floating point number, based
     on the Win32 function `QueryPerformanceCounter()'. The resolution
     is typically better than one microsecond.

 -- Function: time.ctime ([secs])
     Convert a time expressed in seconds since the epoch to a string
     representing local time. If _secs_ is not provided or *note None:
     389, the current time as returned by *note time(): 17b. is used.
     `ctime(secs)' is equivalent to `asctime(localtime(secs))'. Locale
     information is not used by *note ctime(): aa4.

     Changed in version 2.1: Allowed _secs_ to be omitted.

     Changed in version 2.4: If _secs_ is *note None: 389, the current
     time is used.

 -- Data: time.daylight
     Nonzero if a DST timezone is defined.

 -- Function: time.gmtime ([secs])
     Convert a time expressed in seconds since the epoch to a *note
     struct_time: a9b. in UTC in which the dst flag is always zero.  If
     _secs_ is not provided or *note None: 389, the current time as
     returned by *note time(): 17b. is used.  Fractions of a second are
     ignored.  See above for a description of the *note struct_time:
     a9b. object. See *note calendar.timegm(): b0a. for the inverse of
     this function.

     Changed in version 2.1: Allowed _secs_ to be omitted.

     Changed in version 2.4: If _secs_ is *note None: 389, the current
     time is used.

 -- Function: time.localtime ([secs])
     Like *note gmtime(): b0b. but converts to local time.  If _secs_
     is not provided or *note None: 389, the current time as returned
     by *note time(): 17b. is used.  The dst flag is set to `1' when
     DST applies to the given time.

     Changed in version 2.1: Allowed _secs_ to be omitted.

     Changed in version 2.4: If _secs_ is *note None: 389, the current
     time is used.

 -- Function: time.mktime (t)
     This is the inverse function of *note localtime(): a9c.  Its
     argument is the *note struct_time: a9b. or full 9-tuple (since the
     dst flag is needed; use `-1' as the dst flag if it is unknown)
     which expresses the time in _local_ time, not UTC.  It returns a
     floating point number, for compatibility with *note time(): 17b.
     If the input value cannot be represented as a valid time, either
     *note OverflowError: 2cf. or *note ValueError: 233. will be raised
     (which depends on whether the invalid value is caught by Python or
     the underlying C libraries).  The earliest date for which it can
     generate a time is platform-dependent.

 -- Function: time.sleep (secs)
     Suspend execution for the given number of seconds.  The argument
     may be a floating point number to indicate a more precise sleep
     time. The actual suspension time may be less than that requested
     because any caught signal will terminate the *note sleep(): 1198.
     following execution of that signal's catching routine.  Also, the
     suspension time may be longer than requested by an arbitrary
     amount because of the scheduling of other activity in the system.

 -- Function: time.strftime (format[, t])
     Convert a tuple or *note struct_time: a9b. representing a time as
     returned by *note gmtime(): b0b. or *note localtime(): a9c. to a
     string as specified by the _format_ argument.  If _t_ is not
     provided, the current time as returned by *note localtime(): a9c.
     is used.  _format_ must be a string.  *note ValueError: 233. is
     raised if any field in _t_ is outside of the allowed range.

     Changed in version 2.1: Allowed _t_ to be omitted.

     Changed in version 2.4: *note ValueError: 233. raised if a field
     in _t_ is out of range.

     Changed in version 2.5: 0 is now a legal argument for any position
     in the time tuple; if it is normally illegal the value is forced
     to a correct one..

     The following directives can be embedded in the _format_ string.
     They are shown without the optional field width and precision
     specification, and are replaced by the indicated characters in the
     *note strftime(): 3ad. result:

     Directive       Meaning                              Notes
     ----------------------------------------------------------------- 
     `%a'            Locale's abbreviated weekday name.   
     `%A'            Locale's full weekday name.          
     `%b'            Locale's abbreviated month name.     
     `%B'            Locale's full month name.            
     `%c'            Locale's appropriate date and time   
                     representation.                      
     `%d'            Day of the month as a decimal        
                     number [01,31].                      
     `%H'            Hour (24-hour clock) as a decimal    
                     number [00,23].                      
     `%I'            Hour (12-hour clock) as a decimal    
                     number [01,12].                      
     `%j'            Day of the year as a decimal number  
                     [001,366].                           
     `%m'            Month as a decimal number [01,12].   
     `%M'            Minute as a decimal number [00,59].  
     `%p'            Locale's equivalent of either AM or  (1)
                     PM.                                  
     `%S'            Second as a decimal number [00,61].  (2)
     `%U'            Week number of the year (Sunday as   (3)
                     the first day of the week) as a      
                     decimal number [00,53].  All days    
                     in a new year preceding the first    
                     Sunday are considered to be in week  
                     0.                                   
     `%w'            Weekday as a decimal number          
                     [0(Sunday),6].                       
     `%W'            Week number of the year (Monday as   (3)
                     the first day of the week) as a      
                     decimal number [00,53].  All days    
                     in a new year preceding the first    
                     Monday are considered to be in week  
                     0.                                   
     `%x'            Locale's appropriate date            
                     representation.                      
     `%X'            Locale's appropriate time            
                     representation.                      
     `%y'            Year without century as a decimal    
                     number [00,99].                      
     `%Y'            Year with century as a decimal       
                     number.                              
     `%Z'            Time zone name (no characters if no  
                     time zone exists).                   
     `%%'            A literal `'%'' character.           

     Notes:

       1. When used with the *note strptime(): 3ac. function, the `%p'
          directive only affects the output hour field if the `%I'
          directive is used to parse the hour.

       2. The range really is `0' to `61'; this accounts for leap
          seconds and the (very rare) double leap seconds.

       3. When used with the *note strptime(): 3ac. function, `%U' and
          `%W' are only used in calculations when the day of the week
          and the year are specified.

     Here is an example, a format for dates compatible with that
     specified  in the RFC 2822(1) Internet email standard.  (2)

         >>> from time import gmtime, strftime
         >>> strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
         'Thu, 28 Jun 2001 14:17:15 +0000'

     Additional directives may be supported on certain platforms, but
     only the ones listed here have a meaning standardized by ANSI C.

     On some platforms, an optional field width and precision
     specification can immediately follow the initial `'%'' of a
     directive in the following order; this is also not portable. The
     field width is normally 2 except for `%j' where it is 3.

 -- Function: time.strptime (string[, format])
     Parse a string representing a time according to a format.  The
     return  value is a *note struct_time: a9b. as returned by *note
     gmtime(): b0b. or *note localtime(): a9c.

     The _format_ parameter uses the same directives as those used by
     *note strftime(): 3ad.; it defaults to `"%a %b %d %H:%M:%S %Y"'
     which matches the formatting returned by *note ctime(): aa4. If
     _string_ cannot be parsed according to _format_, or if it has
     excess data after parsing, *note ValueError: 233. is raised.  The
     default values used to fill in any missing data when more accurate
     values cannot be inferred are `(1900, 1, 1, 0, 0, 0, 0, 1, -1)'.

     For example:

         >>> import time
         >>> time.strptime("30 Nov 00", "%d %b %y")   # doctest: +NORMALIZE_WHITESPACE
         time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0,
                          tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)

     Support for the `%Z' directive is based on the values contained in
     `tzname' and whether `daylight' is true.  Because of this, it is
     platform-specific except for recognizing UTC and GMT which are
     always known (and are considered to be non-daylight savings
     timezones).

     Only the directives specified in the documentation are supported.
     Because `strftime()' is implemented per platform it can sometimes
     offer more directives than those listed.  But `strptime()' is
     independent of any platform and thus does not necessarily support
     all directives available that are not documented as supported.

 -- Class: time.struct_time
     The type of the time value sequence returned by *note gmtime():
     b0b, *note localtime(): a9c, and *note strptime(): 3ac.  It is an
     object with a *note named tuple: 9e9. interface: values can be
     accessed by index and by attribute name.  The following values are
     present:

     Index       Attribute               Values
     -------------------------------------------------------------------------- 
     0           `tm_year'               (for example, 1993)
     1           `tm_mon'                range [1, 12]
     2           `tm_mday'               range [1, 31]
     3           `tm_hour'               range [0, 23]
     4           `tm_min'                range [0, 59]
     5           `tm_sec'                range [0, 61]; see *(1)* in *note
                                         strftime(): 3ad. description
     6           `tm_wday'               range [0, 6], Monday is 0
     7           `tm_yday'               range [1, 366]
     8           `tm_isdst'              0, 1 or -1; see below

     New in version 2.2.

     Note that unlike the C structure, the month value is a range of
     [1, 12], not [0, 11].  A year value will be handled as described
     under *note Year 2000 (Y2K) issues: 1197. above.  A `-1' argument
     as the daylight savings flag, passed to *note mktime(): 119a. will
     usually result in the correct daylight savings state to be filled
     in.

     When a tuple with an incorrect length is passed to a function
     expecting a *note struct_time: a9b, or having elements of the
     wrong type, a *note TypeError: 215. is raised.

 -- Function: time.time ()
     Return the time as a floating point number expressed in seconds
     since the epoch, in UTC.  Note that even though the time is always
     returned as a floating point number, not all systems provide time
     with a better precision than 1 second.  While this function
     normally returns non-decreasing values, it can return a lower
     value than a previous call if the system clock has been set back
     between the two calls.

 -- Data: time.timezone
     The offset of the local (non-DST) timezone, in seconds west of UTC
     (negative in most of Western Europe, positive in the US, zero in
     the UK).

 -- Data: time.tzname
     A tuple of two strings: the first is the name of the local non-DST
     timezone, the second is the name of the local DST timezone.  If no
     DST timezone is defined, the second string should not be used.

 -- Function: time.tzset ()
     Resets the time conversion rules used by the library routines. The
     environment variable `TZ' specifies how this is done.

     New in version 2.3.

     Availability: Unix.

          Note: Although in many cases, changing the `TZ' environment
          variable may affect the output of functions like *note
          localtime(): a9c. without calling *note tzset(): 11a1, this
          behavior should not be relied on.

          The `TZ' environment variable should contain no whitespace.

     The standard format of the `TZ' environment variable is (whitespace
     added for clarity):

         std offset [dst [offset [,start[/time], end[/time]]]]

     Where the components are:

    `std' and `dst'
          Three or more alphanumerics giving the timezone
          abbreviations. These will be propagated into time.tzname

    `offset'
          The offset has the form: ` hh[:mm[:ss]]'. This indicates
          the value added the local time to arrive at UTC.  If preceded
          by a '-', the timezone is east of the Prime Meridian;
          otherwise, it is west. If no offset follows dst, summer time
          is assumed to be one hour ahead of standard time.

    `start[/time], end[/time]'
          Indicates when to change to and back from DST. The format of
          the start and end dates are one of the following:

         `J_n_'
               The Julian day _n_ (1 <= _n_ <= 365). Leap days are not
               counted, so in all years February 28 is day 59 and March
               1 is day 60.

         `_n_'
               The zero-based Julian day (0 <= _n_ <= 365). Leap days
               are counted, and it is possible to refer to February 29.

         `M_m_._n_._d_'
               The _d_'th day (0 <= _d_ <= 6) or week _n_ of month _m_
               of the year (1 <= _n_ <= 5, 1 <= _m_ <= 12, where week 5
               means "the last _d_ day in month _m_" which may occur in
               either the fourth or the fifth week). Week 1 is the
               first week in which the _d_'th day occurs. Day zero is
               Sunday.

          `time' has the same format as `offset' except that no leading
          sign ('-' or '+') is allowed. The default, if time is not
          given, is 02:00:00.

         >>> os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
         >>> time.tzset()
         >>> time.strftime('%X %x %Z')
         '02:07:36 05/08/03 EDT'
         >>> os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
         >>> time.tzset()
         >>> time.strftime('%X %x %Z')
         '16:08:12 05/08/03 AEST'

     On many Unix systems (including *BSD, Linux, Solaris, and Darwin),
     it is more convenient to use the system's zoneinfo (`tzfile(5)')
     database to specify the timezone rules. To do this, set the `TZ'
     environment variable to the path of the required timezone
     datafile, relative to the root of the systems 'zoneinfo' timezone
     database, usually located at `/usr/share/zoneinfo'. For example,
     `'US/Eastern'', `'Australia/Melbourne'', `'Egypt'' or
     `'Europe/Amsterdam''.

         >>> os.environ['TZ'] = 'US/Eastern'
         >>> time.tzset()
         >>> time.tzname
         ('EST', 'EDT')
         >>> os.environ['TZ'] = 'Egypt'
         >>> time.tzset()
         >>> time.tzname
         ('EET', 'EEST')



See also
........

Module *note datetime: 7e.
     More object-oriented interface to dates and times.

Module *note locale: 101.
     Internationalization services.  The locale settings can affect the
     return values for some of  the functions in the *note time: 17b.
     module.

Module *note calendar: 1f.
     General calendar-related functions.   `timegm()' is the inverse of
     *note gmtime(): b0b. from this module.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html

  (2) The use of `%Z' is now deprecated, but the `%z' escape that
expands to the preferred  hour/minute offset is not supported by all
ANSI C libraries. Also, a strict reading of the original 1982 RFC 822
(http://tools.ietf.org/html/rfc822.html) standard calls for a two-digit
year (%y rather than %Y), but practice moved to 4-digit years long
before the year 2000.  The 4-digit year has been mandated by RFC 2822
(http://tools.ietf.org/html/rfc2822.html), which obsoletes RFC 822
(http://tools.ietf.org/html/rfc822.html).


File: python.info,  Node: argparse --- Parser for command-line options arguments and sub-commands,  Next: optparse --- Parser for command line options,  Prev: time --- Time access and conversions,  Up: Generic Operating System Services

5.15.4 `argparse' -- Parser for command-line options, arguments and sub-commands
--------------------------------------------------------------------------------

New in version 2.7.

  The *note argparse: d. module makes it easy to write user-friendly
command-line interfaces. The program defines what arguments it
requires, and *note argparse: d.  will figure out how to parse those
out of *note sys.argv: 60e.  The *note argparse: d.  module also
automatically generates help and usage messages and issues errors when
users give the program invalid arguments.

* Menu:

* Example: Example<5>.
* ArgumentParser objects::
* The add_argument() method: The add_argument method.
* The parse_args() method: The parse_args method.
* Other utilities::
* Upgrading optparse code::

Example

* Creating a parser::
* Adding arguments::
* Parsing arguments::

ArgumentParser objects

* description::
* epilog::
* add_help::
* prefix_chars::
* fromfile_prefix_chars::
* argument_default::
* parents::
* formatter_class::
* conflict_handler::
* prog::
* usage::

The add_argument() method

* name or flags::
* action::
* nargs::
* const::
* default::
* type::
* choices::
* required::
* help::
* metavar::
* dest::

The parse_args() method

* Option value syntax::
* Invalid arguments::
* Arguments containing "-"::
* Argument abbreviations::
* Beyond sys.argv: Beyond sys argv.
* The Namespace object::

Other utilities

* Sub-commands::
* FileType objects::
* Argument groups::
* Mutual exclusion::
* Parser defaults::
* Printing help::
* Partial parsing::
* Customizing file parsing::
* Exiting methods::


File: python.info,  Node: Example<5>,  Next: ArgumentParser objects,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.1 Example
................

The following code is a Python program that takes a list of integers and
produces either the sum or the max:

    import argparse

    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('integers', metavar='N', type=int, nargs='+',
                       help='an integer for the accumulator')
    parser.add_argument('--sum', dest='accumulate', action='store_const',
                       const=sum, default=max,
                       help='sum the integers (default: find the max)')

    args = parser.parse_args()
    print args.accumulate(args.integers)

Assuming the Python code above is saved into a file called `prog.py',
it can be run at the command line and provides useful help messages:

    $ prog.py -h
    usage: prog.py [-h] [--sum] N [N ...]

    Process some integers.

    positional arguments:
     N           an integer for the accumulator

    optional arguments:
     -h, --help  show this help message and exit
     --sum       sum the integers (default: find the max)

When run with the appropriate arguments, it prints either the sum or
the max of the command-line integers:

    $ prog.py 1 2 3 4
    4

    $ prog.py 1 2 3 4 --sum
    10

If invalid arguments are passed in, it will issue an error:

    $ prog.py a b c
    usage: prog.py [-h] [--sum] N [N ...]
    prog.py: error: argument N: invalid int value: 'a'

The following sections walk you through this example.

* Menu:

* Creating a parser::
* Adding arguments::
* Parsing arguments::


File: python.info,  Node: Creating a parser,  Next: Adding arguments,  Up: Example<5>

5.15.4.2 Creating a parser
..........................

The first step in using the *note argparse: d. is creating an *note
ArgumentParser: 11a6. object:

    >>> parser = argparse.ArgumentParser(description='Process some integers.')

The *note ArgumentParser: 11a6. object will hold all the information
necessary to parse the command line into Python data types.


File: python.info,  Node: Adding arguments,  Next: Parsing arguments,  Prev: Creating a parser,  Up: Example<5>

5.15.4.3 Adding arguments
.........................

Filling an *note ArgumentParser: 11a6. with information about program
arguments is done by making calls to the *note add_argument(): 11a8.
method.  Generally, these calls tell the *note ArgumentParser: 11a6.
how to take the strings on the command line and turn them into objects.
This information is stored and used when *note parse_args(): 11a9. is
called. For example:

    >>> parser.add_argument('integers', metavar='N', type=int, nargs='+',
    ...                     help='an integer for the accumulator')
    >>> parser.add_argument('--sum', dest='accumulate', action='store_const',
    ...                     const=sum, default=max,
    ...                     help='sum the integers (default: find the max)')

Later, calling *note parse_args(): 11a9. will return an object with two
attributes, `integers' and `accumulate'.  The `integers' attribute will
be a list of one or more ints, and the `accumulate' attribute will be
either the *note sum(): 415. function, if `--sum' was specified at the
command line, or the *note max(): 222. function if it was not.


File: python.info,  Node: Parsing arguments,  Prev: Adding arguments,  Up: Example<5>

5.15.4.4 Parsing arguments
..........................

*note ArgumentParser: 11a6. parses args through the *note parse_args():
11a9. method.  This will inspect the command line, convert each arg to
the appropriate type and then invoke the appropriate action.  In most
cases, this means a simple namespace object will be built up from
attributes parsed out of the command line:

    >>> parser.parse_args(['--sum', '7', '-1', '42'])
    Namespace(accumulate=<built-in function sum>, integers=[7, -1, 42])

In a script, *note parse_args(): 11a9. will typically be called with no
arguments, and the *note ArgumentParser: 11a6. will automatically
determine the command-line args from *note sys.argv: 60e.


File: python.info,  Node: ArgumentParser objects,  Next: The add_argument method,  Prev: Example<5>,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.5 ArgumentParser objects
...............................

 -- Class: argparse.ArgumentParser ([description][, epilog][, prog][,
          usage][, add_help][, argument_default][, parents][,
          prefix_chars][, conflict_handler][, formatter_class])
     Create a new *note ArgumentParser: 11a6. object.  Each parameter
     has its own more detailed description below, but in short they are:

        * *note description: 11ac. - Text to display before the
          argument help.

        * *note epilog: 11ad. - Text to display after the argument help.

        * *note add_help: 11ae. - Add a -h/-help option to the parser.
          (default: `True')

        * *note argument_default: 11af. - Set the global default value
          for arguments.  (default: `None')

        * *note parents: 11b0. - A list of *note ArgumentParser: 11a6.
          objects whose arguments should also be included.

        * *note prefix_chars: 11b1. - The set of characters that prefix
          optional arguments.  (default: '-')

        * *note fromfile_prefix_chars: 11b2. - The set of characters
          that prefix files from which additional arguments should be
          read. (default: `None')

        * *note formatter_class: 11b3. - A class for customizing the
          help output.

        * *note conflict_handler: 11b4. - Usually unnecessary, defines
          strategy for resolving conflicting optionals.

        * *note prog: 11b5. - The name of the program (default:
          `sys.argv[0]')

        * *note usage: 11b6. - The string describing the program usage
          (default: generated)

The following sections describe how each of these are used.

* Menu:

* description::
* epilog::
* add_help::
* prefix_chars::
* fromfile_prefix_chars::
* argument_default::
* parents::
* formatter_class::
* conflict_handler::
* prog::
* usage::


File: python.info,  Node: description,  Next: epilog,  Up: ArgumentParser objects

5.15.4.6 description
....................

Most calls to the *note ArgumentParser: 11a6. constructor will use the
`description=' keyword argument.  This argument gives a brief
description of what the program does and how it works.  In help
messages, the description is displayed between the command-line usage
string and the help messages for the various arguments:

    >>> parser = argparse.ArgumentParser(description='A foo that bars')
    >>> parser.print_help()
    usage: argparse.py [-h]

    A foo that bars

    optional arguments:
     -h, --help  show this help message and exit

By default, the description will be line-wrapped so that it fits within
the given space.  To change this behavior, see the *note
formatter_class: 11b3. argument.


File: python.info,  Node: epilog,  Next: add_help,  Prev: description,  Up: ArgumentParser objects

5.15.4.7 epilog
...............

Some programs like to display additional description of the program
after the description of the arguments.  Such text can be specified
using the `epilog=' argument to *note ArgumentParser: 11a6.:

    >>> parser = argparse.ArgumentParser(
    ...     description='A foo that bars',
    ...     epilog="And that's how you'd foo a bar")
    >>> parser.print_help()
    usage: argparse.py [-h]

    A foo that bars

    optional arguments:
     -h, --help  show this help message and exit

    And that's how you'd foo a bar

As with the *note description: 11ac. argument, the `epilog=' text is by
default line-wrapped, but this behavior can be adjusted with the *note
formatter_class: 11b3.  argument to *note ArgumentParser: 11a6.


File: python.info,  Node: add_help,  Next: prefix_chars,  Prev: epilog,  Up: ArgumentParser objects

5.15.4.8 add_help
.................

By default, ArgumentParser objects add an option which simply displays
the parser's help message. For example, consider a file named
`myprogram.py' containing the following code:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--foo', help='foo help')
    args = parser.parse_args()

If `-h' or `--help' is supplied at the command line, the ArgumentParser
help will be printed:

    $ python myprogram.py --help
    usage: myprogram.py [-h] [--foo FOO]

    optional arguments:
     -h, --help  show this help message and exit
     --foo FOO   foo help

Occasionally, it may be useful to disable the addition of this help
option.  This can be achieved by passing `False' as the `add_help='
argument to *note ArgumentParser: 11a6.:

    >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
    >>> parser.add_argument('--foo', help='foo help')
    >>> parser.print_help()
    usage: PROG [--foo FOO]

    optional arguments:
     --foo FOO  foo help

The help option is typically `-h/--help'. The exception to this is if
the `prefix_chars=' is specified and does not include `'-'', in which
case `-h' and `--help' are not valid options.  In this case, the first
character in `prefix_chars' is used to prefix the help options:

    >>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')
    >>> parser.print_help()
    usage: PROG [+h]

    optional arguments:
      +h, ++help  show this help message and exit



File: python.info,  Node: prefix_chars,  Next: fromfile_prefix_chars,  Prev: add_help,  Up: ArgumentParser objects

5.15.4.9 prefix_chars
.....................

Most command-line options will use `'-'' as the prefix, e.g. `-f/--foo'.
Parsers that need to support different or additional prefix characters,
e.g. for options like `+f' or `/foo', may specify them using the
`prefix_chars=' argument to the ArgumentParser constructor:

    >>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')
    >>> parser.add_argument('+f')
    >>> parser.add_argument('++bar')
    >>> parser.parse_args('+f X ++bar Y'.split())
    Namespace(bar='Y', f='X')

The `prefix_chars=' argument defaults to `'-''. Supplying a set of
characters that does not include `'-'' will cause `-f/--foo' options to
be disallowed.


File: python.info,  Node: fromfile_prefix_chars,  Next: argument_default,  Prev: prefix_chars,  Up: ArgumentParser objects

5.15.4.10 fromfile_prefix_chars
...............................

Sometimes, for example when dealing with a particularly long argument
lists, it may make sense to keep the list of arguments in a file rather
than typing it out at the command line.  If the
`fromfile_prefix_chars=' argument is given to the *note ArgumentParser:
11a6. constructor, then arguments that start with any of the specified
characters will be treated as files, and will be replaced by the
arguments they contain.  For example:

    >>> with open('args.txt', 'w') as fp:
    ...    fp.write('-f\nbar')
    >>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
    >>> parser.add_argument('-f')
    >>> parser.parse_args(['-f', 'foo', '@args.txt'])
    Namespace(f='bar')

Arguments read from a file must by default be one per line (but see also
*note convert_arg_line_to_args(): 11b7.) and are treated as if they
were in the same place as the original file referencing argument on the
command line.  So in the example above, the expression `['-f', 'foo',
'@args.txt']' is considered equivalent to the expression `['-f', 'foo',
'-f', 'bar']'.

  The `fromfile_prefix_chars=' argument defaults to `None', meaning that
arguments will never be treated as file references.


File: python.info,  Node: argument_default,  Next: parents,  Prev: fromfile_prefix_chars,  Up: ArgumentParser objects

5.15.4.11 argument_default
..........................

Generally, argument defaults are specified either by passing a default
to *note add_argument(): 11a8. or by calling the *note set_defaults():
11b8. methods with a specific set of name-value pairs.  Sometimes
however, it may be useful to specify a single parser-wide default for
arguments.  This can be accomplished by passing the `argument_default='
keyword argument to *note ArgumentParser: 11a6.  For example, to
globally suppress attribute creation on *note parse_args(): 11a9.
calls, we supply `argument_default=SUPPRESS':

    >>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
    >>> parser.add_argument('--foo')
    >>> parser.add_argument('bar', nargs='?')
    >>> parser.parse_args(['--foo', '1', 'BAR'])
    Namespace(bar='BAR', foo='1')
    >>> parser.parse_args([])
    Namespace()



File: python.info,  Node: parents,  Next: formatter_class,  Prev: argument_default,  Up: ArgumentParser objects

5.15.4.12 parents
.................

Sometimes, several parsers share a common set of arguments. Rather than
repeating the definitions of these arguments, a single parser with all
the shared arguments and passed to `parents=' argument to *note
ArgumentParser: 11a6.  can be used.  The `parents=' argument takes a
list of *note ArgumentParser: 11a6.  objects, collects all the
positional and optional actions from them, and adds these actions to
the *note ArgumentParser: 11a6. object being constructed:

    >>> parent_parser = argparse.ArgumentParser(add_help=False)
    >>> parent_parser.add_argument('--parent', type=int)

    >>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])
    >>> foo_parser.add_argument('foo')
    >>> foo_parser.parse_args(['--parent', '2', 'XXX'])
    Namespace(foo='XXX', parent=2)

    >>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])
    >>> bar_parser.add_argument('--bar')
    >>> bar_parser.parse_args(['--bar', 'YYY'])
    Namespace(bar='YYY', parent=None)

Note that most parent parsers will specify `add_help=False'.
Otherwise, the *note ArgumentParser: 11a6. will see two `-h/--help'
options (one in the parent and one in the child) and raise an error.

     Note: You must fully initialize the parsers before passing them
     via `parents='.  If you change the parent parsers after the child
     parser, those changes will not be reflected in the child.


File: python.info,  Node: formatter_class,  Next: conflict_handler,  Prev: parents,  Up: ArgumentParser objects

5.15.4.13 formatter_class
.........................

*note ArgumentParser: 11a6. objects allow the help formatting to be
customized by specifying an alternate formatting class.  Currently,
there are three such classes:

 -- Class: argparse.RawDescriptionHelpFormatter
 -- Class: argparse.RawTextHelpFormatter
 -- Class: argparse.ArgumentDefaultsHelpFormatter

  The first two allow more control over how textual descriptions are
displayed, while the last automatically adds information about argument
default values.

  By default, *note ArgumentParser: 11a6. objects line-wrap the *note
description: 11ac. and *note epilog: 11ad. texts in command-line help
messages:

    >>> parser = argparse.ArgumentParser(
    ...     prog='PROG',
    ...     description='''this description
    ...         was indented weird
    ...             but that is okay''',
    ...     epilog='''
    ...             likewise for this epilog whose whitespace will
    ...         be cleaned up and whose words will be wrapped
    ...         across a couple lines''')
    >>> parser.print_help()
    usage: PROG [-h]

    this description was indented weird but that is okay

    optional arguments:
     -h, --help  show this help message and exit

    likewise for this epilog whose whitespace will be cleaned up and whose words
    will be wrapped across a couple lines

Passing *note RawDescriptionHelpFormatter: 11b9. as `formatter_class='
indicates that *note description: 11ac. and *note epilog: 11ad. are
already correctly formatted and should not be line-wrapped:

    >>> parser = argparse.ArgumentParser(
    ...     prog='PROG',
    ...     formatter_class=argparse.RawDescriptionHelpFormatter,
    ...     description=textwrap.dedent('''\
    ...         Please do not mess up this text!
    ...         --------------------------------
    ...             I have indented it
    ...             exactly the way
    ...             I want it
    ...         '''))
    >>> parser.print_help()
    usage: PROG [-h]

    Please do not mess up this text!
    --------------------------------
       I have indented it
       exactly the way
       I want it

    optional arguments:
     -h, --help  show this help message and exit

*note RawTextHelpFormatter: 11ba. maintains whitespace for all sorts of
help text including argument descriptions.

  The other formatter class available, *note
ArgumentDefaultsHelpFormatter: 11bb, will add information about the
default value of each of the arguments:

    >>> parser = argparse.ArgumentParser(
    ...     prog='PROG',
    ...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    >>> parser.add_argument('--foo', type=int, default=42, help='FOO!')
    >>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')
    >>> parser.print_help()
    usage: PROG [-h] [--foo FOO] [bar [bar ...]]

    positional arguments:
     bar         BAR! (default: [1, 2, 3])

    optional arguments:
     -h, --help  show this help message and exit
     --foo FOO   FOO! (default: 42)



File: python.info,  Node: conflict_handler,  Next: prog,  Prev: formatter_class,  Up: ArgumentParser objects

5.15.4.14 conflict_handler
..........................

*note ArgumentParser: 11a6. objects do not allow two actions with the
same option string.  By default, *note ArgumentParser: 11a6. objects
raises an exception if an attempt is made to create an argument with an
option string that is already in use:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-f', '--foo', help='old foo help')
    >>> parser.add_argument('--foo', help='new foo help')
    Traceback (most recent call last):
     ..
    ArgumentError: argument --foo: conflicting option string(s): --foo

Sometimes (e.g. when using *note parents: 11b0.) it may be useful to
simply override any older arguments with the same option string.  To
get this behavior, the value `'resolve'' can be supplied to the
`conflict_handler=' argument of *note ArgumentParser: 11a6.:

    >>> parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')
    >>> parser.add_argument('-f', '--foo', help='old foo help')
    >>> parser.add_argument('--foo', help='new foo help')
    >>> parser.print_help()
    usage: PROG [-h] [-f FOO] [--foo FOO]

    optional arguments:
     -h, --help  show this help message and exit
     -f FOO      old foo help
     --foo FOO   new foo help

Note that *note ArgumentParser: 11a6. objects only remove an action if
all of its option strings are overridden.  So, in the example above,
the old `-f/--foo' action is retained as the `-f' action, because only
the `--foo' option string was overridden.


File: python.info,  Node: prog,  Next: usage,  Prev: conflict_handler,  Up: ArgumentParser objects

5.15.4.15 prog
..............

By default, *note ArgumentParser: 11a6. objects uses `sys.argv[0]' to
determine how to display the name of the program in help messages.
This default is almost always desirable because it will make the help
messages match how the program was invoked on the command line.  For
example, consider a file named `myprogram.py' with the following code:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--foo', help='foo help')
    args = parser.parse_args()

The help for this program will display `myprogram.py' as the program
name (regardless of where the program was invoked from):

    $ python myprogram.py --help
    usage: myprogram.py [-h] [--foo FOO]

    optional arguments:
     -h, --help  show this help message and exit
     --foo FOO   foo help
    $ cd ..
    $ python subdir\myprogram.py --help
    usage: myprogram.py [-h] [--foo FOO]

    optional arguments:
     -h, --help  show this help message and exit
     --foo FOO   foo help

To change this default behavior, another value can be supplied using the
`prog=' argument to *note ArgumentParser: 11a6.:

    >>> parser = argparse.ArgumentParser(prog='myprogram')
    >>> parser.print_help()
    usage: myprogram [-h]

    optional arguments:
     -h, --help  show this help message and exit

Note that the program name, whether determined from `sys.argv[0]' or
from the `prog=' argument, is available to help messages using the
`%(prog)s' format specifier.

    >>> parser = argparse.ArgumentParser(prog='myprogram')
    >>> parser.add_argument('--foo', help='foo of the %(prog)s program')
    >>> parser.print_help()
    usage: myprogram [-h] [--foo FOO]

    optional arguments:
     -h, --help  show this help message and exit
     --foo FOO   foo of the myprogram program



File: python.info,  Node: usage,  Prev: prog,  Up: ArgumentParser objects

5.15.4.16 usage
...............

By default, *note ArgumentParser: 11a6. calculates the usage message
from the arguments it contains:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('--foo', nargs='?', help='foo help')
    >>> parser.add_argument('bar', nargs='+', help='bar help')
    >>> parser.print_help()
    usage: PROG [-h] [--foo [FOO]] bar [bar ...]

    positional arguments:
     bar          bar help

    optional arguments:
     -h, --help   show this help message and exit
     --foo [FOO]  foo help

The default message can be overridden with the `usage=' keyword
argument:

    >>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')
    >>> parser.add_argument('--foo', nargs='?', help='foo help')
    >>> parser.add_argument('bar', nargs='+', help='bar help')
    >>> parser.print_help()
    usage: PROG [options]

    positional arguments:
     bar          bar help

    optional arguments:
     -h, --help   show this help message and exit
     --foo [FOO]  foo help

The `%(prog)s' format specifier is available to fill in the program
name in your usage messages.


File: python.info,  Node: The add_argument method,  Next: The parse_args method,  Prev: ArgumentParser objects,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.17 The add_argument() method
...................................

 -- Method: ArgumentParser.add_argument (name or flags...[, action][,
          nargs][, const][, default][, type][, choices][, required][,
          help][, metavar][, dest])
     Define how a single command-line argument should be parsed.  Each
     parameter has its own more detailed description below, but in
     short they are:

        * *note name or flags: 11bd. - Either a name or a list of
          option strings, e.g. `foo' or `-f, --foo'.

        * *note action: 11be. - The basic type of action to be taken
          when this argument is encountered at the command line.

        * *note nargs: 11bf. - The number of command-line arguments
          that should be consumed.

        * *note const: 11c0. - A constant value required by some *note
          action: 11be. and *note nargs: 11bf. selections.

        * *note default: 11c1. - The value produced if the argument is
          absent from the command line.

        * *note type: 11c2. - The type to which the command-line
          argument should be converted.

        * *note choices: 11c3. - A container of the allowable values
          for the argument.

        * *note required: 11c4. - Whether or not the command-line
          option may be omitted (optionals only).

        * *note help: 11c5. - A brief description of what the argument
          does.

        * *note metavar: 11c6. - A name for the argument in usage
          messages.

        * *note dest: 11c7. - The name of the attribute to be added to
          the object returned by *note parse_args(): 11a9.

The following sections describe how each of these are used.

* Menu:

* name or flags::
* action::
* nargs::
* const::
* default::
* type::
* choices::
* required::
* help::
* metavar::
* dest::


File: python.info,  Node: name or flags,  Next: action,  Up: The add_argument method

5.15.4.18 name or flags
.......................

The *note add_argument(): 11a8. method must know whether an optional
argument, like `-f' or `--foo', or a positional argument, like a list of
filenames, is expected.  The first arguments passed to *note
add_argument(): 11a8. must therefore be either a series of flags, or a
simple argument name.  For example, an optional argument could be
created like:

    >>> parser.add_argument('-f', '--foo')

while a positional argument could be created like:

    >>> parser.add_argument('bar')

When *note parse_args(): 11a9. is called, optional arguments will be
identified by the `-' prefix, and the remaining arguments will be
assumed to be positional:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-f', '--foo')
    >>> parser.add_argument('bar')
    >>> parser.parse_args(['BAR'])
    Namespace(bar='BAR', foo=None)
    >>> parser.parse_args(['BAR', '--foo', 'FOO'])
    Namespace(bar='BAR', foo='FOO')
    >>> parser.parse_args(['--foo', 'FOO'])
    usage: PROG [-h] [-f FOO] bar
    PROG: error: too few arguments



File: python.info,  Node: action,  Next: nargs,  Prev: name or flags,  Up: The add_argument method

5.15.4.19 action
................

*note ArgumentParser: 11a6. objects associate command-line args with
actions.  These actions can do just about anything with the
command-line args associated with them, though most actions simply add
an attribute to the object returned by *note parse_args(): 11a9.  The
`action' keyword argument specifies how the command-line args should be
handled. The supported actions are:

   * `'store'' - This just stores the argument's value.  This is the
     default action. For example:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo')
         >>> parser.parse_args('--foo 1'.split())
         Namespace(foo='1')


   * `'store_const'' - This stores the value specified by the *note
     const: 11c0. keyword argument.  (Note that the *note const: 11c0.
     keyword argument defaults to the rather unhelpful `None'.)  The
     `'store_const'' action is most commonly used with optional
     arguments that specify some sort of flag.  For example:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', action='store_const', const=42)
         >>> parser.parse_args('--foo'.split())
         Namespace(foo=42)


   * `'store_true'' and `'store_false'' - These store the values `True'
     and `False' respectively.  These are special cases of
     `'store_const''.  For example:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', action='store_true')
         >>> parser.add_argument('--bar', action='store_false')
         >>> parser.parse_args('--foo --bar'.split())
         Namespace(bar=False, foo=True)


   * `'append'' - This stores a list, and appends each argument value
     to the list.  This is useful to allow an option to be specified
     multiple times.  Example usage:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', action='append')
         >>> parser.parse_args('--foo 1 --foo 2'.split())
         Namespace(foo=['1', '2'])


   * `'append_const'' - This stores a list, and appends the value
     specified by the *note const: 11c0. keyword argument to the list.
     (Note that the *note const: 11c0. keyword argument defaults to
     `None'.)  The `'append_const'' action is typically useful when
     multiple arguments need to store constants to the same list. For
     example:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--str', dest='types', action='append_const', const=str)
         >>> parser.add_argument('--int', dest='types', action='append_const', const=int)
         >>> parser.parse_args('--str --int'.split())
         Namespace(types=[<type 'str'>, <type 'int'>])


   * `'version'' - This expects a `version=' keyword argument in the
     *note add_argument(): 11a8. call, and prints version information
     and exits when invoked.

         >>> import argparse
         >>> parser = argparse.ArgumentParser(prog='PROG')
         >>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')
         >>> parser.parse_args(['--version'])
         PROG 2.0



  You can also specify an arbitrary action by passing an object that
implements the Action API.  The easiest way to do this is to extend
`argparse.Action', supplying an appropriate `__call__' method.  The
`__call__' method should accept four parameters:

   * `parser' - The ArgumentParser object which contains this action.

   * `namespace' - The namespace object that will be returned by *note
     parse_args(): 11a9.  Most actions add an attribute to this object.

   * `values' - The associated command-line args, with any
     type-conversions applied.  (Type-conversions are specified with
     the *note type: 11c2. keyword argument to *note add_argument():
     11a8.

   * `option_string' - The option string that was used to invoke this
     action.  The `option_string' argument is optional, and will be
     absent if the action is associated with a positional argument.

  An example of a custom action:

    >>> class FooAction(argparse.Action):
    ...     def __call__(self, parser, namespace, values, option_string=None):
    ...         print '%r %r %r' % (namespace, values, option_string)
    ...         setattr(namespace, self.dest, values)
    ...
    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', action=FooAction)
    >>> parser.add_argument('bar', action=FooAction)
    >>> args = parser.parse_args('1 --foo 2'.split())
    Namespace(bar=None, foo=None) '1' None
    Namespace(bar='1', foo=None) '2' '--foo'
    >>> args
    Namespace(bar='1', foo='2')



File: python.info,  Node: nargs,  Next: const,  Prev: action,  Up: The add_argument method

5.15.4.20 nargs
...............

ArgumentParser objects usually associate a single command-line argument
with a single action to be taken.  The `nargs' keyword argument
associates a different number of command-line arguments with a single
action.  The supported values are:

   * N (an integer).  N args from the command line will be gathered
     together into a list.  For example:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', nargs=2)
         >>> parser.add_argument('bar', nargs=1)
         >>> parser.parse_args('c --foo a b'.split())
         Namespace(bar=['c'], foo=['a', 'b'])

     Note that `nargs=1' produces a list of one item.  This is
     different from the default, in which the item is produced by
     itself.

   * `'?''. One arg will be consumed from the command line if possible,
     and produced as a single item.  If no command-line arg is present,
     the value from *note default: 11c1. will be produced.  Note that
     for optional arguments, there is an additional case - the option
     string is present but not followed by a command-line arg.  In this
     case the value from *note const: 11c0. will be produced.  Some
     examples to illustrate this:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', nargs='?', const='c', default='d')
         >>> parser.add_argument('bar', nargs='?', default='d')
         >>> parser.parse_args('XX --foo YY'.split())
         Namespace(bar='XX', foo='YY')
         >>> parser.parse_args('XX --foo'.split())
         Namespace(bar='XX', foo='c')
         >>> parser.parse_args(''.split())
         Namespace(bar='d', foo='d')

     One of the more common uses of `nargs='?'' is to allow optional
     input and output files:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
         ...                     default=sys.stdin)
         >>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),
         ...                     default=sys.stdout)
         >>> parser.parse_args(['input.txt', 'output.txt'])
         Namespace(infile=<open file 'input.txt', mode 'r' at 0x...>,
                   outfile=<open file 'output.txt', mode 'w' at 0x...>)
         >>> parser.parse_args([])
         Namespace(infile=<open file '<stdin>', mode 'r' at 0x...>,
                   outfile=<open file '<stdout>', mode 'w' at 0x...>)


   * `'*''.  All command-line args present are gathered into a list.
     Note that it generally doesn't make much sense to have more than
     one positional argument with `nargs='*'', but multiple optional
     arguments with `nargs='*'' is possible.  For example:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', nargs='*')
         >>> parser.add_argument('--bar', nargs='*')
         >>> parser.add_argument('baz', nargs='*')
         >>> parser.parse_args('a b --foo x y --bar 1 2'.split())
         Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])


   * `'+''. Just like `'*'', all command-line args present are gathered
     into a list.  Additionally, an error message will be generated if
     there wasn't at least one command-line arg present.  For example:

         >>> parser = argparse.ArgumentParser(prog='PROG')
         >>> parser.add_argument('foo', nargs='+')
         >>> parser.parse_args('a b'.split())
         Namespace(foo=['a', 'b'])
         >>> parser.parse_args(''.split())
         usage: PROG [-h] foo [foo ...]
         PROG: error: too few arguments



  If the `nargs' keyword argument is not provided, the number of args
consumed is determined by the *note action: 11be.  Generally this means
a single command-line arg will be consumed and a single item (not a
list) will be produced.


File: python.info,  Node: const,  Next: default,  Prev: nargs,  Up: The add_argument method

5.15.4.21 const
...............

The `const' argument of *note add_argument(): 11a8. is used to hold
constant values that are not read from the command line but are
required for the various *note ArgumentParser: 11a6. actions.  The two
most common uses of it are:

   * When *note add_argument(): 11a8. is called with
     `action='store_const'' or `action='append_const''.  These actions
     add the `const' value to one of the attributes of the object
     returned by *note parse_args(): 11a9. See the *note action: 11be.
     description for examples.

   * When *note add_argument(): 11a8. is called with option strings
     (like `-f' or `--foo') and `nargs='?''.  This creates an optional
     argument that can be followed by zero or one command-line args.
     When parsing the command line, if the option string is encountered
     with no command-line arg following it, the value of `const' will
     be assumed instead.  See the *note nargs: 11bf. description for
     examples.

  The `const' keyword argument defaults to `None'.


File: python.info,  Node: default,  Next: type,  Prev: const,  Up: The add_argument method

5.15.4.22 default
.................

All optional arguments and some positional arguments may be omitted at
the command line.  The `default' keyword argument of *note
add_argument(): 11a8, whose value defaults to `None', specifies what
value should be used if the command-line arg is not present.  For
optional arguments, the `default' value is used when the option string
was not present at the command line:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', default=42)
    >>> parser.parse_args('--foo 2'.split())
    Namespace(foo='2')
    >>> parser.parse_args(''.split())
    Namespace(foo=42)

For positional arguments with *note nargs: 11bf. `='?'' or `'*'', the
`default' value is used when no command-line arg was present:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('foo', nargs='?', default=42)
    >>> parser.parse_args('a'.split())
    Namespace(foo='a')
    >>> parser.parse_args(''.split())
    Namespace(foo=42)

Providing `default=argparse.SUPPRESS' causes no attribute to be added
if the command-line argument was not present.:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', default=argparse.SUPPRESS)
    >>> parser.parse_args([])
    Namespace()
    >>> parser.parse_args(['--foo', '1'])
    Namespace(foo='1')



File: python.info,  Node: type,  Next: choices,  Prev: default,  Up: The add_argument method

5.15.4.23 type
..............

By default, ArgumentParser objects read command-line args in as simple
strings.  However, quite often the command-line string should instead
be interpreted as another type, like a *note float: 1e8, *note int:
1ef. or *note file: 1f6.  The `type' keyword argument of *note
add_argument(): 11a8. allows any necessary type-checking and
type-conversions to be performed.  Many common built-in types can be
used directly as the value of the `type' argument:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('foo', type=int)
    >>> parser.add_argument('bar', type=file)
    >>> parser.parse_args('2 temp.txt'.split())
    Namespace(bar=<open file 'temp.txt', mode 'r' at 0x...>, foo=2)

To ease the use of various types of files, the argparse module provides
the factory FileType which takes the `mode=' and `bufsize=' arguments
of the `file' object.  For example, `FileType('w')' can be used to
create a writable file:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('bar', type=argparse.FileType('w'))
    >>> parser.parse_args(['out.txt'])
    Namespace(bar=<open file 'out.txt', mode 'w' at 0x...>)

`type=' can take any callable that takes a single string argument and
returns the type-converted value:

    >>> def perfect_square(string):
    ...     value = int(string)
    ...     sqrt = math.sqrt(value)
    ...     if sqrt != int(sqrt):
    ...         msg = "%r is not a perfect square" % string
    ...         raise argparse.ArgumentTypeError(msg)
    ...     return value
    ...
    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('foo', type=perfect_square)
    >>> parser.parse_args('9'.split())
    Namespace(foo=9)
    >>> parser.parse_args('7'.split())
    usage: PROG [-h] foo
    PROG: error: argument foo: '7' is not a perfect square

The *note choices: 11c3. keyword argument may be more convenient for
type checkers that simply check against a range of values:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('foo', type=int, choices=xrange(5, 10))
    >>> parser.parse_args('7'.split())
    Namespace(foo=7)
    >>> parser.parse_args('11'.split())
    usage: PROG [-h] {5,6,7,8,9}
    PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)

See the *note choices: 11c3. section for more details.


File: python.info,  Node: choices,  Next: required,  Prev: type,  Up: The add_argument method

5.15.4.24 choices
.................

Some command-line args should be selected from a restricted set of
values.  These can be handled by passing a container object as the
`choices' keyword argument to *note add_argument(): 11a8.  When the
command line is parsed, arg values will be checked, and an error
message will be displayed if the arg was not one of the acceptable
values:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('foo', choices='abc')
    >>> parser.parse_args('c'.split())
    Namespace(foo='c')
    >>> parser.parse_args('X'.split())
    usage: PROG [-h] {a,b,c}
    PROG: error: argument foo: invalid choice: 'X' (choose from 'a', 'b', 'c')

Note that inclusion in the `choices' container is checked after any
*note type: 11c2.  conversions have been performed, so the type of the
objects in the `choices' container should match the *note type: 11c2.
specified:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('foo', type=complex, choices=[1, 1j])
    >>> parser.parse_args('1j'.split())
    Namespace(foo=1j)
    >>> parser.parse_args('-- -4'.split())
    usage: PROG [-h] {1,1j}
    PROG: error: argument foo: invalid choice: (-4+0j) (choose from 1, 1j)

Any object that supports the `in' operator can be passed as the
`choices' value, so *note dict: 2f6. objects, *note set: 359. objects,
custom containers, etc. are all supported.


File: python.info,  Node: required,  Next: help,  Prev: choices,  Up: The add_argument method

5.15.4.25 required
..................

In general, the *note argparse: d. module assumes that flags like `-f'
and `--bar' indicate _optional_ arguments, which can always be omitted
at the command line.  To make an option _required_, `True' can be
specified for the `required=' keyword argument to *note add_argument():
11a8.:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', required=True)
    >>> parser.parse_args(['--foo', 'BAR'])
    Namespace(foo='BAR')
    >>> parser.parse_args([])
    usage: argparse.py [-h] [--foo FOO]
    argparse.py: error: option --foo is required

As the example shows, if an option is marked as `required', *note
parse_args(): 11a9. will report an error if that option is not present
at the command line.

     Note: Required options are generally considered bad form because
     users expect _options_ to be _optional_, and thus they should be
     avoided when possible.


File: python.info,  Node: help,  Next: metavar,  Prev: required,  Up: The add_argument method

5.15.4.26 help
..............

The `help' value is a string containing a brief description of the
argument.  When a user requests help (usually by using `-h' or `--help'
at the command line), these `help' descriptions will be displayed with
each argument:

    >>> parser = argparse.ArgumentParser(prog='frobble')
    >>> parser.add_argument('--foo', action='store_true',
    ...         help='foo the bars before frobbling')
    >>> parser.add_argument('bar', nargs='+',
    ...         help='one of the bars to be frobbled')
    >>> parser.parse_args('-h'.split())
    usage: frobble [-h] [--foo] bar [bar ...]

    positional arguments:
     bar     one of the bars to be frobbled

    optional arguments:
     -h, --help  show this help message and exit
     --foo   foo the bars before frobbling

The `help' strings can include various format specifiers to avoid
repetition of things like the program name or the argument *note
default: 11c1.  The available specifiers include the program name,
`%(prog)s' and most keyword arguments to *note add_argument(): 11a8,
e.g. `%(default)s', `%(type)s', etc.:

    >>> parser = argparse.ArgumentParser(prog='frobble')
    >>> parser.add_argument('bar', nargs='?', type=int, default=42,
    ...         help='the bar to %(prog)s (default: %(default)s)')
    >>> parser.print_help()
    usage: frobble [-h] [bar]

    positional arguments:
     bar     the bar to frobble (default: 42)

    optional arguments:
     -h, --help  show this help message and exit



File: python.info,  Node: metavar,  Next: dest,  Prev: help,  Up: The add_argument method

5.15.4.27 metavar
.................

When *note ArgumentParser: 11a6. generates help messages, it need some
way to refer to each expected argument.  By default, ArgumentParser
objects use the *note dest: 11c7.  value as the "name" of each object.
By default, for positional argument actions, the *note dest: 11c7.
value is used directly, and for optional argument actions, the *note
dest: 11c7. value is uppercased.  So, a single positional argument with
`dest='bar'' will that argument will be referred to as `bar'. A single
optional argument `--foo' that should be followed by a single
command-line arg will be referred to as `FOO'.  An example:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo')
    >>> parser.add_argument('bar')
    >>> parser.parse_args('X --foo Y'.split())
    Namespace(bar='X', foo='Y')
    >>> parser.print_help()
    usage:  [-h] [--foo FOO] bar

    positional arguments:
     bar

    optional arguments:
     -h, --help  show this help message and exit
     --foo FOO

An alternative name can be specified with `metavar':

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', metavar='YYY')
    >>> parser.add_argument('bar', metavar='XXX')
    >>> parser.parse_args('X --foo Y'.split())
    Namespace(bar='X', foo='Y')
    >>> parser.print_help()
    usage:  [-h] [--foo YYY] XXX

    positional arguments:
     XXX

    optional arguments:
     -h, --help  show this help message and exit
     --foo YYY

Note that `metavar' only changes the _displayed_ name - the name of the
attribute on the *note parse_args(): 11a9. object is still determined
by the *note dest: 11c7. value.

  Different values of `nargs' may cause the metavar to be used multiple
times.  Providing a tuple to `metavar' specifies a different display
for each of the arguments:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-x', nargs=2)
    >>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))
    >>> parser.print_help()
    usage: PROG [-h] [-x X X] [--foo bar baz]

    optional arguments:
     -h, --help     show this help message and exit
     -x X X
     --foo bar baz



File: python.info,  Node: dest,  Prev: metavar,  Up: The add_argument method

5.15.4.28 dest
..............

Most *note ArgumentParser: 11a6. actions add some value as an attribute
of the object returned by *note parse_args(): 11a9.  The name of this
attribute is determined by the `dest' keyword argument of *note
add_argument(): 11a8.  For positional argument actions, `dest' is
normally supplied as the first argument to *note add_argument(): 11a8.:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('bar')
    >>> parser.parse_args('XXX'.split())
    Namespace(bar='XXX')

For optional argument actions, the value of `dest' is normally inferred
from the option strings.  *note ArgumentParser: 11a6. generates the
value of `dest' by taking the first long option string and stripping
away the initial `'--'' string.  If no long option strings were
supplied, `dest' will be derived from the first short option string by
stripping the initial `'-'' character.  Any internal `'-'' characters
will be converted to `'_'' characters to make sure the string is a
valid attribute name.  The examples below illustrate this behavior:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('-f', '--foo-bar', '--foo')
    >>> parser.add_argument('-x', '-y')
    >>> parser.parse_args('-f 1 -x 2'.split())
    Namespace(foo_bar='1', x='2')
    >>> parser.parse_args('--foo 1 -y 2'.split())
    Namespace(foo_bar='1', x='2')

`dest' allows a custom attribute name to be provided:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', dest='bar')
    >>> parser.parse_args('--foo XXX'.split())
    Namespace(bar='XXX')



File: python.info,  Node: The parse_args method,  Next: Other utilities,  Prev: The add_argument method,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.29 The parse_args() method
.................................

 -- Method: ArgumentParser.parse_args (args=None, namespace=None)
     Convert argument strings to objects and assign them as attributes
     of the namespace.  Return the populated namespace.

     Previous calls to *note add_argument(): 11a8. determine exactly
     what objects are created and how they are assigned. See the
     documentation for *note add_argument(): 11a8. for details.

     By default, the arg strings are taken from *note sys.argv: 60e,
     and a new empty `Namespace' object is created for the attributes.

* Menu:

* Option value syntax::
* Invalid arguments::
* Arguments containing "-"::
* Argument abbreviations::
* Beyond sys.argv: Beyond sys argv.
* The Namespace object::


File: python.info,  Node: Option value syntax,  Next: Invalid arguments,  Up: The parse_args method

5.15.4.30 Option value syntax
.............................

The *note parse_args(): 11a9. method supports several ways of
specifying the value of an option (if it takes one).  In the simplest
case, the option and its value are passed as two separate arguments:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-x')
    >>> parser.add_argument('--foo')
    >>> parser.parse_args('-x X'.split())
    Namespace(foo=None, x='X')
    >>> parser.parse_args('--foo FOO'.split())
    Namespace(foo='FOO', x=None)

For long options (options with names longer than a single character),
the option and value can also be passed as a single command-line
argument, using `=' to separate them:

    >>> parser.parse_args('--foo=FOO'.split())
    Namespace(foo='FOO', x=None)

For short options (options only one character long), the option and its
value can be concatenated:

    >>> parser.parse_args('-xX'.split())
    Namespace(foo=None, x='X')

Several short options can be joined together, using only a single `-'
prefix, as long as only the last option (or none of them) requires a
value:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-x', action='store_true')
    >>> parser.add_argument('-y', action='store_true')
    >>> parser.add_argument('-z')
    >>> parser.parse_args('-xyzZ'.split())
    Namespace(x=True, y=True, z='Z')



File: python.info,  Node: Invalid arguments,  Next: Arguments containing "-",  Prev: Option value syntax,  Up: The parse_args method

5.15.4.31 Invalid arguments
...........................

While parsing the command line, *note parse_args(): 11a9. checks for a
variety of errors, including ambiguous options, invalid types, invalid
options, wrong number of positional arguments, etc.  When it encounters
such an error, it exits and prints the error along with a usage message:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('--foo', type=int)
    >>> parser.add_argument('bar', nargs='?')

    >>> # invalid type
    >>> parser.parse_args(['--foo', 'spam'])
    usage: PROG [-h] [--foo FOO] [bar]
    PROG: error: argument --foo: invalid int value: 'spam'

    >>> # invalid option
    >>> parser.parse_args(['--bar'])
    usage: PROG [-h] [--foo FOO] [bar]
    PROG: error: no such option: --bar

    >>> # wrong number of arguments
    >>> parser.parse_args(['spam', 'badger'])
    usage: PROG [-h] [--foo FOO] [bar]
    PROG: error: extra arguments found: badger



File: python.info,  Node: Arguments containing "-",  Next: Argument abbreviations,  Prev: Invalid arguments,  Up: The parse_args method

5.15.4.32 Arguments containing `"-"'
....................................

The *note parse_args(): 11a9. method attempts to give errors whenever
the user has clearly made a mistake, but some situations are inherently
ambiguous.  For example, the command-line arg `'-1'' could either be an
attempt to specify an option or an attempt to provide a positional
argument.  The *note parse_args(): 11a9. method is cautious here:
positional arguments may only begin with `'-'' if they look like
negative numbers and there are no options in the parser that look like
negative numbers:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-x')
    >>> parser.add_argument('foo', nargs='?')

    >>> # no negative number options, so -1 is a positional argument
    >>> parser.parse_args(['-x', '-1'])
    Namespace(foo=None, x='-1')

    >>> # no negative number options, so -1 and -5 are positional arguments
    >>> parser.parse_args(['-x', '-1', '-5'])
    Namespace(foo='-5', x='-1')

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-1', dest='one')
    >>> parser.add_argument('foo', nargs='?')

    >>> # negative number options present, so -1 is an option
    >>> parser.parse_args(['-1', 'X'])
    Namespace(foo=None, one='X')

    >>> # negative number options present, so -2 is an option
    >>> parser.parse_args(['-2'])
    usage: PROG [-h] [-1 ONE] [foo]
    PROG: error: no such option: -2

    >>> # negative number options present, so both -1s are options
    >>> parser.parse_args(['-1', '-1'])
    usage: PROG [-h] [-1 ONE] [foo]
    PROG: error: argument -1: expected one argument

If you have positional arguments that must begin with `'-'' and don't
look like negative numbers, you can insert the pseudo-argument `'--''
which tells *note parse_args(): 11a9. that everything after that is a
positional argument:

    >>> parser.parse_args(['--', '-f'])
    Namespace(foo='-f', one=None)



File: python.info,  Node: Argument abbreviations,  Next: Beyond sys argv,  Prev: Arguments containing "-",  Up: The parse_args method

5.15.4.33 Argument abbreviations
................................

The *note parse_args(): 11a9. method allows long options to be
abbreviated if the abbreviation is unambiguous:

    >>> parser = argparse.ArgumentParser(prog='PROG')
    >>> parser.add_argument('-bacon')
    >>> parser.add_argument('-badger')
    >>> parser.parse_args('-bac MMM'.split())
    Namespace(bacon='MMM', badger=None)
    >>> parser.parse_args('-bad WOOD'.split())
    Namespace(bacon=None, badger='WOOD')
    >>> parser.parse_args('-ba BA'.split())
    usage: PROG [-h] [-bacon BACON] [-badger BADGER]
    PROG: error: ambiguous option: -ba could match -badger, -bacon

An error is produced for arguments that could produce more than one
options.


File: python.info,  Node: Beyond sys argv,  Next: The Namespace object,  Prev: Argument abbreviations,  Up: The parse_args method

5.15.4.34 Beyond `sys.argv'
...........................

Sometimes it may be useful to have an ArgumentParser parse args other
than those of *note sys.argv: 60e.  This can be accomplished by passing
a list of strings to *note parse_args(): 11a9.  This is useful for
testing at the interactive prompt:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument(
    ...     'integers', metavar='int', type=int, choices=xrange(10),
    ...  nargs='+', help='an integer in the range 0..9')
    >>> parser.add_argument(
    ...     '--sum', dest='accumulate', action='store_const', const=sum,
    ...   default=max, help='sum the integers (default: find the max)')
    >>> parser.parse_args(['1', '2', '3', '4'])
    Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])
    >>> parser.parse_args('1 2 3 4 --sum'.split())
    Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])



File: python.info,  Node: The Namespace object,  Prev: Beyond sys argv,  Up: The parse_args method

5.15.4.35 The Namespace object
..............................

By default, *note parse_args(): 11a9. will return a new object of type
`Namespace' where the necessary attributes have been set. This class is
deliberately simple, just an *note object: 1ee. subclass with a
readable string representation. If you prefer to have dict-like view of
the attributes, you can use the standard Python idiom via *note vars():
57c.:

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo')
    >>> args = parser.parse_args(['--foo', 'BAR'])
    >>> vars(args)
    {'foo': 'BAR'}

It may also be useful to have an *note ArgumentParser: 11a6. assign
attributes to an already existing object, rather than a new `Namespace'
object.  This can be achieved by specifying the `namespace=' keyword
argument:

    >>> class C(object):
    ...     pass
    ...
    >>> c = C()
    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo')
    >>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)
    >>> c.foo
    'BAR'



File: python.info,  Node: Other utilities,  Next: Upgrading optparse code,  Prev: The parse_args method,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.36 Other utilities
.........................

* Menu:

* Sub-commands::
* FileType objects::
* Argument groups::
* Mutual exclusion::
* Parser defaults::
* Printing help::
* Partial parsing::
* Customizing file parsing::
* Exiting methods::


File: python.info,  Node: Sub-commands,  Next: FileType objects,  Up: Other utilities

5.15.4.37 Sub-commands
......................

 -- Method: ArgumentParser.add_subparsers ()
     Many programs split up their functionality into a number of
     sub-commands, for example, the `svn' program can invoke
     sub-commands like `svn checkout', `svn update', and `svn commit'.
     Splitting up functionality this way can be a particularly good
     idea when a program performs several different functions which
     require different kinds of command-line arguments.  *note
     ArgumentParser: 11a6. supports the creation of such sub-commands
     with the *note add_subparsers(): 11d1. method.  The *note
     add_subparsers(): 11d1. method is normally called with no
     arguments and returns an special action object.  This object has a
     single method, `add_parser()', which takes a command name and any
     *note ArgumentParser: 11a6. constructor arguments, and returns an
     *note ArgumentParser: 11a6. object that can be modified as usual.

     Some example usage:

         >>> # create the top-level parser
         >>> parser = argparse.ArgumentParser(prog='PROG')
         >>> parser.add_argument('--foo', action='store_true', help='foo help')
         >>> subparsers = parser.add_subparsers(help='sub-command help')
         >>>
         >>> # create the parser for the "a" command
         >>> parser_a = subparsers.add_parser('a', help='a help')
         >>> parser_a.add_argument('bar', type=int, help='bar help')
         >>>
         >>> # create the parser for the "b" command
         >>> parser_b = subparsers.add_parser('b', help='b help')
         >>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')
         >>>
         >>> # parse some arg lists
         >>> parser.parse_args(['a', '12'])
         Namespace(bar=12, foo=False)
         >>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])
         Namespace(baz='Z', foo=True)

     Note that the object returned by *note parse_args(): 11a9. will
     only contain attributes for the main parser and the subparser that
     was selected by the command line (and not any other subparsers).
     So in the example above, when the `"a"' command is specified, only
     the `foo' and `bar' attributes are present, and when the `"b"'
     command is specified, only the `foo' and `baz' attributes are
     present.

     Similarly, when a help message is requested from a subparser, only
     the help for that particular parser will be printed.  The help
     message will not include parent parser or sibling parser messages.
     (A help message for each subparser command, however, can be given
     by supplying the `help=' argument to `add_parser()' as above.)

         >>> parser.parse_args(['--help'])
         usage: PROG [-h] [--foo] {a,b} ...

         positional arguments:
           {a,b}   sub-command help
         a     a help
         b     b help

         optional arguments:
           -h, --help  show this help message and exit
           --foo   foo help

         >>> parser.parse_args(['a', '--help'])
         usage: PROG a [-h] bar

         positional arguments:
           bar     bar help

         optional arguments:
           -h, --help  show this help message and exit

         >>> parser.parse_args(['b', '--help'])
         usage: PROG b [-h] [--baz {X,Y,Z}]

         optional arguments:
           -h, --help     show this help message and exit
           --baz {X,Y,Z}  baz help

     The *note add_subparsers(): 11d1. method also supports `title' and
     `description' keyword arguments.  When either is present, the
     subparser's commands will appear in their own group in the help
     output.  For example:

         >>> parser = argparse.ArgumentParser()
         >>> subparsers = parser.add_subparsers(title='subcommands',
         ...                                    description='valid subcommands',
         ...                                    help='additional help')
         >>> subparsers.add_parser('foo')
         >>> subparsers.add_parser('bar')
         >>> parser.parse_args(['-h'])
         usage:  [-h] {foo,bar} ...

         optional arguments:
           -h, --help  show this help message and exit

         subcommands:
           valid subcommands

           {foo,bar}   additional help

     One particularly effective way of handling sub-commands is to
     combine the use of the *note add_subparsers(): 11d1. method with
     calls to *note set_defaults(): 11b8. so that each subparser knows
     which Python function it should execute.  For example:

         >>> # sub-command functions
         >>> def foo(args):
         ...     print args.x * args.y
         ...
         >>> def bar(args):
         ...     print '((%s))' % args.z
         ...
         >>> # create the top-level parser
         >>> parser = argparse.ArgumentParser()
         >>> subparsers = parser.add_subparsers()
         >>>
         >>> # create the parser for the "foo" command
         >>> parser_foo = subparsers.add_parser('foo')
         >>> parser_foo.add_argument('-x', type=int, default=1)
         >>> parser_foo.add_argument('y', type=float)
         >>> parser_foo.set_defaults(func=foo)
         >>>
         >>> # create the parser for the "bar" command
         >>> parser_bar = subparsers.add_parser('bar')
         >>> parser_bar.add_argument('z')
         >>> parser_bar.set_defaults(func=bar)
         >>>
         >>> # parse the args and call whatever function was selected
         >>> args = parser.parse_args('foo 1 -x 2'.split())
         >>> args.func(args)
         2.0
         >>>
         >>> # parse the args and call whatever function was selected
         >>> args = parser.parse_args('bar XYZYX'.split())
         >>> args.func(args)
         ((XYZYX))

     This way, you can let *note parse_args(): 11a9. does the job of
     calling the appropriate function after argument parsing is
     complete.  Associating functions with actions like this is
     typically the easiest way to handle the different actions for each
     of your subparsers.  However, if it is necessary to check the name
     of the subparser that was invoked, the `dest' keyword argument to
     the *note add_subparsers(): 11d1. call will work:

         >>> parser = argparse.ArgumentParser()
         >>> subparsers = parser.add_subparsers(dest='subparser_name')
         >>> subparser1 = subparsers.add_parser('1')
         >>> subparser1.add_argument('-x')
         >>> subparser2 = subparsers.add_parser('2')
         >>> subparser2.add_argument('y')
         >>> parser.parse_args(['2', 'frobble'])
         Namespace(subparser_name='2', y='frobble')




File: python.info,  Node: FileType objects,  Next: Argument groups,  Prev: Sub-commands,  Up: Other utilities

5.15.4.38 FileType objects
..........................

 -- Class: argparse.FileType (mode='r', bufsize=None)
     The *note FileType: 1d3. factory creates objects that can be
     passed to the type argument of *note
     ArgumentParser.add_argument(): 11a8.  Arguments that have *note
     FileType: 1d3. objects as their type will open command-line args
     as files with the requested modes and buffer sizes:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--output', type=argparse.FileType('wb', 0))
         >>> parser.parse_args(['--output', 'out'])
         Namespace(output=<open file 'out', mode 'wb' at 0x...>)

     FileType objects understand the pseudo-argument `'-'' and
     automatically convert this into `sys.stdin' for readable *note
     FileType: 1d3. objects and `sys.stdout' for writable *note
     FileType: 1d3. objects:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('infile', type=argparse.FileType('r'))
         >>> parser.parse_args(['-'])
         Namespace(infile=<open file '<stdin>', mode 'r' at 0x...>)




File: python.info,  Node: Argument groups,  Next: Mutual exclusion,  Prev: FileType objects,  Up: Other utilities

5.15.4.39 Argument groups
.........................

 -- Method: ArgumentParser.add_argument_group (title=None,
          description=None)
     By default, *note ArgumentParser: 11a6. groups command-line
     arguments into "positional arguments" and "optional arguments"
     when displaying help messages. When there is a better conceptual
     grouping of arguments than this default one, appropriate groups
     can be created using the *note add_argument_group(): 11d4. method:

         >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
         >>> group = parser.add_argument_group('group')
         >>> group.add_argument('--foo', help='foo help')
         >>> group.add_argument('bar', help='bar help')
         >>> parser.print_help()
         usage: PROG [--foo FOO] bar

         group:
           bar    bar help
           --foo FOO  foo help

     The *note add_argument_group(): 11d4. method returns an argument
     group object which has an *note add_argument(): 11a8. method just
     like a regular *note ArgumentParser: 11a6.  When an argument is
     added to the group, the parser treats it just like a normal
     argument, but displays the argument in a separate group for help
     messages.  The *note add_argument_group(): 11d4. method accepts
     _title_ and _description_ arguments which can be used to customize
     this display:

         >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
         >>> group1 = parser.add_argument_group('group1', 'group1 description')
         >>> group1.add_argument('foo', help='foo help')
         >>> group2 = parser.add_argument_group('group2', 'group2 description')
         >>> group2.add_argument('--bar', help='bar help')
         >>> parser.print_help()
         usage: PROG [--bar BAR] foo

         group1:
           group1 description

           foo    foo help

         group2:
           group2 description

           --bar BAR  bar help

     Note that any arguments not your user defined groups will end up
     back in the usual "positional arguments" and "optional arguments"
     sections.


File: python.info,  Node: Mutual exclusion,  Next: Parser defaults,  Prev: Argument groups,  Up: Other utilities

5.15.4.40 Mutual exclusion
..........................

 -- Method: argparse.add_mutually_exclusive_group (required=False)
     Create a mutually exclusive group. *note argparse: d. will make
     sure that only one of the arguments in the mutually exclusive
     group was present on the command line:

         >>> parser = argparse.ArgumentParser(prog='PROG')
         >>> group = parser.add_mutually_exclusive_group()
         >>> group.add_argument('--foo', action='store_true')
         >>> group.add_argument('--bar', action='store_false')
         >>> parser.parse_args(['--foo'])
         Namespace(bar=True, foo=True)
         >>> parser.parse_args(['--bar'])
         Namespace(bar=False, foo=False)
         >>> parser.parse_args(['--foo', '--bar'])
         usage: PROG [-h] [--foo | --bar]
         PROG: error: argument --bar: not allowed with argument --foo

     The *note add_mutually_exclusive_group(): 11d6. method also
     accepts a _required_ argument, to indicate that at least one of
     the mutually exclusive arguments is required:

         >>> parser = argparse.ArgumentParser(prog='PROG')
         >>> group = parser.add_mutually_exclusive_group(required=True)
         >>> group.add_argument('--foo', action='store_true')
         >>> group.add_argument('--bar', action='store_false')
         >>> parser.parse_args([])
         usage: PROG [-h] (--foo | --bar)
         PROG: error: one of the arguments --foo --bar is required

     Note that currently mutually exclusive argument groups do not
     support the _title_ and _description_ arguments of *note
     add_argument_group(): 11d4.


File: python.info,  Node: Parser defaults,  Next: Printing help,  Prev: Mutual exclusion,  Up: Other utilities

5.15.4.41 Parser defaults
.........................

 -- Method: ArgumentParser.set_defaults (**kwargs)
     Most of the time, the attributes of the object returned by *note
     parse_args(): 11a9.  will be fully determined by inspecting the
     command-line args and the argument actions.  *note set_defaults():
     11b8. allows some additional attributes that are determined
     without any inspection of the command line to be added:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('foo', type=int)
         >>> parser.set_defaults(bar=42, baz='badger')
         >>> parser.parse_args(['736'])
         Namespace(bar=42, baz='badger', foo=736)

     Note that parser-level defaults always override argument-level
     defaults:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', default='bar')
         >>> parser.set_defaults(foo='spam')
         >>> parser.parse_args([])
         Namespace(foo='spam')

     Parser-level defaults can be particularly useful when working with
     multiple parsers.  See the *note add_subparsers(): 11d1. method
     for an example of this type.

 -- Method: ArgumentParser.get_default (dest)
     Get the default value for a namespace attribute, as set by either
     *note add_argument(): 11a8. or by *note set_defaults(): 11b8.:

         >>> parser = argparse.ArgumentParser()
         >>> parser.add_argument('--foo', default='badger')
         >>> parser.get_default('foo')
         'badger'




File: python.info,  Node: Printing help,  Next: Partial parsing,  Prev: Parser defaults,  Up: Other utilities

5.15.4.42 Printing help
.......................

In most typical applications, *note parse_args(): 11a9. will take care
of formatting and printing any usage or error messages.  However,
several formatting methods are available:

 -- Method: ArgumentParser.print_usage (file=None)
     Print a brief description of how the *note ArgumentParser: 11a6.
     should be invoked on the command line.  If _file_ is `None', *note
     sys.stdout: 853. is assumed.

 -- Method: ArgumentParser.print_help (file=None)
     Print a help message, including the program usage and information
     about the arguments registered with the *note ArgumentParser:
     11a6.  If _file_ is `None', *note sys.stdout: 853. is assumed.

  There are also variants of these methods that simply return a string
instead of printing it:

 -- Method: ArgumentParser.format_usage ()
     Return a string containing a brief description of how the *note
     ArgumentParser: 11a6. should be invoked on the command line.

 -- Method: ArgumentParser.format_help ()
     Return a string containing a help message, including the program
     usage and information about the arguments registered with the
     *note ArgumentParser: 11a6.


File: python.info,  Node: Partial parsing,  Next: Customizing file parsing,  Prev: Printing help,  Up: Other utilities

5.15.4.43 Partial parsing
.........................

 -- Method: ArgumentParser.parse_known_args (args=None, namespace=None)

  Sometimes a script may only parse a few of the command-line
arguments, passing the remaining arguments on to another script or
program. In these cases, the *note parse_known_args(): 11df. method can
be useful.  It works much like *note parse_args(): 11a9. except that it
does not produce an error when extra arguments are present.  Instead,
it returns a two item tuple containing the populated namespace and the
list of remaining argument strings.

    >>> parser = argparse.ArgumentParser()
    >>> parser.add_argument('--foo', action='store_true')
    >>> parser.add_argument('bar')
    >>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])
    (Namespace(bar='BAR', foo=True), ['--badger', 'spam'])



File: python.info,  Node: Customizing file parsing,  Next: Exiting methods,  Prev: Partial parsing,  Up: Other utilities

5.15.4.44 Customizing file parsing
..................................

 -- Method: ArgumentParser.convert_arg_line_to_args (arg_line)
     Arguments that are read from a file (see the
     _fromfile_prefix_chars_ keyword argument to the *note
     ArgumentParser: 11a6. constructor) are read one argument per line.
     *note convert_arg_line_to_args(): 11b7. can be overriden for
     fancier reading.

     This method takes a single argument _arg_line_ which is a string
     read from the argument file.  It returns a list of arguments
     parsed from this string.  The method is called once per line read
     from the argument file, in order.

     A useful override of this method is one that treats each
     space-separated word as an argument:

         def convert_arg_line_to_args(self, arg_line):
             for arg in arg_line.split():
                 if not arg.strip():
                     continue
                 yield arg




File: python.info,  Node: Exiting methods,  Prev: Customizing file parsing,  Up: Other utilities

5.15.4.45 Exiting methods
.........................

 -- Method: ArgumentParser.exit (status=0, message=None)
     This method terminates the program, exiting with the specified
     _status_ and, if given, it prints a _message_ before that.

 -- Method: ArgumentParser.error (message)
     This method prints a usage message including the _message_ to the
     standard output and terminates the program with a status code of 2.


File: python.info,  Node: Upgrading optparse code,  Prev: Other utilities,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.46 Upgrading optparse code
.................................

Originally, the *note argparse: d. module had attempted to maintain
compatibility with *note optparse: 128.  However, *note optparse: 128.
was difficult to extend transparently, particularly with the changes
required to support the new `nargs=' specifiers and better usage
messages.  When most everything in *note optparse: 128. had either been
copy-pasted over or monkey-patched, it no longer seemed practical to
try to maintain the backwards compatibility.

  A partial upgrade path from *note optparse: 128. to *note argparse:
d.:

   * Replace all *note optparse.OptionParser.add_option(): 11e5. calls
     with *note ArgumentParser.add_argument(): 11a8. calls.

   * Replace `options, args = parser.parse_args()' with `args =
     parser.parse_args()' and add additional *note
     ArgumentParser.add_argument(): 11a8.  calls for the positional
     arguments.

   * Replace callback actions and the `callback_*' keyword arguments
     with `type' or `action' arguments.

   * Replace string names for `type' keyword arguments with the
     corresponding type objects (e.g. int, float, complex, etc).

   * Replace `optparse.Values' with `Namespace' and
     `optparse.OptionError' and `optparse.OptionValueError' with
     `ArgumentError'.

   * Replace strings with implicit arguments such as `%default' or
     `%prog' with the standard Python syntax to use dictionaries to
     format strings, that is, `%(default)s' and `%(prog)s'.

   * Replace the OptionParser constructor `version' argument with a
     call to `parser.add_argument('--version', action='version',
     version='<the version>')'


File: python.info,  Node: optparse --- Parser for command line options,  Next: getopt --- C-style parser for command line options,  Prev: argparse --- Parser for command-line options arguments and sub-commands,  Up: Generic Operating System Services

5.15.5 `optparse' -- Parser for command line options
----------------------------------------------------

Deprecated since version 2.7: The *note optparse: 128. module is
deprecated and will not be developed further; development will continue
with the *note argparse: d. module.

  New in version 2.3.

  *note optparse: 128. is a more convenient, flexible, and powerful
library for parsing command-line options than the old *note getopt: df.
module.  *note optparse: 128. uses a more declarative style of
command-line parsing: you create an instance of *note OptionParser:
11e8, populate it with options, and parse the command line. *note
optparse: 128. allows users to specify options in the conventional
GNU/POSIX syntax, and additionally generates usage and help messages
for you.

  Here's an example of using *note optparse: 128. in a simple script:

    from optparse import OptionParser
    [...]
    parser = OptionParser()
    parser.add_option("-f", "--file", dest="filename",
                      help="write report to FILE", metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")

    (options, args) = parser.parse_args()

With these few lines of code, users of your script can now do the
"usual thing" on the command-line, for example:

    <yourscript> --file=outfile -q

As it parses the command line, *note optparse: 128. sets attributes of
the `options' object returned by `parse_args()' based on user-supplied
command-line values.  When `parse_args()' returns from parsing this
command line, `options.filename' will be `"outfile"' and
`options.verbose' will be `False'.  *note optparse: 128. supports both
long and short options, allows short options to be merged together, and
allows options to be associated with their arguments in a variety of
ways.  Thus, the following command lines are all equivalent to the
above example:

    <yourscript> -f outfile --quiet
    <yourscript> --quiet --file outfile
    <yourscript> -q -foutfile
    <yourscript> -qfoutfile

Additionally, users can run one of

    <yourscript> -h
    <yourscript> --help

and *note optparse: 128. will print out a brief summary of your
script's options:

    Usage: <yourscript> [options]

    Options:
      -h, --help            show this help message and exit
      -f FILE, --file=FILE  write report to FILE
      -q, --quiet           don't print status messages to stdout

where the value of _yourscript_ is determined at runtime (normally from
`sys.argv[0]').

* Menu:

* Background::
* Tutorial::
* Reference Guide::
* Option Callbacks::
* Extending optparse::

Background

* Terminology::
* What are options for?::
* What are positional arguments for?::

Tutorial

* Understanding option actions::
* The store action::
* Handling boolean (flag) options: Handling boolean flag options.
* Other actions::
* Default values::
* Generating help::
* Printing a version string::
* How optparse handles errors::
* Putting it all together::

Generating help

* Grouping Options::

Reference Guide

* Creating the parser::
* Populating the parser::
* Defining options::
* Option attributes::
* Standard option actions::
* Standard option types::
* Parsing arguments: Parsing arguments<2>.
* Querying and manipulating your option parser::
* Conflicts between options::
* Cleanup::
* Other methods::

Option Callbacks

* Defining a callback option::
* How callbacks are called::
* Raising errors in a callback::
* Callback example 1; trivial callback: Callback example 1 trivial callback.
* Callback example 2; check option order: Callback example 2 check option order.
* Callback example 3; check option order (generalized): Callback example 3 check option order generalized.
* Callback example 4; check arbitrary condition: Callback example 4 check arbitrary condition.
* Callback example 5; fixed arguments: Callback example 5 fixed arguments.
* Callback example 6; variable arguments: Callback example 6 variable arguments.

Extending optparse

* Adding new types::
* Adding new actions::


File: python.info,  Node: Background,  Next: Tutorial,  Up: optparse --- Parser for command line options

5.15.5.1 Background
...................

*note optparse: 128. was explicitly designed to encourage the creation
of programs with straightforward, conventional command-line interfaces.
To that end, it supports only the most common command-line syntax and
semantics conventionally used under Unix.  If you are unfamiliar with
these conventions, read this section to acquaint yourself with them.

* Menu:

* Terminology::
* What are options for?::
* What are positional arguments for?::


File: python.info,  Node: Terminology,  Next: What are options for?,  Up: Background

5.15.5.2 Terminology
....................

argument
     a string entered on the command-line, and passed by the shell to
     `execl()' or `execv()'.  In Python, arguments are elements of
     `sys.argv[1:]' (`sys.argv[0]' is the name of the program being
     executed).  Unix shells also use the term "word".

     It is occasionally desirable to substitute an argument list other
     than `sys.argv[1:]', so you should read "argument" as "an element
     of `sys.argv[1:]', or of some other list provided as a substitute
     for `sys.argv[1:]'".

option
     an argument used to supply extra information to guide or customize
     the execution of a program.  There are many different syntaxes for
     options; the traditional Unix syntax is a hyphen ("-") followed by
     a single letter, e.g. `-x' or `-F'.  Also, traditional Unix syntax
     allows multiple options to be merged into a single argument, e.g.
     `-x -F' is equivalent to `-xF'.  The GNU project introduced `--'
     followed by a series of hyphen-separated words, e.g. `--file' or
     `--dry-run'.  These are the only two option syntaxes provided by
     *note optparse: 128.

     Some other option syntaxes that the world has seen include:

        * a hyphen followed by a few letters, e.g. `-pf' (this is _not_
          the same as multiple options merged into a single argument)

        * a hyphen followed by a whole word, e.g. `-file' (this is
          technically equivalent to the previous syntax, but they
          aren't usually seen in the same program)

        * a plus sign followed by a single letter, or a few letters, or
          a word, e.g.  `+f', `+rgb'

        * a slash followed by a letter, or a few letters, or a word,
          e.g. `/f', `/file'

     These option syntaxes are not supported by *note optparse: 128,
     and they never will be.  This is deliberate: the first three are
     non-standard on any environment, and the last only makes sense if
     you're exclusively targeting VMS, MS-DOS, and/or Windows.

option argument
     an argument that follows an option, is closely associated with
     that option, and is consumed from the argument list when that
     option is. With *note optparse: 128, option arguments may either
     be in a separate argument from their option:

         -f foo
         --file foo

     or included in the same argument:

         -ffoo
         --file=foo

     Typically, a given option either takes an argument or it doesn't.
     Lots of people want an "optional option arguments" feature,
     meaning that some options will take an argument if they see it,
     and won't if they don't.  This is somewhat controversial, because
     it makes parsing ambiguous: if `-a' takes an optional argument and
     `-b' is another option entirely, how do we interpret `-ab'?
     Because of this ambiguity, *note optparse: 128. does not support
     this feature.

positional argument
     something leftover in the argument list after options have been
     parsed, i.e.  after options and their arguments have been parsed
     and removed from the argument list.

required option
     an option that must be supplied on the command-line; note that the
     phrase "required option" is self-contradictory in English.  *note
     optparse: 128. doesn't prevent you from implementing required
     options, but doesn't give you much help at it either.

  For example, consider this hypothetical command-line:

    prog -v --report /tmp/report.txt foo bar

`-v' and `--report' are both options.  Assuming that `--report' takes
one argument, `/tmp/report.txt' is an option argument.  `foo' and `bar'
are positional arguments.


File: python.info,  Node: What are options for?,  Next: What are positional arguments for?,  Prev: Terminology,  Up: Background

5.15.5.3 What are options for?
..............................

Options are used to provide extra information to tune or customize the
execution of a program.  In case it wasn't clear, options are usually
_optional_.  A program should be able to run just fine with no options
whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can
it run without any options at all and still make sense?  The main
exceptions are `find', `tar', and `dd'--all of which are mutant
oddballs that have been rightly criticized for their non-standard
syntax and confusing interfaces.)

  Lots of people want their programs to have "required options".  Think
about it.  If it's required, then it's _not optional_!  If there is a
piece of information that your program absolutely requires in order to
run successfully, that's what positional arguments are for.

  As an example of good command-line interface design, consider the
humble `cp' utility, for copying files.  It doesn't make much sense to
try to copy files without supplying a destination and at least one
source. Hence, `cp' fails if you run it with no arguments.  However, it
has a flexible, useful syntax that does not require any options at all:

    cp SOURCE DEST
    cp SOURCE ... DEST-DIR

You can get pretty far with just that.  Most `cp' implementations
provide a bunch of options to tweak exactly how the files are copied:
you can preserve mode and modification time, avoid following symlinks,
ask before clobbering existing files, etc.  But none of this distracts
from the core mission of `cp', which is to copy either one file to
another, or several files to another directory.


File: python.info,  Node: What are positional arguments for?,  Prev: What are options for?,  Up: Background

5.15.5.4 What are positional arguments for?
...........................................

Positional arguments are for those pieces of information that your
program absolutely, positively requires to run.

  A good user interface should have as few absolute requirements as
possible.  If your program requires 17 distinct pieces of information
in order to run successfully, it doesn't much matter _how_ you get that
information from the user--most people will give up and walk away
before they successfully run the program.  This applies whether the
user interface is a command-line, a configuration file, or a GUI: if
you make that many demands on your users, most of them will simply give
up.

  In short, try to minimize the amount of information that users are
absolutely required to supply--use sensible defaults whenever possible.
Of course, you also want to make your programs reasonably flexible.
That's what options are for.  Again, it doesn't matter if they are
entries in a config file, widgets in the "Preferences" dialog of a GUI,
or command-line options--the more options you implement, the more
flexible your program is, and the more complicated its implementation
becomes.  Too much flexibility has drawbacks as well, of course; too
many options can overwhelm users and make your code much harder to
maintain.


File: python.info,  Node: Tutorial,  Next: Reference Guide,  Prev: Background,  Up: optparse --- Parser for command line options

5.15.5.5 Tutorial
.................

While *note optparse: 128. is quite flexible and powerful, it's also
straightforward to use in most cases.  This section covers the code
patterns that are common to any *note optparse: 128.-based program.

  First, you need to import the OptionParser class; then, early in the
main program, create an OptionParser instance:

    from optparse import OptionParser
    [...]
    parser = OptionParser()

Then you can start defining options.  The basic syntax is:

    parser.add_option(opt_str, ...,
                      attr=value, ...)

Each option has one or more option strings, such as `-f' or `--file',
and several option attributes that tell *note optparse: 128. what to
expect and what to do when it encounters that option on the command
line.

  Typically, each option will have one short option string and one long
option string, e.g.:

    parser.add_option("-f", "--file", ...)

You're free to define as many short option strings and as many long
option strings as you like (including zero), as long as there is at
least one option string overall.

  The option strings passed to `add_option()' are effectively labels
for the option defined by that call.  For brevity, we will frequently
refer to _encountering an option_ on the command line; in reality,
*note optparse: 128.  encounters _option strings_ and looks up options
from them.

  Once all of your options are defined, instruct *note optparse: 128.
to parse your program's command line:

    (options, args) = parser.parse_args()

(If you like, you can pass a custom argument list to `parse_args()', but
that's rarely necessary: by default it uses `sys.argv[1:]'.)

  `parse_args()' returns two values:

   * `options', an object containing values for all of your
     options--e.g. if `--file' takes a single string argument, then
     `options.file' will be the filename supplied by the user, or
     `None' if the user did not supply that option

   * `args', the list of positional arguments leftover after parsing
     options

  This tutorial section only covers the four most important option
attributes: *note action: 11f3, *note type: 11f4, *note dest: 11f5.
(destination), and *note help: 11f6. Of these, *note action: 11f3. is
the most fundamental.

* Menu:

* Understanding option actions::
* The store action::
* Handling boolean (flag) options: Handling boolean flag options.
* Other actions::
* Default values::
* Generating help::
* Printing a version string::
* How optparse handles errors::
* Putting it all together::


File: python.info,  Node: Understanding option actions,  Next: The store action,  Up: Tutorial

5.15.5.6 Understanding option actions
.....................................

Actions tell *note optparse: 128. what to do when it encounters an
option on the command line.  There is a fixed set of actions hard-coded
into *note optparse: 128.; adding new actions is an advanced topic
covered in section *note Extending optparse: 11f9.  Most actions tell
*note optparse: 128. to store a value in some variable--for example,
take a string from the command line and store it in an attribute of
`options'.

  If you don't specify an option action, *note optparse: 128. defaults
to `store'.


File: python.info,  Node: The store action,  Next: Handling boolean flag options,  Prev: Understanding option actions,  Up: Tutorial

5.15.5.7 The store action
.........................

The most common option action is `store', which tells *note optparse:
128. to take the next argument (or the remainder of the current
argument), ensure that it is of the correct type, and store it to your
chosen destination.

  For example:

    parser.add_option("-f", "--file",
                      action="store", type="string", dest="filename")

Now let's make up a fake command line and ask *note optparse: 128. to
parse it:

    args = ["-f", "foo.txt"]
    (options, args) = parser.parse_args(args)

When *note optparse: 128. sees the option string `-f', it consumes the
next argument, `foo.txt', and stores it in `options.filename'.  So,
after this call to `parse_args()', `options.filename' is `"foo.txt"'.

  Some other option types supported by *note optparse: 128. are `int'
and `float'.  Here's an option that expects an integer argument:

    parser.add_option("-n", type="int", dest="num")

Note that this option has no long option string, which is perfectly
acceptable.  Also, there's no explicit action, since the default is
`store'.

  Let's parse another fake command-line.  This time, we'll jam the
option argument right up against the option: since `-n42' (one
argument) is equivalent to `-n 42' (two arguments), the code

    (options, args) = parser.parse_args(["-n42"])
    print options.num

will print `42'.

  If you don't specify a type, *note optparse: 128. assumes `string'.
Combined with the fact that the default action is `store', that means
our first example can be a lot shorter:

    parser.add_option("-f", "--file", dest="filename")

If you don't supply a destination, *note optparse: 128. figures out a
sensible default from the option strings: if the first long option
string is `--foo-bar', then the default destination is `foo_bar'.  If
there are no long option strings, *note optparse: 128. looks at the
first short option string: the default destination for `-f' is `f'.

  *note optparse: 128. also includes built-in `long' and `complex'
types.  Adding types is covered in section *note Extending optparse:
11f9.


File: python.info,  Node: Handling boolean flag options,  Next: Other actions,  Prev: The store action,  Up: Tutorial

5.15.5.8 Handling boolean (flag) options
........................................

Flag options--set a variable to true or false when a particular option
is seen --are quite common.  *note optparse: 128. supports them with
two separate actions, `store_true' and `store_false'.  For example, you
might have a `verbose' flag that is turned on with `-v' and off with
`-q':

    parser.add_option("-v", action="store_true", dest="verbose")
    parser.add_option("-q", action="store_false", dest="verbose")

Here we have two different options with the same destination, which is
perfectly OK.  (It just means you have to be a bit careful when setting
default values-- see below.)

  When *note optparse: 128. encounters `-v' on the command line, it sets
`options.verbose' to `True'; when it encounters `-q', `options.verbose'
is set to `False'.


File: python.info,  Node: Other actions,  Next: Default values,  Prev: Handling boolean flag options,  Up: Tutorial

5.15.5.9 Other actions
......................

Some other actions supported by *note optparse: 128. are:

`"store_const"'
     store a constant value

`"append"'
     append this option's argument to a list

`"count"'
     increment a counter by one

`"callback"'
     call a specified function

  These are covered in section *note Reference Guide: 1200, Reference
Guide and section *note Option Callbacks: 1201.


File: python.info,  Node: Default values,  Next: Generating help,  Prev: Other actions,  Up: Tutorial

5.15.5.10 Default values
........................

All of the above examples involve setting some variable (the
"destination") when certain command-line options are seen.  What
happens if those options are never seen?  Since we didn't supply any
defaults, they are all set to `None'.  This is usually fine, but
sometimes you want more control.  *note optparse: 128. lets you supply
a default value for each destination, which is assigned before the
command line is parsed.

  First, consider the verbose/quiet example.  If we want *note
optparse: 128. to set `verbose' to `True' unless `-q' is seen, then we
can do this:

    parser.add_option("-v", action="store_true", dest="verbose", default=True)
    parser.add_option("-q", action="store_false", dest="verbose")

Since default values apply to the _destination_ rather than to any
particular option, and these two options happen to have the same
destination, this is exactly equivalent:

    parser.add_option("-v", action="store_true", dest="verbose")
    parser.add_option("-q", action="store_false", dest="verbose", default=True)

Consider this:

    parser.add_option("-v", action="store_true", dest="verbose", default=False)
    parser.add_option("-q", action="store_false", dest="verbose", default=True)

Again, the default value for `verbose' will be `True': the last default
value supplied for any particular destination is the one that counts.

  A clearer way to specify default values is the `set_defaults()'
method of OptionParser, which you can call at any time before calling
`parse_args()':

    parser.set_defaults(verbose=True)
    parser.add_option(...)
    (options, args) = parser.parse_args()

As before, the last value specified for a given option destination is
the one that counts.  For clarity, try to use one method or the other
of setting default values, not both.


File: python.info,  Node: Generating help,  Next: Printing a version string,  Prev: Default values,  Up: Tutorial

5.15.5.11 Generating help
.........................

*note optparse: 128.'s ability to generate help and usage text
automatically is useful for creating user-friendly command-line
interfaces.  All you have to do is supply a *note help: 11f6. value for
each option, and optionally a short usage message for your whole
program.  Here's an OptionParser populated with user-friendly
(documented) options:

    usage = "usage: %prog [options] arg1 arg2"
    parser = OptionParser(usage=usage)
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=True,
                      help="make lots of noise [default]")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose",
                      help="be vewwy quiet (I'm hunting wabbits)")
    parser.add_option("-f", "--filename",
                      metavar="FILE", help="write output to FILE")
    parser.add_option("-m", "--mode",
                      default="intermediate",
                      help="interaction mode: novice, intermediate, "
                           "or expert [default: %default]")

If *note optparse: 128. encounters either `-h' or `--help' on the
command-line, or if you just call `parser.print_help()', it prints the
following to standard output:

    Usage: <yourscript> [options] arg1 arg2

    Options:
      -h, --help            show this help message and exit
      -v, --verbose         make lots of noise [default]
      -q, --quiet           be vewwy quiet (I'm hunting wabbits)
      -f FILE, --filename=FILE
                            write output to FILE
      -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                            expert [default: intermediate]

(If the help output is triggered by a help option, *note optparse: 128.
exits after printing the help text.)

  There's a lot going on here to help *note optparse: 128. generate the
best possible help message:

   * the script defines its own usage message:

         usage = "usage: %prog [options] arg1 arg2"

     *note optparse: 128. expands `%prog' in the usage string to the
     name of the current program, i.e. `os.path.basename(sys.argv[0])'.
     The expanded string is then printed before the detailed option
     help.

     If you don't supply a usage string, *note optparse: 128. uses a
     bland but sensible default: `"Usage: %prog [options]"', which is
     fine if your script doesn't take any positional arguments.

   * every option defines a help string, and doesn't worry about
     line-wrapping-- *note optparse: 128. takes care of wrapping lines
     and making the help output look good.

   * options that take a value indicate this fact in their
     automatically-generated help message, e.g. for the "mode" option:

         -m MODE, --mode=MODE

     Here, "MODE" is called the meta-variable: it stands for the
     argument that the user is expected to supply to `-m'/`--mode'.  By
     default, *note optparse: 128. converts the destination variable
     name to uppercase and uses that for the meta-variable.  Sometimes,
     that's not what you want--for example, the `--filename' option
     explicitly sets `metavar="FILE"', resulting in this
     automatically-generated option description:

         -f FILE, --filename=FILE

     This is important for more than just saving space, though: the
     manually written help text uses the meta-variable `FILE' to clue
     the user in that there's a connection between the semi-formal
     syntax `-f FILE' and the informal semantic description "write
     output to FILE". This is a simple but effective way to make your
     help text a lot clearer and more useful for end users.

  New in version 2.4: Options that have a default value can include
`%default' in the help string--*note optparse: 128. will replace it
with *note str(): 1e7. of the option's default value.  If an option has
no default value (or the default value is `None'), `%default' expands
to `none'.

* Menu:

* Grouping Options::


File: python.info,  Node: Grouping Options,  Up: Generating help

5.15.5.12 Grouping Options
..........................

When dealing with many options, it is convenient to group these options
for better help output.  An *note OptionParser: 11e8. can contain
several option groups, each of which can contain several options.

  An option group is obtained using the class *note OptionGroup: 1207.:

 -- Class: optparse.OptionGroup (parser, title, description=None)
     where

        * parser is the *note OptionParser: 11e8. instance the group
          will be insterted in to

        * title is the group title

        * description, optional, is a long description of the group

  *note OptionGroup: 1207. inherits from `OptionContainer' (like *note
OptionParser: 11e8.) and so the `add_option()' method can be used to add
an option to the group.

  Once all the options are declared, using the *note OptionParser:
11e8. method `add_option_group()' the group is added to the previously
defined parser.

  Continuing with the parser defined in the previous section, adding an
*note OptionGroup: 1207. to a parser is easy:

    group = OptionGroup(parser, "Dangerous Options",
                        "Caution: use these options at your own risk.  "
                        "It is believed that some of them bite.")
    group.add_option("-g", action="store_true", help="Group option.")
    parser.add_option_group(group)

This would result in the following help output:

    Usage: <yourscript> [options] arg1 arg2

    Options:
      -h, --help            show this help message and exit
      -v, --verbose         make lots of noise [default]
      -q, --quiet           be vewwy quiet (I'm hunting wabbits)
      -f FILE, --filename=FILE
                            write output to FILE
      -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                            expert [default: intermediate]

      Dangerous Options:
        Caution: use these options at your own risk.  It is believed that some
        of them bite.

        -g                  Group option.

A bit more complete example might invole using more than one group:
still extendind the previous example:

    group = OptionGroup(parser, "Dangerous Options",
                        "Caution: use these options at your own risk.  "
                        "It is believed that some of them bite.")
    group.add_option("-g", action="store_true", help="Group option.")
    parser.add_option_group(group)

    group = OptionGroup(parser, "Debug Options")
    group.add_option("-d", "--debug", action="store_true",
                     help="Print debug information")
    group.add_option("-s", "--sql", action="store_true",
                     help="Print all SQL statements executed")
    group.add_option("-e", action="store_true", help="Print every action done")
    parser.add_option_group(group)

that results in the following output:

    Usage: <yourscript> [options] arg1 arg2

    Options:
      -h, --help            show this help message and exit
      -v, --verbose         make lots of noise [default]
      -q, --quiet           be vewwy quiet (I'm hunting wabbits)
      -f FILE, --filename=FILE
                            write output to FILE
      -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert
                            [default: intermediate]

      Dangerous Options:
        Caution: use these options at your own risk.  It is believed that some
        of them bite.

        -g                  Group option.

      Debug Options:
        -d, --debug         Print debug information
        -s, --sql           Print all SQL statements executed
        -e                  Print every action done

Another interesting method, in particular when working programmatically
with option groups is:

 -- Method: OptionParser.get_option_group (opt_str)
     Return, if defined, the *note OptionGroup: 1207. that has the
     title or the long description equals to _opt_str_


File: python.info,  Node: Printing a version string,  Next: How optparse handles errors,  Prev: Generating help,  Up: Tutorial

5.15.5.13 Printing a version string
...................................

Similar to the brief usage string, *note optparse: 128. can also print
a version string for your program.  You have to supply the string as
the `version' argument to OptionParser:

    parser = OptionParser(usage="%prog [-f] [-q]", version="%prog 1.0")

`%prog' is expanded just like it is in `usage'.  Apart from that,
`version' can contain anything you like.  When you supply it, *note
optparse: 128.  automatically adds a `--version' option to your parser.
If it encounters this option on the command line, it expands your
`version' string (by replacing `%prog'), prints it to stdout, and exits.

  For example, if your script is called `/usr/bin/foo':

    $ /usr/bin/foo --version
    foo 1.0

The following two methods can be used to print and get the `version'
string:

 -- Method: OptionParser.print_version (file=None)
     Print the version message for the current program (`self.version')
     to _file_ (default stdout).  As with *note print_usage(): 120c,
     any occurrence of `%prog' in `self.version' is replaced with the
     name of the current program.  Does nothing if `self.version' is
     empty or undefined.

 -- Method: OptionParser.get_version ()
     Same as *note print_version(): 120b. but returns the version
     string instead of printing it.


File: python.info,  Node: How optparse handles errors,  Next: Putting it all together,  Prev: Printing a version string,  Up: Tutorial

5.15.5.14 How `optparse' handles errors
.......................................

There are two broad classes of errors that *note optparse: 128. has to
worry about: programmer errors and user errors.  Programmer errors are
usually erroneous calls to *note OptionParser.add_option(): 11e5, e.g.
invalid option strings, unknown option attributes, missing option
attributes, etc.  These are dealt with in the usual way: raise an
exception (either `optparse.OptionError' or *note TypeError: 215.) and
let the program crash.

  Handling user errors is much more important, since they are
guaranteed to happen no matter how stable your code is.  *note
optparse: 128. can automatically detect some user errors, such as bad
option arguments (passing `-n 4x' where `-n' takes an integer
argument), missing arguments (`-n' at the end of the command line,
where `-n' takes an argument of any type).  Also, you can call
`OptionParser.error()' to signal an application-defined error condition:

    (options, args) = parser.parse_args()
    [...]
    if options.a and options.b:
        parser.error("options -a and -b are mutually exclusive")

In either case, *note optparse: 128. handles the error the same way: it
prints the program's usage message and an error message to standard
error and exits with error status 2.

  Consider the first example above, where the user passes `4x' to an
option that takes an integer:

    $ /usr/bin/foo -n 4x
    Usage: foo [options]

    foo: error: option -n: invalid integer value: '4x'

Or, where the user fails to pass a value at all:

    $ /usr/bin/foo -n
    Usage: foo [options]

    foo: error: -n option requires an argument

*note optparse: 128.-generated error messages take care always to
mention the option involved in the error; be sure to do the same when
calling `OptionParser.error()' from your application code.

  If *note optparse: 128.'s default error-handling behaviour does not
suit your needs, you'll need to subclass OptionParser and override its
`exit()' and/or `error()' methods.


File: python.info,  Node: Putting it all together,  Prev: How optparse handles errors,  Up: Tutorial

5.15.5.15 Putting it all together
.................................

Here's what *note optparse: 128.-based scripts usually look like:

    from optparse import OptionParser
    [...]
    def main():
        usage = "usage: %prog [options] arg"
        parser = OptionParser(usage)
        parser.add_option("-f", "--file", dest="filename",
                          help="read data from FILENAME")
        parser.add_option("-v", "--verbose",
                          action="store_true", dest="verbose")
        parser.add_option("-q", "--quiet",
                          action="store_false", dest="verbose")
        [...]
        (options, args) = parser.parse_args()
        if len(args) != 1:
            parser.error("incorrect number of arguments")
        if options.verbose:
            print "reading %s..." % options.filename
        [...]

    if __name__ == "__main__":
        main()



File: python.info,  Node: Reference Guide,  Next: Option Callbacks,  Prev: Tutorial,  Up: optparse --- Parser for command line options

5.15.5.16 Reference Guide
.........................

* Menu:

* Creating the parser::
* Populating the parser::
* Defining options::
* Option attributes::
* Standard option actions::
* Standard option types::
* Parsing arguments: Parsing arguments<2>.
* Querying and manipulating your option parser::
* Conflicts between options::
* Cleanup::
* Other methods::


File: python.info,  Node: Creating the parser,  Next: Populating the parser,  Up: Reference Guide

5.15.5.17 Creating the parser
.............................

The first step in using *note optparse: 128. is to create an
OptionParser instance.

 -- Class: optparse.OptionParser (...)
     The OptionParser constructor has no required arguments, but a
     number of optional keyword arguments.  You should always pass them
     as keyword arguments, i.e. do not rely on the order in which the
     arguments are declared.

    `usage' (default: `"%prog [options]"')
          The usage summary to print when your program is run
          incorrectly or with a help option.  When *note optparse: 128.
          prints the usage string, it expands `%prog' to
          `os.path.basename(sys.argv[0])' (or to `prog' if you passed
          that keyword argument).  To suppress a usage message, pass the
          special value `optparse.SUPPRESS_USAGE'.

    `option_list' (default: `[]')
          A list of Option objects to populate the parser with.  The
          options in `option_list' are added after any options in
          `standard_option_list' (a class attribute that may be set by
          OptionParser subclasses), but before any version or help
          options. Deprecated; use *note add_option(): 11e5. after
          creating the parser instead.

    `option_class' (default: optparse.Option)
          Class to use when adding options to the parser in *note
          add_option(): 11e5.

    `version' (default: `None')
          A version string to print when the user supplies a version
          option. If you supply a true value for `version', *note
          optparse: 128. automatically adds a version option with the
          single option string `--version'.  The substring `%prog' is
          expanded the same as for `usage'.

    `conflict_handler' (default: `"error"')
          Specifies what to do when options with conflicting option
          strings are added to the parser; see section *note Conflicts
          between options: 1215.

    `description' (default: `None')
          A paragraph of text giving a brief overview of your program.
          *note optparse: 128. reformats this paragraph to fit the
          current terminal width and prints it when the user requests
          help (after `usage', but before the list of options).

    `formatter' (default: a new `IndentedHelpFormatter')
          An instance of optparse.HelpFormatter that will be used for
          printing help text.  *note optparse: 128. provides two
          concrete classes for this purpose: IndentedHelpFormatter and
          TitledHelpFormatter.

    `add_help_option' (default: `True')
          If true, *note optparse: 128. will add a help option (with
          option strings `-h' and `--help') to the parser.

    `prog'
          The string to use when expanding `%prog' in `usage' and
          `version' instead of `os.path.basename(sys.argv[0])'.

    `epilog' (default: `None')
          A paragraph of help text to print after the option help.


File: python.info,  Node: Populating the parser,  Next: Defining options,  Prev: Creating the parser,  Up: Reference Guide

5.15.5.18 Populating the parser
...............................

There are several ways to populate the parser with options.  The
preferred way is by using *note OptionParser.add_option(): 11e5, as
shown in section *note Tutorial: 11f1.  `add_option()' can be called in
one of two ways:

   * pass it an Option instance (as returned by `make_option()')

   * pass it any combination of positional and keyword arguments that
     are acceptable to `make_option()' (i.e., to the Option
     constructor), and it will create the Option instance for you

  The other alternative is to pass a list of pre-constructed Option
instances to the OptionParser constructor, as in:

    option_list = [
        make_option("-f", "--filename",
                    action="store", type="string", dest="filename"),
        make_option("-q", "--quiet",
                    action="store_false", dest="verbose"),
        ]
    parser = OptionParser(option_list=option_list)

(`make_option()' is a factory function for creating Option instances;
currently it is an alias for the Option constructor.  A future version
of *note optparse: 128. may split Option into several classes, and
`make_option()' will pick the right class to instantiate.  Do not
instantiate Option directly.)


File: python.info,  Node: Defining options,  Next: Option attributes,  Prev: Populating the parser,  Up: Reference Guide

5.15.5.19 Defining options
..........................

Each Option instance represents a set of synonymous command-line option
strings, e.g. `-f' and `--file'.  You can specify any number of short or
long option strings, but you must specify at least one overall option
string.

  The canonical way to create an `Option' instance is with the
`add_option()' method of *note OptionParser: 11e8.

 -- Method: OptionParser.add_option (opt_str[, ...], attr=value, ...)
     To define an option with only a short option string:

         parser.add_option("-f", attr=value, ...)

     And to define an option with only a long option string:

         parser.add_option("--foo", attr=value, ...)

     The keyword arguments define attributes of the new Option object.
     The most important option attribute is *note action: 11f3, and it
     largely determines which other attributes are relevant or
     required.  If you pass irrelevant option attributes, or fail to
     pass required ones, *note optparse: 128.  raises an `OptionError'
     exception explaining your mistake.

     An option's _action_ determines what *note optparse: 128. does
     when it encounters this option on the command-line.  The standard
     option actions hard-coded into *note optparse: 128. are:

    `"store"'
          store this option's argument (default)

    `"store_const"'
          store a constant value

    `"store_true"'
          store a true value

    `"store_false"'
          store a false value

    `"append"'
          append this option's argument to a list

    `"append_const"'
          append a constant value to a list

    `"count"'
          increment a counter by one

    `"callback"'
          call a specified function

    `"help"'
          print a usage message including all options and the
          documentation for them

     (If you don't supply an action, the default is `"store"'.  For
     this action, you may also supply *note type: 11f4. and *note dest:
     11f5. option attributes; see *note Standard option actions: 121a.)

  As you can see, most actions involve storing or updating a value
somewhere.  *note optparse: 128. always creates a special object for
this, conventionally called `options' (it happens to be an instance of
`optparse.Values').  Option arguments (and various other values) are
stored as attributes of this object, according to the *note dest: 11f5.
(destination) option attribute.

  For example, when you call

    parser.parse_args()

one of the first things *note optparse: 128. does is create the
`options' object:

    options = Values()

If one of the options in this parser is defined with

    parser.add_option("-f", "--file", action="store", type="string", dest="filename")

and the command-line being parsed includes any of the following:

    -ffoo
    -f foo
    --file=foo
    --file foo

then *note optparse: 128, on seeing this option, will do the equivalent
of

    options.filename = "foo"

The *note type: 11f4. and *note dest: 11f5. option attributes are almost
as important as *note action: 11f3, but *note action: 11f3. is the only
one that makes sense for _all_ options.


File: python.info,  Node: Option attributes,  Next: Standard option actions,  Prev: Defining options,  Up: Reference Guide

5.15.5.20 Option attributes
...........................

The following option attributes may be passed as keyword arguments to
*note OptionParser.add_option(): 11e5.  If you pass an option attribute
that is not relevant to a particular option, or fail to pass a required
option attribute, *note optparse: 128. raises `OptionError'.

 -- Attribute: Option.action
     (default: `"store"')

     Determines *note optparse: 128.'s behaviour when this option is
     seen on the command line; the available options are documented
     *note here: 121a.

 -- Attribute: Option.type
     (default: `"string"')

     The argument type expected by this option (e.g., `"string"' or
     `"int"'); the available option types are documented *note here:
     121d.

 -- Attribute: Option.dest
     (default: derived from option strings)

     If the option's action implies writing or modifying a value
     somewhere, this tells *note optparse: 128. where to write it:
     *note dest: 11f5. names an attribute of the `options' object that
     *note optparse: 128. builds as it parses the command line.

 -- Attribute: Option.default
     The value to use for this option's destination if the option is
     not seen on the command line.  See also *note
     OptionParser.set_defaults(): 121f.

 -- Attribute: Option.nargs
     (default: 1)

     How many arguments of type *note type: 11f4. should be consumed
     when this option is seen.  If > 1, *note optparse: 128. will store
     a tuple of values to *note dest: 11f5.

 -- Attribute: Option.const
     For actions that store a constant value, the constant value to
     store.

 -- Attribute: Option.choices
     For options of type `"choice"', the list of strings the user may
     choose from.

 -- Attribute: Option.callback
     For options with action `"callback"', the callable to call when
     this option is seen.  See section *note Option Callbacks: 1201.
     for detail on the arguments passed to the callable.

 -- Attribute: Option.callback_args
 -- Attribute: Option.callback_kwargs
     Additional positional and keyword arguments to pass to `callback'
     after the four standard callback arguments.

 -- Attribute: Option.help
     Help text to print for this option when listing all available
     options after the user supplies a *note help: 11f6. option (such
     as `--help').  If no help text is supplied, the option will be
     listed without help text.  To hide this option, use the special
     value `optparse.SUPPRESS_HELP'.

 -- Attribute: Option.metavar
     (default: derived from option strings)

     Stand-in for the option argument(s) to use when printing help
     text.  See section *note Tutorial: 11f1. for an example.


File: python.info,  Node: Standard option actions,  Next: Standard option types,  Prev: Option attributes,  Up: Reference Guide

5.15.5.21 Standard option actions
.................................

The various option actions all have slightly different requirements and
effects.  Most actions have several relevant option attributes which
you may specify to guide *note optparse: 128.'s behaviour; a few have
required attributes, which you must specify for any option using that
action.

   * `"store"' [relevant: *note type: 11f4, *note dest: 11f5, *note
     nargs: 1220, *note choices: 1222.]

     The option must be followed by an argument, which is converted to
     a value according to *note type: 11f4. and stored in *note dest:
     11f5.  If *note nargs: 1220. > 1, multiple arguments will be
     consumed from the command line; all will be converted according to
     *note type: 11f4. and stored to *note dest: 11f5. as a tuple.  See
     the *note Standard option types: 121d. section.

     If *note choices: 1222. is supplied (a list or tuple of strings),
     the type defaults to `"choice"'.

     If *note type: 11f4. is not supplied, it defaults to `"string"'.

     If *note dest: 11f5. is not supplied, *note optparse: 128. derives
     a destination from the first long option string (e.g., `--foo-bar'
     implies `foo_bar'). If there are no long option strings, *note
     optparse: 128. derives a destination from the first short option
     string (e.g., `-f' implies `f').

     Example:

         parser.add_option("-f")
         parser.add_option("-p", type="float", nargs=3, dest="point")

     As it parses the command line

         -f foo.txt -p 1 -3.5 4 -fbar.txt

     *note optparse: 128. will set

         options.f = "foo.txt"
         options.point = (1.0, -3.5, 4.0)
         options.f = "bar.txt"


   * `"store_const"' [required: *note const: 1221.; relevant: *note
     dest: 11f5.]

     The value *note const: 1221. is stored in *note dest: 11f5.

     Example:

         parser.add_option("-q", "--quiet",
                           action="store_const", const=0, dest="verbose")
         parser.add_option("-v", "--verbose",
                           action="store_const", const=1, dest="verbose")
         parser.add_option("--noisy",
                           action="store_const", const=2, dest="verbose")

     If `--noisy' is seen, *note optparse: 128. will set

         options.verbose = 2


   * `"store_true"' [relevant: *note dest: 11f5.]

     A special case of `"store_const"' that stores a true value to
     *note dest: 11f5.

   * `"store_false"' [relevant: *note dest: 11f5.]

     Like `"store_true"', but stores a false value.

     Example:

         parser.add_option("--clobber", action="store_true", dest="clobber")
         parser.add_option("--no-clobber", action="store_false", dest="clobber")


   * `"append"' [relevant: *note type: 11f4, *note dest: 11f5, *note
     nargs: 1220, *note choices: 1222.]

     The option must be followed by an argument, which is appended to
     the list in *note dest: 11f5.  If no default value for *note dest:
     11f5. is supplied, an empty list is automatically created when
     *note optparse: 128. first encounters this option on the
     command-line.  If *note nargs: 1220. > 1, multiple arguments are
     consumed, and a tuple of length *note nargs: 1220.  is appended to
     *note dest: 11f5.

     The defaults for *note type: 11f4. and *note dest: 11f5. are the
     same as for the `"store"' action.

     Example:

         parser.add_option("-t", "--tracks", action="append", type="int")

     If `-t3' is seen on the command-line, *note optparse: 128. does
     the equivalent of:

         options.tracks = []
         options.tracks.append(int("3"))

     If, a little later on, `--tracks=4' is seen, it does:

         options.tracks.append(int("4"))


   * `"append_const"' [required: *note const: 1221.; relevant: *note
     dest: 11f5.]

     Like `"store_const"', but the value *note const: 1221. is appended
     to *note dest: 11f5.; as with `"append"', *note dest: 11f5.
     defaults to `None', and an empty list is automatically created the
     first time the option is encountered.

   * `"count"' [relevant: *note dest: 11f5.]

     Increment the integer stored at *note dest: 11f5.  If no default
     value is supplied, *note dest: 11f5. is set to zero before being
     incremented the first time.

     Example:

         parser.add_option("-v", action="count", dest="verbosity")

     The first time `-v' is seen on the command line, *note optparse:
     128. does the equivalent of:

         options.verbosity = 0
         options.verbosity += 1

     Every subsequent occurrence of `-v' results in

         options.verbosity += 1


   * `"callback"' [required: *note callback: 1223.; relevant: *note
     type: 11f4, *note nargs: 1220, *note callback_args: 1224, *note
     callback_kwargs: 1225.]

     Call the function specified by *note callback: 1223, which is
     called as

         func(option, opt_str, value, parser, *args, **kwargs)

     See section *note Option Callbacks: 1201. for more detail.

   * `"help"'

     Prints a complete help message for all the options in the current
     option parser.  The help message is constructed from the `usage'
     string passed to OptionParser's constructor and the *note help:
     11f6. string passed to every option.

     If no *note help: 11f6. string is supplied for an option, it will
     still be listed in the help message.  To omit an option entirely,
     use the special value `optparse.SUPPRESS_HELP'.

     *note optparse: 128. automatically adds a *note help: 11f6. option
     to all OptionParsers, so you do not normally need to create one.

     Example:

         from optparse import OptionParser, SUPPRESS_HELP

         # usually, a help option is added automatically, but that can
         # be suppressed using the add_help_option argument
         parser = OptionParser(add_help_option=False)

         parser.add_option("-h", "--help", action="help")
         parser.add_option("-v", action="store_true", dest="verbose",
                           help="Be moderately verbose")
         parser.add_option("--file", dest="filename",
                           help="Input file to read data from")
         parser.add_option("--secret", help=SUPPRESS_HELP)

     If *note optparse: 128. sees either `-h' or `--help' on the
     command line, it will print something like the following help
     message to stdout (assuming `sys.argv[0]' is `"foo.py"'):

         Usage: foo.py [options]

         Options:
           -h, --help        Show this help message and exit
           -v                Be moderately verbose
           --file=FILENAME   Input file to read data from

     After printing the help message, *note optparse: 128. terminates
     your process with `sys.exit(0)'.

   * `"version"'

     Prints the version number supplied to the OptionParser to stdout
     and exits.  The version number is actually formatted and printed
     by the `print_version()' method of OptionParser.  Generally only
     relevant if the `version' argument is supplied to the OptionParser
     constructor.  As with *note help: 11f6. options, you will rarely
     create `version' options, since *note optparse: 128. automatically
     adds them when needed.


File: python.info,  Node: Standard option types,  Next: Parsing arguments<2>,  Prev: Standard option actions,  Up: Reference Guide

5.15.5.22 Standard option types
...............................

*note optparse: 128. has six built-in option types: `"string"', `"int"',
`"long"', `"choice"', `"float"' and `"complex"'.  If you need to add new
option types, see section *note Extending optparse: 11f9.

  Arguments to string options are not checked or converted in any way:
the text on the command line is stored in the destination (or passed to
the callback) as-is.

  Integer arguments (type `"int"' or `"long"') are parsed as follows:

   * if the number starts with `0x', it is parsed as a hexadecimal
     number

   * if the number starts with `0', it is parsed as an octal number

   * if the number starts with `0b', it is parsed as a binary number

   * otherwise, the number is parsed as a decimal number

  The conversion is done by calling either *note int(): 1ef. or *note
long(): 1f0. with the appropriate base (2, 8, 10, or 16).  If this
fails, so will *note optparse: 128, although with a more useful error
message.

  `"float"' and `"complex"' option arguments are converted directly with
*note float(): 1e8. and *note complex(): 1e9, with similar
error-handling.

  `"choice"' options are a subtype of `"string"' options.  The *note
choices: 1222. option attribute (a sequence of strings) defines the set
of allowed option arguments.  `optparse.check_choice()' compares
user-supplied option arguments against this master list and raises
`OptionValueError' if an invalid string is given.


File: python.info,  Node: Parsing arguments<2>,  Next: Querying and manipulating your option parser,  Prev: Standard option types,  Up: Reference Guide

5.15.5.23 Parsing arguments
...........................

The whole point of creating and populating an OptionParser is to call
its `parse_args()' method:

    (options, args) = parser.parse_args(args=None, values=None)

where the input parameters are

`args'
     the list of arguments to process (default: `sys.argv[1:]')

`values'
     a `optparse.Values' object to store option arguments in (default: a
     new instance of `Values') - if you give an existing object, the
     option defaults will not be initialized on it

  and the return values are

`options'
     the same object that was passed in as `values', or the
     optparse.Values instance created by *note optparse: 128.

`args'
     the leftover positional arguments after all options have been
     processed

  The most common usage is to supply neither keyword argument.  If you
supply `values', it will be modified with repeated *note setattr():
846. calls (roughly one for every option argument stored to an option
destination) and returned by `parse_args()'.

  If `parse_args()' encounters any errors in the argument list, it
calls the OptionParser's `error()' method with an appropriate end-user
error message.  This ultimately terminates your process with an exit
status of 2 (the traditional Unix exit status for command-line errors).


File: python.info,  Node: Querying and manipulating your option parser,  Next: Conflicts between options,  Prev: Parsing arguments<2>,  Up: Reference Guide

5.15.5.24 Querying and manipulating your option parser
......................................................

The default behavior of the option parser can be customized slightly,
and you can also poke around your option parser and see what's there.
OptionParser provides several methods to help you out:

 -- Method: OptionParser.disable_interspersed_args ()
     Set parsing to stop on the first non-option.  For example, if `-a'
     and `-b' are both simple options that take no arguments, *note
     optparse: 128.  normally accepts this syntax:

         prog -a arg1 -b arg2

     and treats it as equivalent to

         prog -a -b arg1 arg2

     To disable this feature, call *note disable_interspersed_args():
     122d.  This restores traditional Unix syntax, where option parsing
     stops with the first non-option argument.

     Use this if you have a command processor which runs another
     command which has options of its own and you want to make sure
     these options don't get confused.  For example, each command might
     have a different set of options.

 -- Method: OptionParser.enable_interspersed_args ()
     Set parsing to not stop on the first non-option, allowing
     interspersing switches with command arguments.  This is the
     default behavior.

 -- Method: OptionParser.get_option (opt_str)
     Returns the Option instance with the option string _opt_str_, or
     `None' if no options have that option string.

 -- Method: OptionParser.has_option (opt_str)
     Return true if the OptionParser has an option with option string
     _opt_str_ (e.g., `-q' or `--verbose').

 -- Method: OptionParser.remove_option (opt_str)
     If the *note OptionParser: 11e8. has an option corresponding to
     _opt_str_, that option is removed.  If that option provided any
     other option strings, all of those option strings become invalid.
     If _opt_str_ does not occur in any option belonging to this *note
     OptionParser: 11e8, raises *note ValueError: 233.


File: python.info,  Node: Conflicts between options,  Next: Cleanup,  Prev: Querying and manipulating your option parser,  Up: Reference Guide

5.15.5.25 Conflicts between options
...................................

If you're not careful, it's easy to define options with conflicting
option strings:

    parser.add_option("-n", "--dry-run", ...)
    [...]
    parser.add_option("-n", "--noisy", ...)

(This is particularly true if you've defined your own OptionParser
subclass with some standard options.)

  Every time you add an option, *note optparse: 128. checks for
conflicts with existing options.  If it finds any, it invokes the
current conflict-handling mechanism.  You can set the conflict-handling
mechanism either in the constructor:

    parser = OptionParser(..., conflict_handler=handler)

or with a separate call:

    parser.set_conflict_handler(handler)

The available conflict handlers are:

    `"error"' (default)
          assume option conflicts are a programming error and raise
          `OptionConflictError'

    `"resolve"'
          resolve option conflicts intelligently (see below)

  As an example, let's define an *note OptionParser: 11e8. that
resolves conflicts intelligently and add conflicting options to it:

    parser = OptionParser(conflict_handler="resolve")
    parser.add_option("-n", "--dry-run", ..., help="do no harm")
    parser.add_option("-n", "--noisy", ..., help="be noisy")

At this point, *note optparse: 128. detects that a previously-added
option is already using the `-n' option string.  Since
`conflict_handler' is `"resolve"', it resolves the situation by
removing `-n' from the earlier option's list of option strings.  Now
`--dry-run' is the only way for the user to activate that option.  If
the user asks for help, the help message will reflect that:

    Options:
      --dry-run     do no harm
      [...]
      -n, --noisy   be noisy

It's possible to whittle away the option strings for a previously-added
option until there are none left, and the user has no way of invoking
that option from the command-line.  In that case, *note optparse: 128.
removes that option completely, so it doesn't show up in help text or
anywhere else. Carrying on with our existing OptionParser:

    parser.add_option("--dry-run", ..., help="new dry-run option")

At this point, the original `-n'/`--dry-run' option is no longer
accessible, so *note optparse: 128. removes it, leaving this help text:

    Options:
      [...]
      -n, --noisy   be noisy
      --dry-run     new dry-run option



File: python.info,  Node: Cleanup,  Next: Other methods,  Prev: Conflicts between options,  Up: Reference Guide

5.15.5.26 Cleanup
.................

OptionParser instances have several cyclic references.  This should not
be a problem for Python's garbage collector, but you may wish to break
the cyclic references explicitly by calling `destroy()' on your
OptionParser once you are done with it.  This is particularly useful in
long-running applications where large object graphs are reachable from
your OptionParser.


File: python.info,  Node: Other methods,  Prev: Cleanup,  Up: Reference Guide

5.15.5.27 Other methods
.......................

OptionParser supports several other public methods:

 -- Method: OptionParser.set_usage (usage)
     Set the usage string according to the rules described above for
     the `usage' constructor keyword argument.  Passing `None' sets the
     default usage string; use `optparse.SUPPRESS_USAGE' to suppress a
     usage message.

 -- Method: OptionParser.print_usage (file=None)
     Print the usage message for the current program (`self.usage') to
     _file_ (default stdout).  Any occurrence of the string `%prog' in
     `self.usage' is replaced with the name of the current program.
     Does nothing if `self.usage' is empty or not defined.

 -- Method: OptionParser.get_usage ()
     Same as *note print_usage(): 120c. but returns the usage string
     instead of printing it.

 -- Method: OptionParser.set_defaults (dest=value, ...)
     Set default values for several option destinations at once.  Using
     *note set_defaults(): 121f. is the preferred way to set default
     values for options, since multiple options can share the same
     destination.  For example, if several "mode" options all set the
     same destination, any one of them can set the default, and the
     last one wins:

         parser.add_option("--advanced", action="store_const",
                           dest="mode", const="advanced",
                           default="novice")    # overridden below
         parser.add_option("--novice", action="store_const",
                           dest="mode", const="novice",
                           default="advanced")  # overrides above setting

     To avoid this confusion, use *note set_defaults(): 121f.:

         parser.set_defaults(mode="advanced")
         parser.add_option("--advanced", action="store_const",
                           dest="mode", const="advanced")
         parser.add_option("--novice", action="store_const",
                           dest="mode", const="novice")




File: python.info,  Node: Option Callbacks,  Next: Extending optparse,  Prev: Reference Guide,  Up: optparse --- Parser for command line options

5.15.5.28 Option Callbacks
..........................

When *note optparse: 128.'s built-in actions and types aren't quite
enough for your needs, you have two choices: extend *note optparse:
128. or define a callback option.  Extending *note optparse: 128. is
more general, but overkill for a lot of simple cases.  Quite often a
simple callback is all you need.

  There are two steps to defining a callback option:

   * define the option itself using the `"callback"' action

   * write the callback; this is a function (or method) that takes at
     least four arguments, as described below

* Menu:

* Defining a callback option::
* How callbacks are called::
* Raising errors in a callback::
* Callback example 1; trivial callback: Callback example 1 trivial callback.
* Callback example 2; check option order: Callback example 2 check option order.
* Callback example 3; check option order (generalized): Callback example 3 check option order generalized.
* Callback example 4; check arbitrary condition: Callback example 4 check arbitrary condition.
* Callback example 5; fixed arguments: Callback example 5 fixed arguments.
* Callback example 6; variable arguments: Callback example 6 variable arguments.


File: python.info,  Node: Defining a callback option,  Next: How callbacks are called,  Up: Option Callbacks

5.15.5.29 Defining a callback option
....................................

As always, the easiest way to define a callback option is by using the
*note OptionParser.add_option(): 11e5. method.  Apart from *note
action: 11f3, the only option attribute you must specify is `callback',
the function to call:

    parser.add_option("-c", action="callback", callback=my_callback)

`callback' is a function (or other callable object), so you must have
already defined `my_callback()' when you create this callback option.
In this simple case, *note optparse: 128. doesn't even know if `-c'
takes any arguments, which usually means that the option takes no
arguments--the mere presence of `-c' on the command-line is all it
needs to know.  In some circumstances, though, you might want your
callback to consume an arbitrary number of command-line arguments.
This is where writing callbacks gets tricky; it's covered later in this
section.

  *note optparse: 128. always passes four particular arguments to your
callback, and it will only pass additional arguments if you specify
them via *note callback_args: 1224. and *note callback_kwargs: 1225.
Thus, the minimal callback function signature is:

    def my_callback(option, opt, value, parser):

The four arguments to a callback are described below.

  There are several other option attributes that you can supply when
you define a callback option:

*note type: 11f4.
     has its usual meaning: as with the `"store"' or `"append"'
     actions, it instructs *note optparse: 128. to consume one argument
     and convert it to *note type: 11f4.  Rather than storing the
     converted value(s) anywhere, though, *note optparse: 128. passes
     it to your callback function.

*note nargs: 1220.
     also has its usual meaning: if it is supplied and > 1, *note
     optparse: 128. will consume *note nargs: 1220. arguments, each of
     which must be convertible to *note type: 11f4.  It then passes a
     tuple of converted values to your callback.

*note callback_args: 1224.
     a tuple of extra positional arguments to pass to the callback

*note callback_kwargs: 1225.
     a dictionary of extra keyword arguments to pass to the callback


File: python.info,  Node: How callbacks are called,  Next: Raising errors in a callback,  Prev: Defining a callback option,  Up: Option Callbacks

5.15.5.30 How callbacks are called
..................................

All callbacks are called as follows:

    func(option, opt_str, value, parser, *args, **kwargs)

where

`option'
     is the Option instance that's calling the callback

`opt_str'
     is the option string seen on the command-line that's triggering
     the callback.  (If an abbreviated long option was used, `opt_str'
     will be the full, canonical option string--e.g. if the user puts
     `--foo' on the command-line as an abbreviation for `--foobar',
     then `opt_str' will be `"--foobar"'.)

`value'
     is the argument to this option seen on the command-line.  *note
     optparse: 128. will only expect an argument if *note type: 11f4.
     is set; the type of `value' will be the type implied by the
     option's type.  If *note type: 11f4. for this option is `None' (no
     argument expected), then `value' will be `None'.  If *note nargs:
     1220.  > 1, `value' will be a tuple of values of the appropriate
     type.

`parser'
     is the OptionParser instance driving the whole thing, mainly
     useful because you can access some other interesting data through
     its instance attributes:

    `parser.largs'
          the current list of leftover arguments, ie. arguments that
          have been consumed but are neither options nor option
          arguments. Feel free to modify `parser.largs', e.g. by adding
          more arguments to it.  (This list will become `args', the
          second return value of `parse_args()'.)

    `parser.rargs'
          the current list of remaining arguments, ie. with `opt_str'
          and `value' (if applicable) removed, and only the arguments
          following them still there.  Feel free to modify
          `parser.rargs', e.g. by consuming more arguments.

    `parser.values'
          the object where option values are by default stored (an
          instance of optparse.OptionValues).  This lets callbacks use
          the same mechanism as the rest of *note optparse: 128. for
          storing option values; you don't need to mess around with
          globals or closures.  You can also access or modify the
          value(s) of any options already encountered on the
          command-line.

`args'
     is a tuple of arbitrary positional arguments supplied via the
     *note callback_args: 1224. option attribute.

`kwargs'
     is a dictionary of arbitrary keyword arguments supplied via *note
     callback_kwargs: 1225.


File: python.info,  Node: Raising errors in a callback,  Next: Callback example 1 trivial callback,  Prev: How callbacks are called,  Up: Option Callbacks

5.15.5.31 Raising errors in a callback
......................................

The callback function should raise `OptionValueError' if there are any
problems with the option or its argument(s).  *note optparse: 128.
catches this and terminates the program, printing the error message you
supply to stderr.  Your message should be clear, concise, accurate, and
mention the option at fault.  Otherwise, the user will have a hard time
figuring out what he did wrong.


File: python.info,  Node: Callback example 1 trivial callback,  Next: Callback example 2 check option order,  Prev: Raising errors in a callback,  Up: Option Callbacks

5.15.5.32 Callback example 1: trivial callback
..............................................

Here's an example of a callback option that takes no arguments, and
simply records that the option was seen:

    def record_foo_seen(option, opt_str, value, parser):
        parser.values.saw_foo = True

    parser.add_option("--foo", action="callback", callback=record_foo_seen)

Of course, you could do that with the `"store_true"' action.


File: python.info,  Node: Callback example 2 check option order,  Next: Callback example 3 check option order generalized,  Prev: Callback example 1 trivial callback,  Up: Option Callbacks

5.15.5.33 Callback example 2: check option order
................................................

Here's a slightly more interesting example: record the fact that `-a' is
seen, but blow up if it comes after `-b' in the command-line.

    def check_order(option, opt_str, value, parser):
        if parser.values.b:
            raise OptionValueError("can't use -a after -b")
        parser.values.a = 1
    [...]
    parser.add_option("-a", action="callback", callback=check_order)
    parser.add_option("-b", action="store_true", dest="b")



File: python.info,  Node: Callback example 3 check option order generalized,  Next: Callback example 4 check arbitrary condition,  Prev: Callback example 2 check option order,  Up: Option Callbacks

5.15.5.34 Callback example 3: check option order (generalized)
..............................................................

If you want to re-use this callback for several similar options (set a
flag, but blow up if `-b' has already been seen), it needs a bit of
work: the error message and the flag that it sets must be generalized.

    def check_order(option, opt_str, value, parser):
        if parser.values.b:
            raise OptionValueError("can't use %s after -b" % opt_str)
        setattr(parser.values, option.dest, 1)
    [...]
    parser.add_option("-a", action="callback", callback=check_order, dest='a')
    parser.add_option("-b", action="store_true", dest="b")
    parser.add_option("-c", action="callback", callback=check_order, dest='c')



File: python.info,  Node: Callback example 4 check arbitrary condition,  Next: Callback example 5 fixed arguments,  Prev: Callback example 3 check option order generalized,  Up: Option Callbacks

5.15.5.35 Callback example 4: check arbitrary condition
.......................................................

Of course, you could put any condition in there--you're not limited to
checking the values of already-defined options.  For example, if you
have options that should not be called when the moon is full, all you
have to do is this:

    def check_moon(option, opt_str, value, parser):
        if is_moon_full():
            raise OptionValueError("%s option invalid when moon is full"
                                   % opt_str)
        setattr(parser.values, option.dest, 1)
    [...]
    parser.add_option("--foo",
                      action="callback", callback=check_moon, dest="foo")

(The definition of `is_moon_full()' is left as an exercise for the
reader.)


File: python.info,  Node: Callback example 5 fixed arguments,  Next: Callback example 6 variable arguments,  Prev: Callback example 4 check arbitrary condition,  Up: Option Callbacks

5.15.5.36 Callback example 5: fixed arguments
.............................................

Things get slightly more interesting when you define callback options
that take a fixed number of arguments.  Specifying that a callback
option takes arguments is similar to defining a `"store"' or `"append"'
option: if you define *note type: 11f4, then the option takes one
argument that must be convertible to that type; if you further define
*note nargs: 1220, then the option takes *note nargs: 1220. arguments.

  Here's an example that just emulates the standard `"store"' action:

    def store_value(option, opt_str, value, parser):
        setattr(parser.values, option.dest, value)
    [...]
    parser.add_option("--foo",
                      action="callback", callback=store_value,
                      type="int", nargs=3, dest="foo")

Note that *note optparse: 128. takes care of consuming 3 arguments and
converting them to integers for you; all you have to do is store them.
(Or whatever; obviously you don't need a callback for this example.)


File: python.info,  Node: Callback example 6 variable arguments,  Prev: Callback example 5 fixed arguments,  Up: Option Callbacks

5.15.5.37 Callback example 6: variable arguments
................................................

Things get hairy when you want an option to take a variable number of
arguments.  For this case, you must write a callback, as *note
optparse: 128. doesn't provide any built-in capabilities for it.  And
you have to deal with certain intricacies of conventional Unix
command-line parsing that *note optparse: 128. normally handles for
you.  In particular, callbacks should implement the conventional rules
for bare `--' and `-' arguments:

   * either `--' or `-' can be option arguments

   * bare `--' (if not the argument to some option): halt command-line
     processing and discard the `--'

   * bare `-' (if not the argument to some option): halt command-line
     processing but keep the `-' (append it to `parser.largs')

  If you want an option that takes a variable number of arguments,
there are several subtle, tricky issues to worry about.  The exact
implementation you choose will be based on which trade-offs you're
willing to make for your application (which is why *note optparse: 128.
doesn't support this sort of thing directly).

  Nevertheless, here's a stab at a callback for an option with variable
arguments:

     def vararg_callback(option, opt_str, value, parser):
         assert value is None
         value = []

         def floatable(str):
             try:
                 float(str)
                 return True
             except ValueError:
                 return False

         for arg in parser.rargs:
             # stop on --foo like options
             if arg[:2] == "--" and len(arg) > 2:
                 break
             # stop on -a, but not on -3 or -3.0
             if arg[:1] == "-" and len(arg) > 1 and not floatable(arg):
                 break
             value.append(arg)

         del parser.rargs[:len(value)]
         setattr(parser.values, option.dest, value)

    [...]
    parser.add_option("-c", "--callback", dest="vararg_attr",
                      action="callback", callback=vararg_callback)



File: python.info,  Node: Extending optparse,  Prev: Option Callbacks,  Up: optparse --- Parser for command line options

5.15.5.38 Extending `optparse'
..............................

Since the two major controlling factors in how *note optparse: 128.
interprets command-line options are the action and type of each option,
the most likely direction of extension is to add new actions and new
types.

* Menu:

* Adding new types::
* Adding new actions::


File: python.info,  Node: Adding new types,  Next: Adding new actions,  Up: Extending optparse

5.15.5.39 Adding new types
..........................

To add new types, you need to define your own subclass of *note
optparse: 128.'s `Option' class.  This class has a couple of attributes
that define *note optparse: 128.'s types: *note TYPES: 124f. and *note
TYPE_CHECKER: 1250.

 -- Attribute: Option.TYPES
     A tuple of type names; in your subclass, simply define a new tuple
     *note TYPES: 124f. that builds on the standard one.

 -- Attribute: Option.TYPE_CHECKER
     A dictionary mapping type names to type-checking functions.  A
     type-checking function has the following signature:

         def check_mytype(option, opt, value)

     where `option' is an `Option' instance, `opt' is an option string
     (e.g., `-f'), and `value' is the string from the command line that
     must be checked and converted to your desired type.
     `check_mytype()' should return an object of the hypothetical type
     `mytype'.  The value returned by a type-checking function will
     wind up in the OptionValues instance returned by
     `OptionParser.parse_args()', or be passed to a callback as the
     `value' parameter.

     Your type-checking function should raise `OptionValueError' if it
     encounters any problems.  `OptionValueError' takes a single string
     argument, which is passed as-is to *note OptionParser: 11e8.'s
     `error()' method, which in turn prepends the program name and the
     string `"error:"' and prints everything to stderr before
     terminating the process.

  Here's a silly example that demonstrates adding a `"complex"' option
type to parse Python-style complex numbers on the command line.  (This
is even sillier than it used to be, because *note optparse: 128. 1.3
added built-in support for complex numbers, but never mind.)

  First, the necessary imports:

    from copy import copy
    from optparse import Option, OptionValueError

You need to define your type-checker first, since it's referred to
later (in the *note TYPE_CHECKER: 1250. class attribute of your Option
subclass):

    def check_complex(option, opt, value):
        try:
            return complex(value)
        except ValueError:
            raise OptionValueError(
                "option %s: invalid complex value: %r" % (opt, value))

Finally, the Option subclass:

    class MyOption (Option):
        TYPES = Option.TYPES + ("complex",)
        TYPE_CHECKER = copy(Option.TYPE_CHECKER)
        TYPE_CHECKER["complex"] = check_complex

(If we didn't make a *note copy(): 71. of *note Option.TYPE_CHECKER:
1250, we would end up modifying the *note TYPE_CHECKER: 1250. attribute
of *note optparse: 128.'s Option class.  This being Python, nothing
stops you from doing that except good manners and common sense.)

  That's it!  Now you can write a script that uses the new option type
just like any other *note optparse: 128.-based script, except you have
to instruct your OptionParser to use MyOption instead of Option:

    parser = OptionParser(option_class=MyOption)
    parser.add_option("-c", type="complex")

Alternately, you can build your own option list and pass it to
OptionParser; if you don't use `add_option()' in the above way, you
don't need to tell OptionParser which option class to use:

    option_list = [MyOption("-c", action="store", type="complex", dest="c")]
    parser = OptionParser(option_list=option_list)



File: python.info,  Node: Adding new actions,  Prev: Adding new types,  Up: Extending optparse

5.15.5.40 Adding new actions
............................

Adding new actions is a bit trickier, because you have to understand
that *note optparse: 128. has a couple of classifications for actions:

"store" actions
     actions that result in *note optparse: 128. storing a value to an
     attribute of the current OptionValues instance; these options
     require a *note dest: 11f5.  attribute to be supplied to the
     Option constructor.

"typed" actions
     actions that take a value from the command line and expect it to
     be of a certain type; or rather, a string that can be converted to
     a certain type.  These options require a *note type: 11f4.
     attribute to the Option constructor.

  These are overlapping sets: some default "store" actions are
`"store"', `"store_const"', `"append"', and `"count"', while the
default "typed" actions are `"store"', `"append"', and `"callback"'.

  When you add an action, you need to categorize it by listing it in at
least one of the following class attributes of Option (all are lists of
strings):

 -- Attribute: Option.ACTIONS
     All actions must be listed in ACTIONS.

 -- Attribute: Option.STORE_ACTIONS
     "store" actions are additionally listed here.

 -- Attribute: Option.TYPED_ACTIONS
     "typed" actions are additionally listed here.

 -- Attribute: Option.ALWAYS_TYPED_ACTIONS
     Actions that always take a type (i.e. whose options always take a
     value) are additionally listed here.  The only effect of this is
     that *note optparse: 128.  assigns the default type, `"string"',
     to options with no explicit type whose action is listed in *note
     ALWAYS_TYPED_ACTIONS: 1256.

  In order to actually implement your new action, you must override
Option's `take_action()' method and add a case that recognizes your
action.

  For example, let's add an `"extend"' action.  This is similar to the
standard `"append"' action, but instead of taking a single value from
the command-line and appending it to an existing list, `"extend"' will
take multiple values in a single comma-delimited string, and extend an
existing list with them.  That is, if `--names' is an `"extend"' option
of type `"string"', the command line

    --names=foo,bar --names blah --names ding,dong

would result in a list

    ["foo", "bar", "blah", "ding", "dong"]

Again we define a subclass of Option:

    class MyOption(Option):

        ACTIONS = Option.ACTIONS + ("extend",)
        STORE_ACTIONS = Option.STORE_ACTIONS + ("extend",)
        TYPED_ACTIONS = Option.TYPED_ACTIONS + ("extend",)
        ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + ("extend",)

        def take_action(self, action, dest, opt, value, values, parser):
            if action == "extend":
                lvalue = value.split(",")
                values.ensure_value(dest, []).extend(lvalue)
            else:
                Option.take_action(
                    self, action, dest, opt, value, values, parser)

Features of note:

   * `"extend"' both expects a value on the command-line and stores
     that value somewhere, so it goes in both *note STORE_ACTIONS:
     1254. and *note TYPED_ACTIONS: 1255.

   * to ensure that *note optparse: 128. assigns the default type of
     `"string"' to `"extend"' actions, we put the `"extend"' action in
     *note ALWAYS_TYPED_ACTIONS: 1256. as well.

   * `MyOption.take_action()' implements just this one new action, and
     passes control back to `Option.take_action()' for the standard
     *note optparse: 128.  actions.

   * `values' is an instance of the optparse_parser.Values class, which
     provides the very useful `ensure_value()' method. `ensure_value()'
     is essentially *note getattr(): 844. with a safety valve; it is
     called as

         values.ensure_value(attr, value)

     If the `attr' attribute of `values' doesn't exist or is None, then
     ensure_value() first sets it to `value', and then returns 'value.
     This is very handy for actions like `"extend"', `"append"', and
     `"count"', all of which accumulate data in a variable and expect
     that variable to be of a certain type (a list for the first two,
     an integer for the latter).  Using `ensure_value()' means that
     scripts using your action don't have to worry about setting a
     default value for the option destinations in question; they can
     just leave the default as None and `ensure_value()' will take care
     of getting it right when it's needed.


File: python.info,  Node: getopt --- C-style parser for command line options,  Next: logging --- Logging facility for Python,  Prev: optparse --- Parser for command line options,  Up: Generic Operating System Services

5.15.6 `getopt' -- C-style parser for command line options
----------------------------------------------------------

This module helps scripts to parse the command line arguments in
`sys.argv'.  It supports the same conventions as the Unix `getopt()'
function (including the special meanings of arguments of the form '`-''
and '`--'').  Long options similar to those supported by GNU software
may be used as well via an optional third argument.

  A more convenient, flexible, and powerful alternative is the *note
optparse: 128. module.

  This module provides two functions and an exception:

 -- Function: getopt.getopt (args, options[, long_options])
     Parses command line options and parameter list.  _args_ is the
     argument list to be parsed, without the leading reference to the
     running program. Typically, this means `sys.argv[1:]'. _options_
     is the string of option letters that the script wants to
     recognize, with options that require an argument followed by a
     colon (`':''; i.e., the same format that Unix `getopt()' uses).

          Note: Unlike GNU `getopt()', after a non-option argument, all
          further arguments are considered also non-options. This is
          similar to the way non-GNU Unix systems work.

     _long_options_, if specified, must be a list of strings with the
     names of the long options which should be supported.  The leading
     `'--'' characters should not be included in the option name.  Long
     options which require an argument should be followed by an equal
     sign (`'='').  Optional arguments are not supported.  To accept
     only long options, _options_ should be an empty string.  Long
     options on the command line can be recognized so long as they
     provide a prefix of the option name that matches exactly one of
     the accepted options.  For example, if _long_options_ is `['foo',
     'frob']', the option `--fo' will match as `--foo', but `--f' will
     not match uniquely, so *note GetoptError: 125a. will be raised.

     The return value consists of two elements: the first is a list of
     `(option, value)' pairs; the second is the list of program
     arguments left after the option list was stripped (this is a
     trailing slice of _args_).  Each option-and-value pair returned
     has the option as its first element, prefixed with a hyphen for
     short options (e.g., `'-x'') or two hyphens for long options
     (e.g., `'--long-option''), and the option argument as its second
     element, or an empty string if the option has no argument.  The
     options occur in the list in the same order in which they were
     found, thus allowing multiple occurrences.  Long and short options
     may be mixed.

 -- Function: getopt.gnu_getopt (args, options[, long_options])
     This function works like *note getopt(): df, except that GNU style
     scanning mode is used by default. This means that option and
     non-option arguments may be intermixed. The *note getopt(): df.
     function stops processing options as soon as a non-option argument
     is encountered.

     If the first character of the option string is `'+'', or if the
     environment variable `POSIXLY_CORRECT' is set, then option
     processing stops as soon as a non-option argument is encountered.

     New in version 2.3.

 -- Exception: getopt.GetoptError
     This is raised when an unrecognized option is found in the
     argument list or when an option requiring an argument is given
     none. The argument to the exception is a string indicating the
     cause of the error.  For long options, an argument given to an
     option which does not require one will also cause this exception
     to be raised.  The attributes `msg' and `opt' give the error
     message and related option; if there is no specific option to
     which the exception relates, `opt' is an empty string.

     Changed in version 1.6: Introduced *note GetoptError: 125a. as a
     synonym for *note error: 125c.

 -- Exception: getopt.error
     Alias for *note GetoptError: 125a.; for backward compatibility.

  An example using only Unix style options:

    >>> import getopt
    >>> args = '-a -b -cfoo -d bar a1 a2'.split()
    >>> args
    ['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']
    >>> optlist, args = getopt.getopt(args, 'abc:d:')
    >>> optlist
    [('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]
    >>> args
    ['a1', 'a2']

Using long option names is equally easy:

    >>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'
    >>> args = s.split()
    >>> args
    ['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']
    >>> optlist, args = getopt.getopt(args, 'x', [
    ...     'condition=', 'output-file=', 'testing'])
    >>> optlist
    [('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]
    >>> args
    ['a1', 'a2']

In a script, typical usage is something like this:

    import getopt, sys

    def main():
        try:
            opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
        except getopt.GetoptError, err:
            # print help information and exit:
            print str(err) # will print something like "option -a not recognized"
            usage()
            sys.exit(2)
        output = None
        verbose = False
        for o, a in opts:
            if o == "-v":
                verbose = True
            elif o in ("-h", "--help"):
                usage()
                sys.exit()
            elif o in ("-o", "--output"):
                output = a
            else:
                assert False, "unhandled option"
        # ...

    if __name__ == "__main__":
        main()

Note that an equivalent command line interface could be produced with
less code and more informative help and error messages by using the
*note argparse: d. module:

    import argparse

    if __name__ == '__main__':
        parser = argparse.ArgumentParser()
        parser.add_argument('-o', '--output')
        parser.add_argument('-v', dest='verbose', action='store_true')
        args = parser.parse_args()
        # ... do something with args.output ...
        # ... do something with args.verbose ..


See also
........

Module *note argparse: d.
     Alternative command line option and argument parsing library.


File: python.info,  Node: logging --- Logging facility for Python,  Next: logging config --- Logging configuration,  Prev: getopt --- C-style parser for command line options,  Up: Generic Operating System Services

5.15.7 `logging' -- Logging facility for Python
-----------------------------------------------

Important
.........

This page contains the API reference information. For tutorial
information and discussion of more advanced topics, see

   * *note Basic Tutorial: 125f.

   * *note Advanced Tutorial: 1260.

   * *note Logging Cookbook: 1261.

  New in version 2.3.

  This module defines functions and classes which implement a flexible
event logging system for applications and libraries.

  The key benefit of having the logging API provided by a standard
library module is that all Python modules can participate in logging,
so your application log can include your own messages integrated with
messages from third-party modules.

  The module provides a lot of functionality and flexibility.  If you
are unfamiliar with logging, the best way to get to grips with it is to
see the tutorials (see the links on the right).

  The basic classes defined by the module, together with their
functions, are listed below.

   * Loggers expose the interface that application code directly uses.

   * Handlers send the log records (created by loggers) to the
     appropriate destination.

   * Filters provide a finer grained facility for determining which log
     records to output.

   * Formatters specify the layout of log records in the final output.

* Menu:

* Logger Objects::
* Handler Objects::
* Formatter Objects::
* Filter Objects::
* LogRecord Objects::
* LogRecord attributes::
* LoggerAdapter Objects::
* Thread Safety::
* Module-Level Functions::
* Integration with the warnings module::


File: python.info,  Node: Logger Objects,  Next: Handler Objects,  Up: logging --- Logging facility for Python

5.15.7.1 Logger Objects
.......................

Loggers have the following attributes and methods. Note that Loggers
are never instantiated directly, but always through the module-level
function `logging.getLogger(name)'.

 -- Class: logging.Logger

 -- Attribute: Logger.propagate
     If this evaluates to false, logging messages are not passed by
     this logger or by its child loggers to the handlers of higher
     level (ancestor) loggers. The constructor sets this attribute to 1.

 -- Method: Logger.setLevel (lvl)
     Sets the threshold for this logger to _lvl_. Logging messages
     which are less severe than _lvl_ will be ignored. When a logger is
     created, the level is set to `NOTSET' (which causes all messages
     to be processed when the logger is the root logger, or delegation
     to the parent when the logger is a non-root logger). Note that the
     root logger is created with level `WARNING'.

     The term 'delegation to the parent' means that if a logger has a
     level of NOTSET, its chain of ancestor loggers is traversed until
     either an ancestor with a level other than NOTSET is found, or the
     root is reached.

     If an ancestor is found with a level other than NOTSET, then that
     ancestor's level is treated as the effective level of the logger
     where the ancestor search began, and is used to determine how a
     logging event is handled.

     If the root is reached, and it has a level of NOTSET, then all
     messages will be processed. Otherwise, the root's level will be
     used as the effective level.

 -- Method: Logger.isEnabledFor (lvl)
     Indicates if a message of severity _lvl_ would be processed by
     this logger.  This method checks first the module-level level set
     by `logging.disable(lvl)' and then the logger's effective level as
     determined by *note getEffectiveLevel(): 1267.

 -- Method: Logger.getEffectiveLevel ()
     Indicates the effective level for this logger. If a value other
     than `NOTSET' has been set using *note setLevel(): 1265, it is
     returned. Otherwise, the hierarchy is traversed towards the root
     until a value other than `NOTSET' is found, and that value is
     returned.

 -- Method: Logger.getChild (suffix)
     Returns a logger which is a descendant to this logger, as
     determined by the suffix.  Thus,
     `logging.getLogger('abc').getChild('def.ghi')' would return the
     same logger as would be returned by
     `logging.getLogger('abc.def.ghi')'. This is a convenience method,
     useful when the parent logger is named using e.g. `__name__'
     rather than a literal string.

     New in version 2.7.

 -- Method: Logger.debug (msg, *args, **kwargs)
     Logs a message with level `DEBUG' on this logger. The _msg_ is the
     message format string, and the _args_ are the arguments which are
     merged into _msg_ using the string formatting operator. (Note that
     this means that you can use keywords in the format string,
     together with a single dictionary argument.)

     There are two keyword arguments in _kwargs_ which are inspected:
     _exc_info_ which, if it does not evaluate as false, causes
     exception information to be added to the logging message. If an
     exception tuple (in the format returned by *note sys.exc_info():
     2e4.) is provided, it is used; otherwise, *note sys.exc_info():
     2e4.  is called to get the exception information.

     The second keyword argument is _extra_ which can be used to pass a
     dictionary which is used to populate the __dict__ of the LogRecord
     created for the logging event with user-defined attributes. These
     custom attributes can then be used as you like. For example, they
     could be incorporated into logged messages. For example:

         FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
         logging.basicConfig(format=FORMAT)
         d = { 'clientip' : '192.168.0.1', 'user' : 'fbloggs' }
         logger = logging.getLogger('tcpserver')
         logger.warning('Protocol problem: %s', 'connection reset', extra=d)

     would print something like

         2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

     The keys in the dictionary passed in _extra_ should not clash with
     the keys used by the logging system. (See the *note Formatter:
     1269. documentation for more information on which keys are used by
     the logging system.)

     If you choose to use these attributes in logged messages, you need
     to exercise some care. In the above example, for instance, the
     *note Formatter: 1269. has been set up with a format string which
     expects 'clientip' and 'user' in the attribute dictionary of the
     LogRecord. If these are missing, the message will not be logged
     because a string formatting exception will occur. So in this case,
     you always need to pass the _extra_ dictionary with these keys.

     While this might be annoying, this feature is intended for use in
     specialized circumstances, such as multi-threaded servers where
     the same code executes in many contexts, and interesting
     conditions which arise are dependent on this context (such as
     remote client IP address and authenticated user name, in the above
     example). In such circumstances, it is likely that specialized
     *note Formatter: 1269.s would be used with particular `Handler's.

 -- Method: Logger.info (msg, *args, **kwargs)
     Logs a message with level `INFO' on this logger. The arguments are
     interpreted as for *note debug(): 126b.

 -- Method: Logger.warning (msg, *args, **kwargs)
     Logs a message with level `WARNING' on this logger. The arguments
     are interpreted as for *note debug(): 126b.

 -- Method: Logger.error (msg, *args, **kwargs)
     Logs a message with level `ERROR' on this logger. The arguments are
     interpreted as for *note debug(): 126b.

 -- Method: Logger.critical (msg, *args, **kwargs)
     Logs a message with level `CRITICAL' on this logger. The arguments
     are interpreted as for *note debug(): 126b.

 -- Method: Logger.log (lvl, msg, *args, **kwargs)
     Logs a message with integer level _lvl_ on this logger. The other
     arguments are interpreted as for *note debug(): 126b.

 -- Method: Logger.exception (msg, *args)
     Logs a message with level `ERROR' on this logger. The arguments are
     interpreted as for *note debug(): 126b. Exception info is added to
     the logging message. This method should only be called from an
     exception handler.

 -- Method: Logger.addFilter (filt)
     Adds the specified filter _filt_ to this logger.

 -- Method: Logger.removeFilter (filt)
     Removes the specified filter _filt_ from this logger.

 -- Method: Logger.filter (record)
     Applies this logger's filters to the record and returns a true
     value if the record is to be processed.

 -- Method: Logger.addHandler (hdlr)
     Adds the specified handler _hdlr_ to this logger.

 -- Method: Logger.removeHandler (hdlr)
     Removes the specified handler _hdlr_ from this logger.

 -- Method: Logger.findCaller ()
     Finds the caller's source filename and line number. Returns the
     filename, line number and function name as a 3-element tuple.

     Changed in version 2.4: The function name was added. In earlier
     versions, the filename and line number were returned as a
     2-element tuple.

 -- Method: Logger.handle (record)
     Handles a record by passing it to all handlers associated with
     this logger and its ancestors (until a false value of _propagate_
     is found). This method is used for unpickled records received from
     a socket, as well as those created locally.  Logger-level
     filtering is applied using *note filter(): 1273.

 -- Method: Logger.makeRecord (name, lvl, fn, lno, msg, args, exc_info,
          func=None, extra=None)
     This is a factory method which can be overridden in subclasses to
     create specialized *note LogRecord: 1279. instances.

     Changed in version 2.5: _func_ and _extra_ were added.


File: python.info,  Node: Handler Objects,  Next: Formatter Objects,  Prev: Logger Objects,  Up: logging --- Logging facility for Python

5.15.7.2 Handler Objects
........................

Handlers have the following attributes and methods. Note that `Handler'
is never instantiated directly; this class acts as a base for more
useful subclasses. However, the *note __init__(): 36b. method in
subclasses needs to call *note Handler.__init__(): 127c.

 -- Method: Handler.__init__ (level=NOTSET)
     Initializes the `Handler' instance by setting its level, setting
     the list of filters to the empty list and creating a lock (using
     *note createLock(): 127d.) for serializing access to an I/O
     mechanism.

 -- Method: Handler.createLock ()
     Initializes a thread lock which can be used to serialize access to
     underlying I/O functionality which may not be threadsafe.

 -- Method: Handler.acquire ()
     Acquires the thread lock created with *note createLock(): 127d.

 -- Method: Handler.release ()
     Releases the thread lock acquired with *note acquire(): 127e.

 -- Method: Handler.setLevel (lvl)
     Sets the threshold for this handler to _lvl_. Logging messages
     which are less severe than _lvl_ will be ignored. When a handler
     is created, the level is set to `NOTSET' (which causes all
     messages to be processed).

 -- Method: Handler.setFormatter (form)
     Sets the *note Formatter: 1269. for this handler to _form_.

 -- Method: Handler.addFilter (filt)
     Adds the specified filter _filt_ to this handler.

 -- Method: Handler.removeFilter (filt)
     Removes the specified filter _filt_ from this handler.

 -- Method: Handler.filter (record)
     Applies this handler's filters to the record and returns a true
     value if the record is to be processed.

 -- Method: Handler.flush ()
     Ensure all logging output has been flushed. This version does
     nothing and is intended to be implemented by subclasses.

 -- Method: Handler.close ()
     Tidy up any resources used by the handler. This version does no
     output but removes the handler from an internal list of handlers
     which is closed when *note shutdown(): 1287. is called. Subclasses
     should ensure that this gets called from overridden *note close():
     1286. methods.

 -- Method: Handler.handle (record)
     Conditionally emits the specified logging record, depending on
     filters which may have been added to the handler. Wraps the actual
     emission of the record with acquisition/release of the I/O thread
     lock.

 -- Method: Handler.handleError (record)
     This method should be called from handlers when an exception is
     encountered during an *note emit(): 128a. call. By default it does
     nothing, which means that exceptions get silently ignored. This is
     what is mostly wanted for a logging system - most users will not
     care about errors in the logging system, they are more interested
     in application errors. You could, however, replace this with a
     custom handler if you wish. The specified record is the one which
     was being processed when the exception occurred.

 -- Method: Handler.format (record)
     Do formatting for a record - if a formatter is set, use it.
     Otherwise, use the default formatter for the module.

 -- Method: Handler.emit (record)
     Do whatever it takes to actually log the specified logging record.
     This version is intended to be implemented by subclasses and so
     raises a *note NotImplementedError: 919.

  For a list of handlers included as standard, see *note
logging.handlers: 104.


File: python.info,  Node: Formatter Objects,  Next: Filter Objects,  Prev: Handler Objects,  Up: logging --- Logging facility for Python

5.15.7.3 Formatter Objects
..........................

*note Formatter: 1269. objects have the following attributes and
methods. They are responsible for converting a *note LogRecord: 1279.
to (usually) a string which can be interpreted by either a human or an
external system. The base *note Formatter: 1269. allows a formatting
string to be specified. If none is supplied, the default value of
`'%(message)s'' is used.

  A Formatter can be initialized with a format string which makes use
of knowledge of the *note LogRecord: 1279. attributes - such as the
default value mentioned above making use of the fact that the user's
message and arguments are pre-formatted into a *note LogRecord: 1279.'s
_message_ attribute.  This format string contains standard Python
%-style mapping keys. See section *note String Formatting Operations:
50e.  for more information on string formatting.

  The useful mapping keys in a *note LogRecord: 1279. are given in the
section on *note LogRecord attributes: 128e.

 -- Class: logging.Formatter (fmt=None, datefmt=None)
     Returns a new instance of the *note Formatter: 1269. class.  The
     instance is initialized with a format string for the message as a
     whole, as well as a format string for the date/time portion of a
     message.  If no _fmt_ is specified, `'%(message)s'' is used.  If
     no _datefmt_ is specified, the ISO8601 date format is used.

      -- Method: format (record)
          The record's attribute dictionary is used as the operand to a
          string formatting operation. Returns the resulting string.
          Before formatting the dictionary, a couple of preparatory
          steps are carried out. The _message_ attribute of the record
          is computed using _msg_ % _args_. If the formatting string
          contains `'(asctime)'', *note formatTime(): 1290. is called
          to format the event time. If there is exception information,
          it is formatted using *note formatException(): 1291. and
          appended to the message. Note that the formatted exception
          information is cached in attribute _exc_text_. This is useful
          because the exception information can be pickled and sent
          across the wire, but you should be careful if you have more
          than one *note Formatter: 1269. subclass which customizes the
          formatting of exception information. In this case, you will
          have to clear the cached value after a formatter has done its
          formatting, so that the next formatter to handle the event
          doesn't use the cached value but recalculates it afresh.

      -- Method: formatTime (record, datefmt=None)
          This method should be called from *note format(): 1ec. by a
          formatter which wants to make use of a formatted time. This
          method can be overridden in formatters to provide for any
          specific requirement, but the basic behavior is as follows:
          if _datefmt_ (a string) is specified, it is used with *note
          time.strftime(): 3ad. to format the creation time of the
          record. Otherwise, the ISO8601 format is used.  The resulting
          string is returned.

      -- Method: formatException (exc_info)
          Formats the specified exception information (a standard
          exception tuple as returned by *note sys.exc_info(): 2e4.) as
          a string. This default implementation just uses *note
          traceback.print_exception(): 1292. The resulting string is
          returned.


File: python.info,  Node: Filter Objects,  Next: LogRecord Objects,  Prev: Formatter Objects,  Up: logging --- Logging facility for Python

5.15.7.4 Filter Objects
.......................

`Filters' can be used by `Handlers' and `Loggers' for more sophisticated
filtering than is provided by levels. The base filter class only allows
events which are below a certain point in the logger hierarchy. For
example, a filter initialized with 'A.B' will allow events logged by
loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B'
etc. If initialized with the empty string, all events are passed.

 -- Class: logging.Filter (name='')
     Returns an instance of the *note Filter: 1295. class. If _name_ is
     specified, it names a logger which, together with its children,
     will have its events allowed through the filter. If _name_ is the
     empty string, allows every event.

      -- Method: filter (record)
          Is the specified record to be logged? Returns zero for no,
          nonzero for yes. If deemed appropriate, the record may be
          modified in-place by this method.

  Note that filters attached to handlers are consulted whenever an
event is emitted by the handler, whereas filters attached to loggers
are consulted whenever an event is logged to the handler (using *note
debug(): 126b, *note info(): 1297, etc.) This means that events which
have been generated by descendant loggers will not be filtered by a
logger's filter setting, unless the filter has also been applied to
those descendant loggers.

  You don't actually need to subclass `Filter': you can pass any
instance which has a `filter' method with the same semantics.

  Although filters are used primarily to filter records based on more
sophisticated criteria than levels, they get to see every record which
is processed by the handler or logger they're attached to: this can be
useful if you want to do things like counting how many records were
processed by a particular logger or handler, or adding, changing or
removing attributes in the LogRecord being processed. Obviously
changing the LogRecord needs to be done with some care, but it does
allow the injection of contextual information into logs (see *note
Using Filters to impart contextual information: 1298.).


File: python.info,  Node: LogRecord Objects,  Next: LogRecord attributes,  Prev: Filter Objects,  Up: logging --- Logging facility for Python

5.15.7.5 LogRecord Objects
..........................

*note LogRecord: 1279. instances are created automatically by the *note
Logger: 1da.  every time something is logged, and can be created
manually via *note makeLogRecord(): 129b. (for example, from a pickled
event received over the wire).

 -- Class: logging.LogRecord (name, level, pathname, lineno, msg, args,
          exc_info, func=None)
     Contains all the information pertinent to the event being logged.

     The primary information is passed in `msg' and `args', which are
     combined using `msg % args' to create the `message' field of the
     record.

          Parameters:

             * *name* - The name of the logger used to log the event
               represented by this LogRecord.

             * *level* - The numeric level of the logging event (one of
               DEBUG, INFO etc.)

             * *pathname* - The full pathname of the source file where
               the logging call was made.

             * *lineno* - The line number in the source file where the
               logging call was made.

             * *msg* - The event description message, possibly a format
               string with placeholders for variable data.

             * *args* - Variable data to merge into the _msg_ argument
               to obtain the event description.

             * *exc_info* - An exception tuple with the current
               exception information, or _None_ if no exception
               information is available.

             * *func* - The name of the function or method from which
               the logging call was invoked.

     Changed in version 2.5: _func_ was added.

      -- Method: getMessage ()
          Returns the message for this *note LogRecord: 1279. instance
          after merging any user-supplied arguments with the message.
          If the user-supplied message argument to the logging call is
          not a string, *note str(): 1e7. is called on it to convert it
          to a string. This allows use of user-defined classes as
          messages, whose `__str__' method can return the actual format
          string to be used.


File: python.info,  Node: LogRecord attributes,  Next: LoggerAdapter Objects,  Prev: LogRecord Objects,  Up: logging --- Logging facility for Python

5.15.7.6 LogRecord attributes
.............................

The LogRecord has a number of attributes, most of which are derived
from the parameters to the constructor. (Note that the names do not
always correspond exactly between the LogRecord constructor parameters
and the LogRecord attributes.) These attributes can be used to merge
data from the record into the format string. The following table lists
(in alphabetical order) the attribute names, their meanings and the
corresponding placeholder in a %-style format string.

Attribute name       Format                        Description
------------------------------------------------------------------------------------------------------- 
args                 You shouldn't need to format  The tuple of arguments merged into `msg' to
                     this yourself.                produce `message'.
asctime              `%(asctime)s'                 Human-readable time when the *note LogRecord:
                                                   1279. was created.  By default this is of the form
                                                   '2003-07-08 16:49:45,896' (the numbers after the
                                                   comma are millisecond portion of the time).
created              `%(created)f'                 Time when the *note LogRecord: 1279. was created
                                                   (as returned by *note time.time(): 450.).
exc_info             You shouldn't need to format  Exception tuple (  la `sys.exc_info') or, if no
                     this yourself.                exception has occurred, _None_.
filename             `%(filename)s'                Filename portion of `pathname'.
funcName             `%(funcName)s'                Name of function containing the logging call.
levelname            `%(levelname)s'               Text logging level for the message (`'DEBUG'',
                                                   `'INFO'', `'WARNING'', `'ERROR'', `'CRITICAL'').
levelno              `%(levelno)s'                 Numeric logging level for the message (`DEBUG',
                                                   `INFO', `WARNING', `ERROR', `CRITICAL').
lineno               `%(lineno)d'                  Source line number where the logging call was
                                                   issued (if available).
module               `%(module)s'                  Module (name portion of `filename').
msecs                `%(msecs)d'                   Millisecond portion of the time when the *note
                                                   LogRecord: 1279. was created.
message              `%(message)s'                 The logged message, computed as `msg % args'. This
                                                   is set when *note Formatter.format(): 128f. is
                                                   invoked.
msg                  You shouldn't need to format  The format string passed in the original logging
                     this yourself.                call. Merged with `args' to produce `message', or
                                                   an arbitrary object (see *note Using arbitrary
                                                   objects as messages: 129e.).
name                 `%(name)s'                    Name of the logger used to log the call.
pathname             `%(pathname)s'                Full pathname of the source file where the logging
                                                   call was issued (if available).
process              `%(process)d'                 Process ID (if available).
processName          `%(processName)s'             Process name (if available).
relativeCreated      `%(relativeCreated)d'         Time in milliseconds when the LogRecord was
                                                   created, relative to the time the logging module
                                                   was loaded.
thread               `%(thread)d'                  Thread ID (if available).
threadName           `%(threadName)s'              Thread name (if available).

  Changed in version 2.5: _funcName_ was added.


File: python.info,  Node: LoggerAdapter Objects,  Next: Thread Safety,  Prev: LogRecord attributes,  Up: logging --- Logging facility for Python

5.15.7.7 LoggerAdapter Objects
..............................

*note LoggerAdapter: 1dc. instances are used to conveniently pass
contextual information into logging calls. For a usage example , see
the section on *note adding contextual information to your logging
output: 12a1.

  New in version 2.6.

 -- Class: logging.LoggerAdapter (logger, extra)
     Returns an instance of *note LoggerAdapter: 1dc. initialized with
     an underlying *note Logger: 1da. instance and a dict-like object.

      -- Method: process (msg, kwargs)
          Modifies the message and/or keyword arguments passed to a
          logging call in order to insert contextual information. This
          implementation takes the object passed as _extra_ to the
          constructor and adds it to _kwargs_ using key 'extra'. The
          return value is a (_msg_, _kwargs_) tuple which has the
          (possibly modified) versions of the arguments passed in.

  In addition to the above, *note LoggerAdapter: 1dc. supports the
following methods of *note Logger: 1da, i.e. *note debug(): 126b, *note
info(): 1297, *note warning(): 12a3, *note error(): 12a4, *note
exception(): 12a5, *note critical(): 12a6, *note log(): 12a7,
`isEnabledFor()', `getEffectiveLevel()', `setLevel()', `hasHandlers()'.
These methods have the same signatures as their counterparts in *note
Logger: 1da, so you can use the two types of instances interchangeably.

  Changed in version 2.7: The `isEnabledFor()' method was added to
*note LoggerAdapter: 1dc.  This method delegates to the underlying
logger.


File: python.info,  Node: Thread Safety,  Next: Module-Level Functions,  Prev: LoggerAdapter Objects,  Up: logging --- Logging facility for Python

5.15.7.8 Thread Safety
......................

The logging module is intended to be thread-safe without any special
work needing to be done by its clients. It achieves this though using
threading locks; there is one lock to serialize access to the module's
shared data, and each handler also creates a lock to serialize access
to its underlying I/O.

  If you are implementing asynchronous signal handlers using the *note
signal: 156.  module, you may not be able to use logging from within
such handlers. This is because lock implementations in the *note
threading: 17a. module are not always re-entrant, and so cannot be
invoked from such signal handlers.


File: python.info,  Node: Module-Level Functions,  Next: Integration with the warnings module,  Prev: Thread Safety,  Up: logging --- Logging facility for Python

5.15.7.9 Module-Level Functions
...............................

In addition to the classes described above, there are a number of
module- level functions.

 -- Function: logging.getLogger ([name])
     Return a logger with the specified name or, if no name is
     specified, return a logger which is the root logger of the
     hierarchy. If specified, the name is typically a dot-separated
     hierarchical name like _"a"_, _"a.b"_ or _"a.b.c.d"_.  Choice of
     these names is entirely up to the developer who is using logging.

     All calls to this function with a given name return the same
     logger instance.  This means that logger instances never need to
     be passed between different parts of an application.

 -- Function: logging.getLoggerClass ()
     Return either the standard *note Logger: 1da. class, or the last
     class passed to *note setLoggerClass(): 12ac. This function may be
     called from within a new class definition, to ensure that
     installing a customised *note Logger: 1da. class will not undo
     customisations already applied by other code. For example:

         class MyLogger(logging.getLoggerClass()):
             # ... override behaviour here



 -- Function: logging.debug (msg[, *args[, **kwargs]])
     Logs a message with level `DEBUG' on the root logger. The _msg_ is
     the message format string, and the _args_ are the arguments which
     are merged into _msg_ using the string formatting operator. (Note
     that this means that you can use keywords in the format string,
     together with a single dictionary argument.)

     There are two keyword arguments in _kwargs_ which are inspected:
     _exc_info_ which, if it does not evaluate as false, causes
     exception information to be added to the logging message. If an
     exception tuple (in the format returned by *note sys.exc_info():
     2e4.) is provided, it is used; otherwise, *note sys.exc_info():
     2e4.  is called to get the exception information.

     The other optional keyword argument is _extra_ which can be used
     to pass a dictionary which is used to populate the __dict__ of the
     LogRecord created for the logging event with user-defined
     attributes. These custom attributes can then be used as you like.
     For example, they could be incorporated into logged messages. For
     example:

         FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s"
         logging.basicConfig(format=FORMAT)
         d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
         logging.warning("Protocol problem: %s", "connection reset", extra=d)

     would print something like:

         2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

     The keys in the dictionary passed in _extra_ should not clash with
     the keys used by the logging system. (See the *note Formatter:
     1269. documentation for more information on which keys are used by
     the logging system.)

     If you choose to use these attributes in logged messages, you need
     to exercise some care. In the above example, for instance, the
     *note Formatter: 1269. has been set up with a format string which
     expects 'clientip' and 'user' in the attribute dictionary of the
     LogRecord. If these are missing, the message will not be logged
     because a string formatting exception will occur. So in this case,
     you always need to pass the _extra_ dictionary with these keys.

     While this might be annoying, this feature is intended for use in
     specialized circumstances, such as multi-threaded servers where
     the same code executes in many contexts, and interesting
     conditions which arise are dependent on this context (such as
     remote client IP address and authenticated user name, in the above
     example). In such circumstances, it is likely that specialized
     *note Formatter: 1269.s would be used with particular `Handler's.

     Changed in version 2.5: _extra_ was added.

 -- Function: logging.info (msg[, *args[, **kwargs]])
     Logs a message with level `INFO' on the root logger. The arguments
     are interpreted as for *note debug(): 126b.

 -- Function: logging.warning (msg[, *args[, **kwargs]])
     Logs a message with level `WARNING' on the root logger. The
     arguments are interpreted as for *note debug(): 126b.

 -- Function: logging.error (msg[, *args[, **kwargs]])
     Logs a message with level `ERROR' on the root logger. The
     arguments are interpreted as for *note debug(): 126b.

 -- Function: logging.critical (msg[, *args[, **kwargs]])
     Logs a message with level `CRITICAL' on the root logger. The
     arguments are interpreted as for *note debug(): 126b.

 -- Function: logging.exception (msg[, *args])
     Logs a message with level `ERROR' on the root logger. The
     arguments are interpreted as for *note debug(): 126b. Exception
     info is added to the logging message. This function should only be
     called from an exception handler.

 -- Function: logging.log (level, msg[, *args[, **kwargs]])
     Logs a message with level _level_ on the root logger. The other
     arguments are interpreted as for *note debug(): 126b.

     PLEASE NOTE: The above module-level functions which delegate to
     the root logger should _not_ be used in threads, in versions of
     Python earlier than 2.7.1 and 3.2, unless at least one handler has
     been added to the root logger _before_ the threads are started.
     These convenience functions call *note basicConfig(): 12ad. to
     ensure that at least one handler is available; in earlier versions
     of Python, this can (under rare circumstances) lead to handlers
     being added multiple times to the root logger, which can in turn
     lead to multiple messages for the same event.

 -- Function: logging.disable (lvl)
     Provides an overriding level _lvl_ for all loggers which takes
     precedence over the logger's own level. When the need arises to
     temporarily throttle logging output down across the whole
     application, this function can be useful. Its effect is to disable
     all logging calls of severity _lvl_ and below, so that if you call
     it with a value of INFO, then all INFO and DEBUG events would be
     discarded, whereas those of severity WARNING and above would be
     processed according to the logger's effective level.

 -- Function: logging.addLevelName (lvl, levelName)
     Associates level _lvl_ with text _levelName_ in an internal
     dictionary, which is used to map numeric levels to a textual
     representation, for example when a *note Formatter: 1269. formats
     a message. This function can also be used to define your own
     levels. The only constraints are that all levels used must be
     registered using this function, levels should be positive integers
     and they should increase in increasing order of severity.

     NOTE: If you are thinking of defining your own levels, please see
     the section on *note Custom Levels: 12b0.

 -- Function: logging.getLevelName (lvl)
     Returns the textual representation of logging level _lvl_. If the
     level is one of the predefined levels `CRITICAL', `ERROR',
     `WARNING', `INFO' or `DEBUG' then you get the corresponding
     string. If you have associated levels with names using *note
     addLevelName(): 12af. then the name you have associated with _lvl_
     is returned. If a numeric value corresponding to one of the
     defined levels is passed in, the corresponding string
     representation is returned. Otherwise, the string "Level %s" % lvl
     is returned.

 -- Function: logging.makeLogRecord (attrdict)
     Creates and returns a new *note LogRecord: 1279. instance whose
     attributes are defined by _attrdict_. This function is useful for
     taking a pickled *note LogRecord: 1279. attribute dictionary, sent
     over a socket, and reconstituting it as a *note LogRecord: 1279.
     instance at the receiving end.

 -- Function: logging.basicConfig ([**kwargs])
     Does basic configuration for the logging system by creating a
     *note StreamHandler: 12b2. with a default *note Formatter: 1269.
     and adding it to the root logger. The functions *note debug():
     126b, *note info(): 1297, *note warning(): 12a3, *note error():
     12a4. and *note critical(): 12a6. will call *note basicConfig():
     12ad. automatically if no handlers are defined for the root logger.

     This function does nothing if the root logger already has handlers
     configured for it.

     Changed in version 2.4: Formerly, *note basicConfig(): 12ad. did
     not take any keyword arguments.

     PLEASE NOTE: This function should be called from the main thread
     before other threads are started. In versions of Python prior to
     2.7.1 and 3.2, if this function is called from multiple threads,
     it is possible (in rare circumstances) that a handler will be added
     to the root logger more than once, leading to unexpected results
     such as messages being duplicated in the log.

     The following keyword arguments are supported.

     Format             Description
     --------------------------------------------------------------------- 
     `filename'         Specifies that a FileHandler be created, using
                        the specified filename, rather than a
                        StreamHandler.
     `filemode'         Specifies the mode to open the file, if filename
                        is specified (if filemode is unspecified, it
                        defaults to 'a').
     `format'           Use the specified format string for the handler.
     `datefmt'          Use the specified date/time format.
     `level'            Set the root logger level to the specified level.
     `stream'           Use the specified stream to initialize the
                        StreamHandler. Note that this argument is
                        incompatible with 'filename' - if both are
                        present, 'stream' is ignored.


 -- Function: logging.shutdown ()
     Informs the logging system to perform an orderly shutdown by
     flushing and closing all handlers. This should be called at
     application exit and no further use of the logging system should
     be made after this call.

 -- Function: logging.setLoggerClass (klass)
     Tells the logging system to use the class _klass_ when
     instantiating a logger.  The class should define *note __init__():
     36b. such that only a name argument is required, and the *note
     __init__(): 36b. should call `Logger.__init__()'. This function is
     typically called before any loggers are instantiated by
     applications which need to use custom logger behavior.


File: python.info,  Node: Integration with the warnings module,  Prev: Module-Level Functions,  Up: logging --- Logging facility for Python

5.15.7.10 Integration with the warnings module
..............................................

The *note captureWarnings(): 12b4. function can be used to integrate
*note logging: 102.  with the *note warnings: 194. module.

 -- Function: logging.captureWarnings (capture)
     This function is used to turn the capture of warnings by logging
     on and off.

     If _capture_ is `True', warnings issued by the *note warnings:
     194. module will be redirected to the logging system.
     Specifically, a warning will be formatted using *note
     warnings.formatwarning(): 12b5. and the resulting string logged to
     a logger named 'py.warnings' with a severity of `WARNING'.

     If _capture_ is `False', the redirection of warnings to the
     logging system will stop, and warnings will be redirected to their
     original destinations (i.e. those in effect before
     `captureWarnings(True)' was called).

See also
........

Module *note logging.config: 103.
     Configuration API for the logging module.

Module *note logging.handlers: 104.
     Useful handlers included with the logging module.

PEP 282(1) - A Logging System
     The proposal which described this feature for inclusion in the
     Python standard library.

Original Python logging package(2)
     This is the original source for the *note logging: 102. package.
     The version of the package available from this site is suitable
     for use with Python 1.5.2, 2.1.x and 2.2.x, which do not include
     the *note logging: 102. package in the standard library.

  ---------- Footnotes ----------

  (1) http://www.python.org/dev/peps/pep-0282

  (2) http://www.red-dove.com/python_logging.html


File: python.info,  Node: logging config --- Logging configuration,  Next: logging handlers --- Logging handlers,  Prev: logging --- Logging facility for Python,  Up: Generic Operating System Services

5.15.8 `logging.config' -- Logging configuration
------------------------------------------------

Important
.........

This page contains only reference information. For tutorials, please see

   * *note Basic Tutorial: 125f.

   * *note Advanced Tutorial: 1260.

   * *note Logging Cookbook: 1261.

  This section describes the API for configuring the logging module.

* Menu:

* Configuration functions::
* Configuration dictionary schema::
* Configuration file format::


File: python.info,  Node: Configuration functions,  Next: Configuration dictionary schema,  Up: logging config --- Logging configuration

5.15.8.1 Configuration functions
................................

The following functions configure the logging module. They are located
in the *note logging.config: 103. module.  Their use is optional -- you
can configure the logging module using these functions or by making
calls to the main API (defined in *note logging: 102. itself) and
defining handlers which are declared either in *note logging: 102. or
*note logging.handlers: 104.

 -- Function: logging.config.dictConfig (config)
          Takes the logging configuration from a dictionary.  The
          contents of this dictionary are described in *note
          Configuration dictionary schema: 12ba.  below.

          If an error is encountered during configuration, this
          function will raise a *note ValueError: 233, *note TypeError:
          215, *note AttributeError: 1f5.  or *note ImportError: 35f.
          with a suitably descriptive message.  The following is a
          (possibly incomplete) list of conditions which will raise an
          error:

             * A `level' which is not a string or which is a string not
               corresponding to an actual logging level.

             * A `propagate' value which is not a boolean.

             * An id which does not have a corresponding destination.

             * A non-existent handler id found during an incremental
               call.

             * An invalid logger name.

             * Inability to resolve to an internal or external object.

          Parsing is performed by the `DictConfigurator' class, whose
          constructor is passed the dictionary used for configuration,
          and has a `configure()' method.  The *note logging.config:
          103. module has a callable attribute `dictConfigClass' which
          is initially set to `DictConfigurator'.  You can replace the
          value of `dictConfigClass' with a suitable implementation of
          your own.

          *note dictConfig(): 12b9. calls `dictConfigClass' passing the
          specified dictionary, and then calls the `configure()' method
          on the returned object to put the configuration into effect:

              def dictConfig(config):
                  dictConfigClass(config).configure()

          For example, a subclass of `DictConfigurator' could call
          `DictConfigurator.__init__()' in its own *note __init__():
          36b, then set up custom prefixes which would be usable in the
          subsequent `configure()' call. `dictConfigClass' would be
          bound to this new subclass, and then *note dictConfig():
          12b9. could be called exactly as in the default, uncustomized
          state.

     New in version 2.7.

 -- Function: logging.config.fileConfig (fname, defaults=None,
          disable_existing_loggers=True)
     Reads the logging configuration from a `configparser'-format file
     named _fname_. This function can be called several times from an
     application, allowing an end user to select from various pre-canned
     configurations (if the developer provides a mechanism to present
     the choices and load the chosen configuration).

          Parameters:

             * *defaults* - Defaults to be passed to the ConfigParser
               can be specified in this argument.

             * *disable_existing_loggers* - If specified as `False',
               loggers which exist when this call is made are left
               alone. The default is `True' because this enables old
               behaviour in a backward- compatible way. This behaviour
               is to disable any existing loggers unless they or their
               ancestors are explicitly named in the logging
               configuration.

     Changed in version 2.6: The `disable_existing_loggers' keyword
     argument was added. Previously, existing loggers were _always_
     disabled.

 -- Function: logging.config.listen (port=DEFAULT_LOGGING_CONFIG_PORT)
     Starts up a socket server on the specified port, and listens for
     new configurations. If no port is specified, the module's default
     `DEFAULT_LOGGING_CONFIG_PORT' is used. Logging configurations will
     be sent as a file suitable for processing by *note fileConfig():
     12bb. Returns a `Thread' instance on which you can call `start()'
     to start the server, and which you can `join()' when appropriate.
     To stop the server, call *note stopListening(): 12bd.

     To send a configuration to the socket, read in the configuration
     file and send it to the socket as a string of bytes preceded by a
     four-byte length string packed in binary using `struct.pack('>L',
     n)'.

 -- Function: logging.config.stopListening ()
     Stops the listening server which was created with a call to *note
     listen(): 12bc.  This is typically called before calling `join()'
     on the return value from *note listen(): 12bc.


File: python.info,  Node: Configuration dictionary schema,  Next: Configuration file format,  Prev: Configuration functions,  Up: logging config --- Logging configuration

5.15.8.2 Configuration dictionary schema
........................................

Describing a logging configuration requires listing the various objects
to create and the connections between them; for example, you may create
a handler named 'console' and then say that the logger named 'startup'
will send its messages to the 'console' handler.  These objects aren't
limited to those provided by the *note logging: 102.  module because
you might write your own formatter or handler class.  The parameters to
these classes may also need to include external objects such as
`sys.stderr'.  The syntax for describing these objects and connections
is defined in *note Object connections: 12bf.  below.

* Menu:

* Dictionary Schema Details::
* Incremental Configuration::
* Object connections::
* User-defined objects::
* Access to external objects::
* Access to internal objects::


File: python.info,  Node: Dictionary Schema Details,  Next: Incremental Configuration,  Up: Configuration dictionary schema

5.15.8.3 Dictionary Schema Details
..................................

The dictionary passed to *note dictConfig(): 12b9. must contain the
following keys:

   * _version_ - to be set to an integer value representing the schema
     version.  The only valid value at present is 1, but having this key
     allows the schema to evolve while still preserving backwards
     compatibility.

  All other keys are optional, but if present they will be interpreted
as described below.  In all cases below where a 'configuring dict' is
mentioned, it will be checked for the special `'()'' key to see if a
custom instantiation is required.  If so, the mechanism described in
*note User-defined objects: 12c1. below is used to create an instance;
otherwise, the context is used to determine what to instantiate.

   * _formatters_ - the corresponding value will be a dict in which each
     key is a formatter id and each value is a dict describing how to
     configure the corresponding Formatter instance.

     The configuring dict is searched for keys `format' and `datefmt'
     (with defaults of `None') and these are used to construct a *note
     logging.Formatter: 1269. instance.

   * _filters_ - the corresponding value will be a dict in which each
     key is a filter id and each value is a dict describing how to
     configure the corresponding Filter instance.

     The configuring dict is searched for the key `name' (defaulting to
     the empty string) and this is used to construct a *note
     logging.Filter: 1295.  instance.

   * _handlers_ - the corresponding value will be a dict in which each
     key is a handler id and each value is a dict describing how to
     configure the corresponding Handler instance.

     The configuring dict is searched for the following keys:

        * `class' (mandatory).  This is the fully qualified name of the
          handler class.

        * `level' (optional).  The level of the handler.

        * `formatter' (optional).  The id of the formatter for this
          handler.

        * `filters' (optional).  A list of ids of the filters for this
          handler.

     All _other_ keys are passed through as keyword arguments to the
     handler's constructor.  For example, given the snippet:

         handlers:
           console:
             class : logging.StreamHandler
             formatter: brief
             level   : INFO
             filters: [allow_foo]
             stream  : ext://sys.stdout
           file:
             class : logging.handlers.RotatingFileHandler
             formatter: precise
             filename: logconfig.log
             maxBytes: 1024
             backupCount: 3

     the handler with id `console' is instantiated as a *note
     logging.StreamHandler: 12b2, using `sys.stdout' as the underlying
     stream.  The handler with id `file' is instantiated as a *note
     logging.handlers.RotatingFileHandler: 12c2. with the keyword
     arguments `filename='logconfig.log', maxBytes=1024, backupCount=3'.

   * _loggers_ - the corresponding value will be a dict in which each
     key is a logger name and each value is a dict describing how to
     configure the corresponding Logger instance.

     The configuring dict is searched for the following keys:

        * `level' (optional).  The level of the logger.

        * `propagate' (optional).  The propagation setting of the
          logger.

        * `filters' (optional).  A list of ids of the filters for this
          logger.

        * `handlers' (optional).  A list of ids of the handlers for this
          logger.

     The specified loggers will be configured according to the level,
     propagation, filters and handlers specified.

   * _root_ - this will be the configuration for the root logger.
     Processing of the configuration will be as for any logger, except
     that the `propagate' setting will not be applicable.

   * _incremental_ - whether the configuration is to be interpreted as
     incremental to the existing configuration.  This value defaults to
     `False', which means that the specified configuration replaces the
     existing configuration with the same semantics as used by the
     existing *note fileConfig(): 12bb. API.

     If the specified value is `True', the configuration is processed
     as described in the section on *note Incremental Configuration:
     12c3.

   * _disable_existing_loggers_ - whether any existing loggers are to be
     disabled. This setting mirrors the parameter of the same name in
     *note fileConfig(): 12bb. If absent, this parameter defaults to
     `True'.  This value is ignored if _incremental_ is `True'.


File: python.info,  Node: Incremental Configuration,  Next: Object connections,  Prev: Dictionary Schema Details,  Up: Configuration dictionary schema

5.15.8.4 Incremental Configuration
..................................

It is difficult to provide complete flexibility for incremental
configuration.  For example, because objects such as filters and
formatters are anonymous, once a configuration is set up, it is not
possible to refer to such anonymous objects when augmenting a
configuration.

  Furthermore, there is not a compelling case for arbitrarily altering
the object graph of loggers, handlers, filters, formatters at run-time,
once a configuration is set up; the verbosity of loggers and handlers
can be controlled just by setting levels (and, in the case of loggers,
propagation flags).  Changing the object graph arbitrarily in a safe
way is problematic in a multi-threaded environment; while not
impossible, the benefits are not worth the complexity it adds to the
implementation.

  Thus, when the `incremental' key of a configuration dict is present
and is `True', the system will completely ignore any `formatters' and
`filters' entries, and process only the `level' settings in the
`handlers' entries, and the `level' and `propagate' settings in the
`loggers' and `root' entries.

  Using a value in the configuration dict lets configurations to be sent
over the wire as pickled dicts to a socket listener. Thus, the logging
verbosity of a long-running application can be altered over time with
no need to stop and restart the application.


File: python.info,  Node: Object connections,  Next: User-defined objects,  Prev: Incremental Configuration,  Up: Configuration dictionary schema

5.15.8.5 Object connections
...........................

The schema describes a set of logging objects - loggers, handlers,
formatters, filters - which are connected to each other in an object
graph.  Thus, the schema needs to represent connections between the
objects.  For example, say that, once configured, a particular logger
has attached to it a particular handler.  For the purposes of this
discussion, we can say that the logger represents the source, and the
handler the destination, of a connection between the two.  Of course in
the configured objects this is represented by the logger holding a
reference to the handler.  In the configuration dict, this is done by
giving each destination object an id which identifies it unambiguously,
and then using the id in the source object's configuration to indicate
that a connection exists between the source and the destination object
with that id.

  So, for example, consider the following YAML snippet:

    formatters:
      brief:
        # configuration for formatter with id 'brief' goes here
      precise:
        # configuration for formatter with id 'precise' goes here
    handlers:
      h1: #This is an id
       # configuration of handler with id 'h1' goes here
       formatter: brief
      h2: #This is another id
       # configuration of handler with id 'h2' goes here
       formatter: precise
    loggers:
      foo.bar.baz:
        # other configuration for logger 'foo.bar.baz'
        handlers: [h1, h2]

(Note: YAML used here because it's a little more readable than the
equivalent Python source form for the dictionary.)

  The ids for loggers are the logger names which would be used
programmatically to obtain a reference to those loggers, e.g.
`foo.bar.baz'.  The ids for Formatters and Filters can be any string
value (such as `brief', `precise' above) and they are transient, in
that they are only meaningful for processing the configuration
dictionary and used to determine connections between objects, and are
not persisted anywhere when the configuration call is complete.

  The above snippet indicates that logger named `foo.bar.baz' should
have two handlers attached to it, which are described by the handler
ids `h1' and `h2'. The formatter for `h1' is that described by id
`brief', and the formatter for `h2' is that described by id `precise'.


File: python.info,  Node: User-defined objects,  Next: Access to external objects,  Prev: Object connections,  Up: Configuration dictionary schema

5.15.8.6 User-defined objects
.............................

The schema supports user-defined objects for handlers, filters and
formatters.  (Loggers do not need to have different types for different
instances, so there is no support in this configuration schema for
user-defined logger classes.)

  Objects to be configured are described by dictionaries which detail
their configuration.  In some places, the logging system will be able
to infer from the context how an object is to be instantiated, but when
a user-defined object is to be instantiated, the system will not know
how to do this.  In order to provide complete flexibility for
user-defined object instantiation, the user needs to provide a
'factory' - a callable which is called with a configuration dictionary
and which returns the instantiated object.  This is signalled by an
absolute import path to the factory being made available under the
special key `'()''.  Here's a concrete example:

    formatters:
      brief:
        format: '%(message)s'
      default:
        format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'
        datefmt: '%Y-%m-%d %H:%M:%S'
      custom:
          (): my.package.customFormatterFactory
          bar: baz
          spam: 99.9
          answer: 42

The above YAML snippet defines three formatters.  The first, with id
`brief', is a standard *note logging.Formatter: 1269. instance with the
specified format string.  The second, with id `default', has a longer
format and also defines the time format explicitly, and will result in
a *note logging.Formatter: 1269. initialized with those two format
strings.  Shown in Python source form, the `brief' and `default'
formatters have configuration sub-dictionaries:

    {
      'format' : '%(message)s'
    }

and:

    {
      'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',
      'datefmt' : '%Y-%m-%d %H:%M:%S'
    }

respectively, and as these dictionaries do not contain the special key
`'()'', the instantiation is inferred from the context: as a result,
standard *note logging.Formatter: 1269. instances are created.  The
configuration sub-dictionary for the third formatter, with id `custom',
is:

    {
      '()' : 'my.package.customFormatterFactory',
      'bar' : 'baz',
      'spam' : 99.9,
      'answer' : 42
    }

and this contains the special key `'()'', which means that user-defined
instantiation is wanted.  In this case, the specified factory callable
will be used. If it is an actual callable it will be used directly -
otherwise, if you specify a string (as in the example) the actual
callable will be located using normal import mechanisms.  The callable
will be called with the *remaining* items in the configuration
sub-dictionary as keyword arguments.  In the above example, the
formatter with id `custom' will be assumed to be returned by the call:

    my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)

The key `'()'' has been used as the special key because it is not a
valid keyword parameter name, and so will not clash with the names of
the keyword arguments used in the call.  The `'()'' also serves as a
mnemonic that the corresponding value is a callable.


File: python.info,  Node: Access to external objects,  Next: Access to internal objects,  Prev: User-defined objects,  Up: Configuration dictionary schema

5.15.8.7 Access to external objects
...................................

There are times where a configuration needs to refer to objects
external to the configuration, for example `sys.stderr'.  If the
configuration dict is constructed using Python code, this is
straightforward, but a problem arises when the configuration is
provided via a text file (e.g. JSON, YAML).  In a text file, there is
no standard way to distinguish `sys.stderr' from the literal string
`'sys.stderr''.  To facilitate this distinction, the configuration
system looks for certain special prefixes in string values and treat
them specially.  For example, if the literal string
`'ext://sys.stderr'' is provided as a value in the configuration, then
the `ext://' will be stripped off and the remainder of the value
processed using normal import mechanisms.

  The handling of such prefixes is done in a way analogous to protocol
handling: there is a generic mechanism to look for prefixes which match
the regular expression `^(?P<prefix>[a-z]+)://(?P<suffix>.*)$' whereby,
if the `prefix' is recognised, the `suffix' is processed in a
prefix-dependent manner and the result of the processing replaces the
string value.  If the prefix is not recognised, then the string value
will be left as-is.


File: python.info,  Node: Access to internal objects,  Prev: Access to external objects,  Up: Configuration dictionary schema

5.15.8.8 Access to internal objects
...................................

As well as external objects, there is sometimes also a need to refer to
objects in the configuration.  This will be done implicitly by the
configuration system for things that it knows about.  For example, the
string value `'DEBUG'' for a `level' in a logger or handler will
automatically be converted to the value `logging.DEBUG', and the
`handlers', `filters' and `formatter' entries will take an object id
and resolve to the appropriate destination object.

  However, a more generic mechanism is needed for user-defined objects
which are not known to the *note logging: 102. module.  For example,
consider *note logging.handlers.MemoryHandler: 12cb, which takes a
`target' argument which is another handler to delegate to. Since the
system already knows about this class, then in the configuration, the
given `target' just needs to be the object id of the relevant target
handler, and the system will resolve to the handler from the id.  If,
however, a user defines a `my.package.MyHandler' which has an
`alternate' handler, the configuration system would not know that the
`alternate' referred to a handler.  To cater for this, a generic
resolution system allows the user to specify:

    handlers:
      file:
        # configuration of file handler goes here

      custom:
        (): my.package.MyHandler
        alternate: cfg://handlers.file

The literal string `'cfg://handlers.file'' will be resolved in an
analogous way to strings with the `ext://' prefix, but looking in the
configuration itself rather than the import namespace.  The mechanism
allows access by dot or by index, in a similar way to that provided by
`str.format'.  Thus, given the following snippet:

    handlers:
      email:
        class: logging.handlers.SMTPHandler
        mailhost: localhost
        fromaddr: my_app@domain.tld
        toaddrs:
          - support_team@domain.tld
          - dev_team@domain.tld
        subject: Houston, we have a problem.

in the configuration, the string `'cfg://handlers'' would resolve to
the dict with key `handlers', the string `'cfg://handlers.email' would
resolve to the dict with key `email' in the `handlers' dict, and so on.
The string `'cfg://handlers.email.toaddrs[1]' would resolve to
`'dev_team.domain.tld'' and the string
`'cfg://handlers.email.toaddrs[0]'' would resolve to the value
`'support_team@domain.tld''. The `subject' value could be accessed
using either `'cfg://handlers.email.subject'' or, equivalently,
`'cfg://handlers.email[subject]''.  The latter form only needs to be
used if the key contains spaces or non-alphanumeric characters.  If an
index value consists only of decimal digits, access will be attempted
using the corresponding integer value, falling back to the string value
if needed.

  Given a string `cfg://handlers.myhandler.mykey.123', this will
resolve to `config_dict['handlers']['myhandler']['mykey']['123']'.  If
the string is specified as `cfg://handlers.myhandler.mykey[123]', the
system will attempt to retrieve the value from
`config_dict['handlers']['myhandler']['mykey'][123]', and fall back to
`config_dict['handlers']['myhandler']['mykey']['123']' if that fails.

