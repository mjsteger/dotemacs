This is python.info, produced by makeinfo version 4.8 from
build/texinfo/python.texi.

Generated by Sphinx 1.1pre.
INFO-DIR-SECTION Documentation tools
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY

     Python 2.7.2, April 02, 2012

     Georg Brandl

     Copyright (C) 1990-2012, Python Software Foundation


File: python.info,  Node: Additional notes,  Prev: Parser class API,  Up: email Parsing email messages

5.18.1.5 Additional notes
.........................

Here are some notes on the parsing semantics:

   * Most non-`multipart' type messages are parsed as a single message
     object with a string payload.  These objects will return `False'
     for `is_multipart()'.  Their `get_payload()' method will return a
     string object.

   * All `multipart' type messages will be parsed as a container message
     object with a list of sub-message objects for their payload.  The
     outer container message will return `True' for `is_multipart()'
     and their `get_payload()' method will return the list of *note
     Message: 213.  subparts.

   * Most messages with a content type of `message/*' (e.g.
     `message/delivery-status' and `message/rfc822') will also be
     parsed as container object containing a list payload of length 1.
     Their `is_multipart()' method will return `True'.  The single
     element in the list payload will be a sub-message object.

   * Some non-standards compliant messages may not be internally
     consistent about their `multipart'-edness.  Such messages may have
     a `Content-Type' header of type `multipart', but their
     `is_multipart()' method may return `False'.  If such messages were
     parsed with the `FeedParser', they will have an instance of the
     `MultipartInvariantViolationDefect' class in their _defects_
     attribute list.  See *note email.errors: bf. for details.


File: python.info,  Node: email Generating MIME documents,  Next: email Creating email and MIME objects from scratch,  Prev: email Parsing email messages,  Up: email --- An email and MIME handling package

5.18.1.6 `email': Generating MIME documents
...........................................

One of the most common tasks is to generate the flat text of the email
message represented by a message object structure.  You will need to do
this if you want to send your message via the *note smtplib: 15b.
module or the *note nntplib: 125. module, or print the message on the
console.  Taking a message object structure and producing a flat text
document is the job of the *note Generator: 175c. class.

  Again, as with the *note email.parser: c5. module, you aren't limited
to the functionality of the bundled generator; you could write one from
scratch yourself.  However the bundled generator knows how to generate
most email in a standards-compliant way, should handle MIME and
non-MIME email messages just fine, and is designed so that the
transformation from flat text, to a message structure via the *note
Parser: 1787. class, and back to flat text, is idempotent (the input is
identical to the output).  On the other hand, using the Generator on a
*note Message: 213. constructed by program may result in changes to the
*note Message: 213. object as defaults are filled in.

  Here are the public methods of the *note Generator: 175c. class,
imported from the *note email.generator: c0. module:

 -- Class: email.generator.Generator (outfp[, mangle_from_[,
          maxheaderlen]])
     The constructor for the *note Generator: 175c. class takes a
     file-like object called _outfp_ for an argument.  _outfp_ must
     support the *note write(): 1798. method and be usable as the
     output file in a Python extended print statement.

     Optional _mangle_from__ is a flag that, when `True', puts a `>'
     character in front of any line in the body that starts exactly as
     `From', i.e. `From' followed by a space at the beginning of the
     line.  This is the only guaranteed portable way to avoid having
     such lines be mistaken for a Unix mailbox format envelope header
     separator (see WHY THE CONTENT-LENGTH FORMAT IS BAD(1) for
     details).  _mangle_from__ defaults to `True', but you might want
     to set this to `False' if you are not writing Unix mailbox format
     files.

     Optional _maxheaderlen_ specifies the longest length for a
     non-continued header.  When a header line is longer than
     _maxheaderlen_ (in characters, with tabs expanded to 8 spaces),
     the header will be split as defined in the *note Header: 1799.
     class.  Set to zero to disable header wrapping.  The default is
     78, as recommended (but not required) by RFC 2822(2).

     The other public *note Generator: 175c. methods are:

      -- Method: flatten (msg[, unixfrom])
          Print the textual representation of the message object
          structure rooted at _msg_ to the output file specified when
          the *note Generator: 175c. instance was created.  Subparts
          are visited depth-first and the resulting text will be
          properly MIME encoded.

          Optional _unixfrom_ is a flag that forces the printing of the
          envelope header delimiter before the first RFC 2822(3) header
          of the root message object.  If the root object has no
          envelope header, a standard one is crafted.  By default, this
          is set to `False' to inhibit the printing of the envelope
          delimiter.

          Note that for subparts, no envelope header is ever printed.

          New in version 2.2.2.

      -- Method: clone (fp)
          Return an independent clone of this *note Generator: 175c.
          instance with the exact same options.

          New in version 2.2.2.

      -- Method: write (s)
          Write the string _s_ to the underlying file object, i.e.
          _outfp_ passed to *note Generator: 175c.'s constructor.  This
          provides just enough file-like API for *note Generator: 175c.
          instances to be used in extended print statements.

  As a convenience, see the methods `Message.as_string()' and
`str(aMessage)', a.k.a. `Message.__str__()', which simplify the
generation of a formatted string representation of a message object.
For more detail, see *note email.message: c3.

  The *note email.generator: c0. module also provides a derived class,
called *note DecodedGenerator: 179c. which is like the *note Generator:
175c. base class, except that non-`text' parts are substituted with a
format string representing the part.

 -- Class: email.generator.DecodedGenerator (outfp[, mangle_from_[,
          maxheaderlen[, fmt]]])
     This class, derived from *note Generator: 175c. walks through all
     the subparts of a message.  If the subpart is of main type `text',
     then it prints the decoded payload of the subpart. Optional
     __mangle_from__ and _maxheaderlen_ are as with the *note
     Generator: 175c. base class.

     If the subpart is not of main type `text', optional _fmt_ is a
     format string that is used instead of the message payload. _fmt_
     is expanded with the following keywords, `%(keyword)s' format:

        * `type' - Full MIME type of the non-`text' part

        * `maintype' - Main MIME type of the non-`text' part

        * `subtype' - Sub-MIME type of the non-`text' part

        * `filename' - Filename of the non-`text' part

        * `description' - Description associated with the non-`text'
          part

        * `encoding' - Content transfer encoding of the non-`text' part

     The default value for _fmt_ is `None', meaning

         [Non-text (%(type)s) part of message omitted, filename %(filename)s]

     New in version 2.2.2.

  Changed in version 2.5: The previously deprecated method *note
__call__(): 6d4. was removed.

  ---------- Footnotes ----------

  (1) http://www.jwz.org/doc/content-length.html

  (2) http://tools.ietf.org/html/rfc2822.html

  (3) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email Creating email and MIME objects from scratch,  Next: email Internationalized headers,  Prev: email Generating MIME documents,  Up: email --- An email and MIME handling package

5.18.1.7 `email': Creating email and MIME objects from scratch
..............................................................

Ordinarily, you get a message object structure by passing a file or
some text to a parser, which parses the text and returns the root
message object.  However you can also build a complete message
structure from scratch, or even individual *note Message: 213. objects
by hand.  In fact, you can also take an existing structure and add new
*note Message: 213. objects, move them around, etc.  This makes a very
convenient interface for slicing-and-dicing MIME messages.

  You can create a new object structure by creating *note Message: 213.
instances, adding attachments and all the appropriate headers manually.
For MIME messages though, the *note email: bc. package provides some
convenient subclasses to make things easier.

  Here are the classes:

 -- Class: email.mime.base.MIMEBase (_maintype, _subtype, **_params)
     Module: `email.mime.base'

     This is the base class for all the MIME-specific subclasses of
     *note Message: 213.  Ordinarily you won't create instances
     specifically of *note MIMEBase: 179f, although you could.  *note
     MIMEBase: 179f.  is provided primarily as a convenient base class
     for more specific MIME-aware subclasses.

     __maintype_ is the `Content-Type' major type (e.g. `text' or
     `image'), and __subtype_ is the `Content-Type' minor type  (e.g.
     `plain' or `gif').  __params_ is a parameter key/value dictionary
     and is passed directly to `Message.add_header()'.

     The *note MIMEBase: 179f. class always adds a `Content-Type' header
     (based on __maintype_, __subtype_, and __params_), and a
     `MIME-Version' header (always set to `1.0').

 -- Class: email.mime.nonmultipart.MIMENonMultipart
     Module: `email.mime.nonmultipart'

     A subclass of *note MIMEBase: 179f, this is an intermediate base
     class for MIME messages that are not `multipart'.  The primary
     purpose of this class is to prevent the use of the `attach()'
     method, which only makes sense for `multipart' messages.  If
     `attach()' is called, a *note MultipartConversionError: 17a1.
     exception is raised.

     New in version 2.2.2.

 -- Class: email.mime.multipart.MIMEMultipart ([_subtype[, boundary[,
          _subparts[, _params]]]])
     Module: `email.mime.multipart'

     A subclass of *note MIMEBase: 179f, this is an intermediate base
     class for MIME messages that are `multipart'.  Optional __subtype_
     defaults to `mixed', but can be used to specify the subtype of the
     message.  A `Content-Type' header of `multipart/_subtype' will be
     added to the message object.  A `MIME-Version' header will also be
     added.

     Optional _boundary_ is the multipart boundary string.  When `None'
     (the default), the boundary is calculated when needed (for
     example, when the message is serialized).

     __subparts_ is a sequence of initial subparts for the payload.  It
     must be possible to convert this sequence to a list.  You can
     always attach new subparts to the message by using the
     `Message.attach()' method.

     Additional parameters for the `Content-Type' header are taken from
     the keyword arguments, or passed into the __params_ argument,
     which is a keyword dictionary.

     New in version 2.2.2.

 -- Class: email.mime.application.MIMEApplication (_data[, _subtype[,
          _encoder[, **_params]]])
     Module: `email.mime.application'

     A subclass of *note MIMENonMultipart: 17a0, the *note
     MIMEApplication: 17a3. class is used to represent MIME message
     objects of major type `application'.  __data_ is a string
     containing the raw byte data.  Optional __subtype_ specifies the
     MIME subtype and defaults to `octet-stream'.

     Optional __encoder_ is a callable (i.e. function) which will
     perform the actual encoding of the data for transport.  This
     callable takes one argument, which is the *note MIMEApplication:
     17a3. instance. It should use `get_payload()' and `set_payload()'
     to change the payload to encoded form.  It should also add any
     `Content-Transfer-Encoding' or other headers to the message object
     as necessary.  The default encoding is base64.  See the *note
     email.encoders: be. module for a list of the built-in encoders.

     __params_ are passed straight through to the base class
     constructor.

     New in version 2.5.

 -- Class: email.mime.audio.MIMEAudio (_audiodata[, _subtype[,
          _encoder[, **_params]]])
     Module: `email.mime.audio'

     A subclass of *note MIMENonMultipart: 17a0, the *note MIMEAudio:
     17a4. class is used to create MIME message objects of major type
     `audio'. __audiodata_ is a string containing the raw audio data.
     If this data can be decoded by the standard Python module *note
     sndhdr: 15c, then the subtype will be automatically included in
     the `Content-Type' header.  Otherwise you can explicitly specify
     the audio subtype via the __subtype_ parameter.  If the minor type
     could not be guessed and __subtype_ was not given, then *note
     TypeError: 215. is raised.

     Optional __encoder_ is a callable (i.e. function) which will
     perform the actual encoding of the audio data for transport.  This
     callable takes one argument, which is the *note MIMEAudio: 17a4.
     instance. It should use `get_payload()' and `set_payload()' to
     change the payload to encoded form.  It should also add any
     `Content-Transfer-Encoding' or other headers to the message object
     as necessary.  The default encoding is base64.  See the *note
     email.encoders: be. module for a list of the built-in encoders.

     __params_ are passed straight through to the base class
     constructor.

 -- Class: email.mime.image.MIMEImage (_imagedata[, _subtype[,
          _encoder[, **_params]]])
     Module: `email.mime.image'

     A subclass of *note MIMENonMultipart: 17a0, the *note MIMEImage:
     17a5. class is used to create MIME message objects of major type
     `image'. __imagedata_ is a string containing the raw image data.
     If this data can be decoded by the standard Python module *note
     imghdr: f5, then the subtype will be automatically included in the
     `Content-Type' header.  Otherwise you can explicitly specify the
     image subtype via the __subtype_ parameter.  If the minor type
     could not be guessed and __subtype_ was not given, then *note
     TypeError: 215. is raised.

     Optional __encoder_ is a callable (i.e. function) which will
     perform the actual encoding of the image data for transport.  This
     callable takes one argument, which is the *note MIMEImage: 17a5.
     instance. It should use `get_payload()' and `set_payload()' to
     change the payload to encoded form.  It should also add any
     `Content-Transfer-Encoding' or other headers to the message object
     as necessary.  The default encoding is base64.  See the *note
     email.encoders: be. module for a list of the built-in encoders.

     __params_ are passed straight through to the *note MIMEBase: 179f.
     constructor.

 -- Class: email.mime.message.MIMEMessage (_msg[, _subtype])
     Module: `email.mime.message'

     A subclass of *note MIMENonMultipart: 17a0, the *note MIMEMessage:
     17a6. class is used to create MIME objects of main type `message'.
     __msg_ is used as the payload, and must be an instance of class
     *note Message: 213. (or a subclass thereof), otherwise a *note
     TypeError: 215. is raised.

     Optional __subtype_ sets the subtype of the message; it defaults to
     `rfc822'.

 -- Class: email.mime.text.MIMEText (_text[, _subtype[, _charset]])
     Module: `email.mime.text'

     A subclass of *note MIMENonMultipart: 17a0, the *note MIMEText:
     17a7. class is used to create MIME objects of major type `text'.
     __text_ is the string for the payload.  __subtype_ is the minor
     type and defaults to `plain'.  __charset_ is the character set of
     the text and is passed as a parameter to the *note
     MIMENonMultipart: 17a0. constructor; it defaults to `us-ascii'.
     If __text_ is unicode, it is encoded using the _output_charset_ of
     __charset_, otherwise it is used as-is.

     Changed in version 2.4: The previously deprecated __encoding_
     argument has been removed.  Content Transfer Encoding now happens
     happens implicitly based on the __charset_ argument.


File: python.info,  Node: email Internationalized headers,  Next: email Representing character sets,  Prev: email Creating email and MIME objects from scratch,  Up: email --- An email and MIME handling package

5.18.1.8 `email': Internationalized headers
...........................................

RFC 2822(1) is the base standard that describes the format of email
messages.  It derives from the older RFC 822(2) standard which came
into widespread use at a time when most email was composed of ASCII
characters only.  RFC 2822(3) is a specification written assuming email
contains only 7-bit ASCII characters.

  Of course, as email has been deployed worldwide, it has become
internationalized, such that language specific character sets can now
be used in email messages.  The base standard still requires email
messages to be transferred using only 7-bit ASCII characters, so a slew
of RFCs have been written describing how to encode email containing
non-ASCII characters into RFC 2822(4)-compliant format. These RFCs
include RFC 2045(5), RFC 2046(6), RFC 2047(7), and RFC 2231(8). The
*note email: bc. package supports these standards in its *note
email.header: c1. and *note email.charset: bd. modules.

  If you want to include non-ASCII characters in your email headers,
say in the `Subject' or `To' fields, you should use the *note Header:
1799. class and assign the field in the *note Message: 213.  object to
an instance of *note Header: 1799. instead of using a string for the
header value.  Import the *note Header: 1799. class from the *note
email.header: c1. module.  For example:

    >>> from email.message import Message
    >>> from email.header import Header
    >>> msg = Message()
    >>> h = Header('p\xf6stal', 'iso-8859-1')
    >>> msg['Subject'] = h
    >>> print msg.as_string()
    Subject: =?iso-8859-1?q?p=F6stal?=

Notice here how we wanted the `Subject' field to contain a non-ASCII
character?  We did this by creating a *note Header: 1799. instance and
passing in the character set that the byte string was encoded in.  When
the subsequent *note Message: 213. instance was flattened, the `Subject'
field was properly RFC 2047(9) encoded.  MIME-aware mail readers would
show this header using the embedded ISO-8859-1 character.

  New in version 2.2.2.

  Here is the *note Header: 1799. class description:

 -- Class: email.header.Header ([s[, charset[, maxlinelen[,
          header_name[, continuation_ws[, errors]]]]]])
     Create a MIME-compliant header that can contain strings in
     different character sets.

     Optional _s_ is the initial header value.  If `None' (the
     default), the initial header value is not set.  You can later
     append to the header with *note append(): 17aa. method calls.  _s_
     may be a byte string or a Unicode string, but see the *note
     append(): 17aa. documentation for semantics.

     Optional _charset_ serves two purposes: it has the same meaning as
     the _charset_ argument to the *note append(): 17aa. method.  It
     also sets the default character set for all subsequent *note
     append(): 17aa. calls that omit the _charset_ argument.  If
     _charset_ is not provided in the constructor (the default), the
     `us-ascii' character set is used both as _s_'s initial charset and
     as the default for subsequent *note append(): 17aa. calls.

     The maximum line length can be specified explicitly via
     _maxlinelen_.  For splitting the first line to a shorter value (to
     account for the field header which isn't included in _s_, e.g.
     `Subject') pass in the name of the field in _header_name_.  The
     default _maxlinelen_ is 76, and the default value for
     _header_name_ is `None', meaning it is not taken into account for
     the first line of a long, split header.

     Optional _continuation_ws_ must be RFC 2822(10)-compliant folding
     whitespace, and is usually either a space or a hard tab character.
     This character will be prepended to continuation lines.
     _continuation_ws_ defaults to a single space character (" ").

     Optional _errors_ is passed straight through to the *note
     append(): 17aa. method.

      -- Method: append (s[, charset[, errors]])
          Append the string _s_ to the MIME header.

          Optional _charset_, if given, should be a *note Charset: 1765.
          instance (see *note email.charset: bd.) or the name of a
          character set, which will be converted to a *note Charset:
          1765. instance.  A value of `None' (the default) means that
          the _charset_ given in the constructor is used.

          _s_ may be a byte string or a Unicode string.  If it is a
          byte string (i.e.  `isinstance(s, str)' is true), then
          _charset_ is the encoding of that byte string, and a *note
          UnicodeError: 422. will be raised if the string cannot be
          decoded with that character set.

          If _s_ is a Unicode string, then _charset_ is a hint
          specifying the character set of the characters in the string.
          In this case, when producing an RFC 2822(11)-compliant
          header using RFC 2047(12) rules, the Unicode string will be
          encoded using the following charsets in order: `us-ascii',
          the _charset_ hint, `utf-8'.  The first character set to not
          provoke a *note UnicodeError: 422. is used.

          Optional _errors_ is passed through to any *note unicode():
          1f2. or `ustr.encode()' call, and defaults to "strict".

      -- Method: encode ([splitchars])
          Encode a message header into an RFC-compliant format,
          possibly wrapping long lines and encapsulating non-ASCII
          parts in base64 or quoted-printable encodings.  Optional
          _splitchars_ is a string containing characters to split long
          ASCII lines on, in rough support of RFC 2822(13)'s _highest
          level syntactic breaks_.  This doesn't affect RFC 2047(14)
          encoded lines.

     The *note Header: 1799. class also provides a number of methods to
     support standard operators and built-in functions.

      -- Method: __str__ ()
          A synonym for *note Header.encode(): 17ab.  Useful for
          `str(aHeader)'.

      -- Method: __unicode__ ()
          A helper for the built-in *note unicode(): 1f2. function.
          Returns the header as a Unicode string.

      -- Method: __eq__ (other)
          This method allows you to compare two *note Header: 1799.
          instances for equality.

      -- Method: __ne__ (other)
          This method allows you to compare two *note Header: 1799.
          instances for inequality.

  The *note email.header: c1. module also provides the following
convenient functions.

 -- Function: email.header.decode_header (header)
     Decode a message header value without converting the character
     set. The header value is in _header_.

     This function returns a list of `(decoded_string, charset)' pairs
     containing each of the decoded parts of the header.  _charset_ is
     `None' for non-encoded parts of the header, otherwise a lower case
     string containing the name of the character set specified in the
     encoded string.

     Here's an example:

         >>> from email.header import decode_header
         >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
         [('p\xf6stal', 'iso-8859-1')]



 -- Function: email.header.make_header (decoded_seq[, maxlinelen[,
          header_name[, continuation_ws]]])
     Create a *note Header: 1799. instance from a sequence of pairs as
     returned by *note decode_header(): 17b0.

     *note decode_header(): 17b0. takes a header value string and
     returns a sequence of pairs of the format `(decoded_string,
     charset)' where _charset_ is the name of the character set.

     This function takes one of those sequence of pairs and returns a
     *note Header: 1799.  instance.  Optional _maxlinelen_,
     _header_name_, and _continuation_ws_ are as in the *note Header:
     1799. constructor.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html

  (2) http://tools.ietf.org/html/rfc822.html

  (3) http://tools.ietf.org/html/rfc2822.html

  (4) http://tools.ietf.org/html/rfc2822.html

  (5) http://tools.ietf.org/html/rfc2045.html

  (6) http://tools.ietf.org/html/rfc2046.html

  (7) http://tools.ietf.org/html/rfc2047.html

  (8) http://tools.ietf.org/html/rfc2231.html

  (9) http://tools.ietf.org/html/rfc2047.html

  (10) http://tools.ietf.org/html/rfc2822.html

  (11) http://tools.ietf.org/html/rfc2822.html

  (12) http://tools.ietf.org/html/rfc2047.html

  (13) http://tools.ietf.org/html/rfc2822.html

  (14) http://tools.ietf.org/html/rfc2047.html


File: python.info,  Node: email Representing character sets,  Next: email Encoders,  Prev: email Internationalized headers,  Up: email --- An email and MIME handling package

5.18.1.9 `email': Representing character sets
.............................................

This module provides a class *note Charset: 1765. for representing
character sets and character set conversions in email messages, as well
as a character set registry and several convenience methods for
manipulating this registry.  Instances of *note Charset: 1765. are used
in several other modules within the *note email: bc. package.

  Import this class from the *note email.charset: bd. module.

  New in version 2.2.2.

 -- Class: email.charset.Charset ([input_charset])
     Map character sets to their email properties.

     This class provides information about the requirements imposed on
     email for a specific character set.  It also provides convenience
     routines for converting between character sets, given the
     availability of the applicable codecs.  Given a character set, it
     will do its best to provide information on how to use that
     character set in an email message in an RFC-compliant way.

     Certain character sets must be encoded with quoted-printable or
     base64 when used in email headers or bodies.  Certain character
     sets must be converted outright, and are not allowed in email.

     Optional _input_charset_ is as described below; it is always
     coerced to lower case.  After being alias normalized it is also
     used as a lookup into the registry of character sets to find out
     the header encoding, body encoding, and output conversion codec to
     be used for the character set.  For example, if _input_charset_ is
     `iso-8859-1', then headers and bodies will be encoded using
     quoted-printable and no output conversion codec is necessary.  If
     _input_charset_ is `euc-jp', then headers will be encoded with
     base64, bodies will not be encoded, but output text will be
     converted from the `euc-jp' character set to the `iso-2022-jp'
     character set.

     *note Charset: 1765. instances have the following data attributes:

      -- Attribute: input_charset
          The initial character set specified.  Common aliases are
          converted to their _official_ email names (e.g. `latin_1' is
          converted to `iso-8859-1').  Defaults to 7-bit `us-ascii'.

      -- Attribute: header_encoding
          If the character set must be encoded before it can be used in
          an email header, this attribute will be set to `Charset.QP'
          (for quoted-printable), `Charset.BASE64' (for base64
          encoding), or `Charset.SHORTEST' for the shortest of QP or
          BASE64 encoding. Otherwise, it will be `None'.

      -- Attribute: body_encoding
          Same as _header_encoding_, but describes the encoding for the
          mail message's body, which indeed may be different than the
          header encoding.  `Charset.SHORTEST' is not allowed for
          _body_encoding_.

      -- Attribute: output_charset
          Some character sets must be converted before they can be used
          in email headers or bodies.  If the _input_charset_ is one of
          them, this attribute will contain the name of the character
          set output will be converted to.  Otherwise, it will be
          `None'.

      -- Attribute: input_codec
          The name of the Python codec used to convert the
          _input_charset_ to Unicode.  If no conversion codec is
          necessary, this attribute will be `None'.

      -- Attribute: output_codec
          The name of the Python codec used to convert Unicode to the
          _output_charset_.  If no conversion codec is necessary, this
          attribute will have the same value as the _input_codec_.

     *note Charset: 1765. instances also have the following methods:

      -- Method: get_body_encoding ()
          Return the content transfer encoding used for body encoding.

          This is either the string `quoted-printable' or `base64'
          depending on the encoding used, or it is a function, in which
          case you should call the function with a single argument, the
          Message object being encoded.  The function should then set
          the `Content-Transfer-Encoding' header itself to whatever is
          appropriate.

          Returns the string `quoted-printable' if _body_encoding_ is
          `QP', returns the string `base64' if _body_encoding_ is
          `BASE64', and returns the string `7bit' otherwise.

      -- Method: convert (s)
          Convert the string _s_ from the _input_codec_ to the
          _output_codec_.

      -- Method: to_splittable (s)
          Convert a possibly multibyte string to a safely splittable
          format. _s_ is the string to split.

          Uses the _input_codec_ to try and convert the string to
          Unicode, so it can be safely split on character boundaries
          (even for multibyte characters).

          Returns the string as-is if it isn't known how to convert _s_
          to Unicode with the _input_charset_.

          Characters that could not be converted to Unicode will be
          replaced with the Unicode replacement character `'U+FFFD''.

      -- Method: from_splittable (ustr[, to_output])
          Convert a splittable string back into an encoded string.
          _ustr_ is a Unicode string to "unsplit".

          This method uses the proper codec to try and convert the
          string from Unicode back into an encoded format.  Return the
          string as-is if it is not Unicode, or if it could not be
          converted from Unicode.

          Characters that could not be converted from Unicode will be
          replaced with an appropriate character (usually `'?'').

          If _to_output_ is `True' (the default), uses _output_codec_
          to convert to an encoded format.  If _to_output_ is `False',
          it uses _input_codec_.

      -- Method: get_output_charset ()
          Return the output character set.

          This is the _output_charset_ attribute if that is not `None',
          otherwise it is _input_charset_.

      -- Method: encoded_header_len ()
          Return the length of the encoded header string, properly
          calculating for quoted-printable or base64 encoding.

      -- Method: header_encode (s[, convert])
          Header-encode the string _s_.

          If _convert_ is `True', the string will be converted from the
          input charset to the output charset automatically.  This is
          not useful for multibyte character sets, which have line
          length issues (multibyte characters must be split on a
          character, not a byte boundary); use the higher-level *note
          Header: 1799. class to deal with these issues (see *note
          email.header: c1.).  _convert_ defaults to `False'.

          The type of encoding (base64 or quoted-printable) will be
          based on the _header_encoding_ attribute.

      -- Method: body_encode (s[, convert])
          Body-encode the string _s_.

          If _convert_ is `True' (the default), the string will be
          converted from the input charset to output charset
          automatically. Unlike *note header_encode(): 17c0, there are
          no issues with byte boundaries and multibyte charsets in
          email bodies, so this is usually pretty safe.

          The type of encoding (base64 or quoted-printable) will be
          based on the _body_encoding_ attribute.

     The *note Charset: 1765. class also provides a number of methods
     to support standard operations and built-in functions.

      -- Method: __str__ ()
          Returns _input_charset_ as a string coerced to lower case.
          *note __repr__(): 475. is an alias for *note __str__(): 17c2.

      -- Method: __eq__ (other)
          This method allows you to compare two *note Charset: 1765.
          instances for equality.

      -- Method: __ne__ (other)
          This method allows you to compare two *note Charset: 1765.
          instances for inequality.

  The *note email.charset: bd. module also provides the following
functions for adding new entries to the global character set, alias,
and codec registries:

 -- Function: email.charset.add_charset (charset[, header_enc[,
          body_enc[, output_charset]]])
     Add character properties to the global registry.

     _charset_ is the input character set, and must be the canonical
     name of a character set.

     Optional _header_enc_ and _body_enc_ is either `Charset.QP' for
     quoted-printable, `Charset.BASE64' for base64 encoding,
     `Charset.SHORTEST' for the shortest of quoted-printable or base64
     encoding, or `None' for no encoding.  `SHORTEST' is only valid for
     _header_enc_. The default is `None' for no encoding.

     Optional _output_charset_ is the character set that the output
     should be in.  Conversions will proceed from input charset, to
     Unicode, to the output charset when the method *note
     Charset.convert(): 17bb. is called.  The default is to output in
     the same character set as the input.

     Both _input_charset_ and _output_charset_ must have Unicode codec
     entries in the module's character set-to-codec mapping; use *note
     add_codec(): 17c6. to add codecs the module does not know about.
     See the *note codecs: 63. module's documentation for more
     information.

     The global character set registry is kept in the module global
     dictionary `CHARSETS'.

 -- Function: email.charset.add_alias (alias, canonical)
     Add a character set alias.  _alias_ is the alias name, e.g.
     `latin-1'.  _canonical_ is the character set's canonical name,
     e.g. `iso-8859-1'.

     The global charset alias registry is kept in the module global
     dictionary `ALIASES'.

 -- Function: email.charset.add_codec (charset, codecname)
     Add a codec that map characters in the given character set to and
     from Unicode.

     _charset_ is the canonical name of a character set. _codecname_ is
     the name of a Python codec, as appropriate for the second argument
     to the *note unicode(): 1f2.  built-in, or to the `encode()'
     method of a Unicode string.


File: python.info,  Node: email Encoders,  Next: email Exception and Defect classes,  Prev: email Representing character sets,  Up: email --- An email and MIME handling package

5.18.1.10 `email': Encoders
...........................

When creating *note Message: 213. objects from scratch, you often need
to encode the payloads for transport through compliant mail servers.
This is especially true for `image/*' and `text/*' type messages
containing binary data.

  The *note email: bc. package provides some convenient encodings in its
`encoders' module.  These encoders are actually used by the *note
MIMEAudio: 17a4. and *note MIMEImage: 17a5.  class constructors to
provide default encodings.  All encoder functions take exactly one
argument, the message object to encode.  They usually extract the
payload, encode it, and reset the payload to this newly encoded value.
They should also set the `Content-Transfer-Encoding' header as
appropriate.

  Here are the encoding functions provided:

 -- Function: email.encoders.encode_quopri (msg)
     Encodes the payload into quoted-printable form and sets the
     `Content-Transfer-Encoding' header to `quoted-printable' (1).
     This is a good encoding to use when most of your payload is normal
     printable data, but contains a few unprintable characters.

 -- Function: email.encoders.encode_base64 (msg)
     Encodes the payload into base64 form and sets the
     `Content-Transfer-Encoding' header to `base64'.  This is a good
     encoding to use when most of your payload is unprintable data
     since it is a more compact form than quoted-printable.  The
     drawback of base64 encoding is that it renders the text non-human
     readable.

 -- Function: email.encoders.encode_7or8bit (msg)
     This doesn't actually modify the message's payload, but it does
     set the `Content-Transfer-Encoding' header to either `7bit' or
     `8bit' as appropriate, based on the payload data.

 -- Function: email.encoders.encode_noop (msg)
     This does nothing; it doesn't even set the
     `Content-Transfer-Encoding' header.

  ---------- Footnotes ----------

  (1) Note that encoding with *note encode_quopri(): 17ca. also encodes
all tabs and space characters in the data.


File: python.info,  Node: email Exception and Defect classes,  Next: email Miscellaneous utilities,  Prev: email Encoders,  Up: email --- An email and MIME handling package

5.18.1.11 `email': Exception and Defect classes
...............................................

The following exception classes are defined in the *note email.errors:
bf. module:

 -- Exception: email.errors.MessageError
     This is the base class for all exceptions that the *note email:
     bc. package can raise.  It is derived from the standard *note
     Exception: 328. class and defines no additional methods.

 -- Exception: email.errors.MessageParseError
     This is the base class for exceptions raised by the *note Parser:
     1787.  class.  It is derived from *note MessageError: 17d0.

 -- Exception: email.errors.HeaderParseError
     Raised under some error conditions when parsing the RFC 2822(1)
     headers of a message, this class is derived from *note
     MessageParseError: 17d1. It can be raised from the
     `Parser.parse()' or `Parser.parsestr()' methods.

     Situations where it can be raised include finding an envelope
     header after the first RFC 2822(2) header of the message, finding
     a continuation line before the first RFC 2822(3) header is found,
     or finding a line in the headers which is neither a header or a
     continuation line.

 -- Exception: email.errors.BoundaryError
     Raised under some error conditions when parsing the RFC 2822(4)
     headers of a message, this class is derived from *note
     MessageParseError: 17d1. It can be raised from the
     `Parser.parse()' or `Parser.parsestr()' methods.

     Situations where it can be raised include not being able to find
     the starting or terminating boundary in a `multipart/*' message
     when strict parsing is used.

 -- Exception: email.errors.MultipartConversionError
     Raised when a payload is added to a `Message' object using
     `add_payload()', but the payload is already a scalar and the
     message's `Content-Type' main type is not either `multipart' or
     missing.  *note MultipartConversionError: 17a1. multiply inherits
     from *note MessageError: 17d0. and the built-in *note TypeError:
     215.

     Since `Message.add_payload()' is deprecated, this exception is
     rarely raised in practice.  However the exception may also be
     raised if the `attach()' method is called on an instance of a
     class derived from *note MIMENonMultipart: 17a0. (e.g.  *note
     MIMEImage: 17a5.).

  Here's the list of the defects that the `FeedParser' can find while
parsing messages.  Note that the defects are added to the message where
the problem was found, so for example, if a message nested inside a
`multipart/alternative' had a malformed header, that nested message
object would have a defect, but the containing messages would not.

  All defect classes are subclassed from `email.errors.MessageDefect',
but this class is _not_ an exception!

  New in version 2.4: All the defect classes were added.

   * `NoBoundaryInMultipartDefect' - A message claimed to be a
     multipart, but had no `boundary' parameter.

   * `StartBoundaryNotFoundDefect' - The start boundary claimed in the
     `Content-Type' header was never found.

   * `FirstHeaderLineIsContinuationDefect' - The message had a
     continuation line as its first header line.

   * `MisplacedEnvelopeHeaderDefect' - A "Unix From" header was found
     in the middle of a header block.

   * `MalformedHeaderDefect' - A header was found that was missing a
     colon, or was otherwise malformed.

   * `MultipartInvariantViolationDefect' - A message claimed to be a
     `multipart', but no subparts were found.  Note that when a message
     has this defect, its `is_multipart()' method may return false even
     though its content type claims to be `multipart'.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html

  (2) http://tools.ietf.org/html/rfc2822.html

  (3) http://tools.ietf.org/html/rfc2822.html

  (4) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email Miscellaneous utilities,  Next: email Iterators,  Prev: email Exception and Defect classes,  Up: email --- An email and MIME handling package

5.18.1.12 `email': Miscellaneous utilities
..........................................

There are several useful utilities provided in the *note email.utils:
c6. module:

 -- Function: email.utils.quote (str)
     Return a new string with backslashes in _str_ replaced by two
     backslashes, and double quotes replaced by backslash-double quote.

 -- Function: email.utils.unquote (str)
     Return a new string which is an _unquoted_ version of _str_. If
     _str_ ends and begins with double quotes, they are stripped off.
     Likewise if _str_ ends and begins with angle brackets, they are
     stripped off.

 -- Function: email.utils.parseaddr (address)
     Parse address - which should be the value of some
     address-containing field such as `To' or `Cc' - into its
     constituent _realname_ and _email address_ parts.  Returns a tuple
     of that information, unless the parse fails, in which case a
     2-tuple of `('', '')' is returned.

 -- Function: email.utils.formataddr (pair)
     The inverse of *note parseaddr(): 17d7, this takes a 2-tuple of
     the form `(realname, email_address)' and returns the string value
     suitable for a `To' or `Cc' header.  If the first element of
     _pair_ is false, then the second element is returned unmodified.

 -- Function: email.utils.getaddresses (fieldvalues)
     This method returns a list of 2-tuples of the form returned by
     `parseaddr()'.  _fieldvalues_ is a sequence of header field values
     as might be returned by `Message.get_all()'.  Here's a simple
     example that gets all the recipients of a message:

         from email.utils import getaddresses

         tos = msg.get_all('to', [])
         ccs = msg.get_all('cc', [])
         resent_tos = msg.get_all('resent-to', [])
         resent_ccs = msg.get_all('resent-cc', [])
         all_recipients = getaddresses(tos + ccs + resent_tos + resent_ccs)



 -- Function: email.utils.parsedate (date)
     Attempts to parse a date according to the rules in RFC 2822(1).
     however, some mailers don't follow that format as specified, so
     *note parsedate(): 17da. tries to guess correctly in such cases.
     _date_ is a string containing an RFC 2822(2) date, such as  `"Mon,
     20 Nov 1995 19:12:08 -0500"'.  If it succeeds in parsing the date,
     *note parsedate(): 17da. returns a 9-tuple that can be passed
     directly to *note time.mktime(): 119a.; otherwise `None' will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: email.utils.parsedate_tz (date)
     Performs the same function as *note parsedate(): 17da, but returns
     either `None' or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *note time.mktime(): 119a, and the
     tenth is the offset of the date's timezone from UTC (which is the
     official term for Greenwich Mean Time) (3).  If the input string
     has no timezone, the last element of the tuple returned is `None'.
     Note that indexes 6, 7, and 8 of the result tuple are not usable.

 -- Function: email.utils.mktime_tz (tuple)
     Turn a 10-tuple as returned by *note parsedate_tz(): 17db. into a
     UTC timestamp.  It the timezone item in the tuple is `None',
     assume local time.  Minor deficiency: *note mktime_tz(): 17dc.
     interprets the first 8 elements of _tuple_ as a local time and
     then compensates for the timezone difference.  This may yield a
     slight error around changes in daylight savings time, though not
     worth worrying about for common use.

 -- Function: email.utils.formatdate ([timeval[, localtime][, usegmt]])
     Returns a date string as per RFC 2822(4), e.g.:

         Fri, 09 Nov 2001 01:08:47 -0000

     Optional _timeval_ if given is a floating point time value as
     accepted by *note time.gmtime(): b0b. and *note time.localtime():
     a9c, otherwise the current time is used.

     Optional _localtime_ is a flag that when `True', interprets
     _timeval_, and returns a date relative to the local timezone
     instead of UTC, properly taking daylight savings time into
     account. The default is `False' meaning UTC is used.

     Optional _usegmt_ is a flag that when `True', outputs a  date
     string with the timezone as an ascii string `GMT', rather than a
     numeric `-0000'. This is needed for some protocols (such as HTTP).
     This only applies when _localtime_ is `False'.  The default is
     `False'.

     New in version 2.4.

 -- Function: email.utils.make_msgid ([idstring])
     Returns a string suitable for an RFC 2822(5)-compliant
     `Message-ID' header.  Optional _idstring_ if given, is a string
     used to strengthen the uniqueness of the message id.

 -- Function: email.utils.decode_rfc2231 (s)
     Decode the string _s_ according to RFC 2231(6).

 -- Function: email.utils.encode_rfc2231 (s[, charset[, language]])
     Encode the string _s_ according to RFC 2231(7).  Optional
     _charset_ and _language_, if given is the character set name and
     language name to use.  If neither is given, _s_ is returned as-is.
     If _charset_ is given but _language_ is not, the string is
     encoded using the empty string for _language_.

 -- Function: email.utils.collapse_rfc2231_value (value[, errors[,
          fallback_charset]])
     When a header parameter is encoded in RFC 2231(8) format,
     `Message.get_param()' may return a 3-tuple containing the
     character set, language, and value.  *note
     collapse_rfc2231_value(): 177b. turns this into a unicode string.
     Optional _errors_ is passed to the _errors_ argument of the
     built-in *note unicode(): 1f2. function; it defaults to `replace'.
     Optional _fallback_charset_ specifies the character set to use if
     the one in the RFC 2231(9) header is not known by Python; it
     defaults to `us-ascii'.

     For convenience, if the _value_ passed to *note
     collapse_rfc2231_value(): 177b. is not a tuple, it should be a
     string and it is returned unquoted.

 -- Function: email.utils.decode_params (params)
     Decode parameters list according to RFC 2231(10).  _params_ is a
     sequence of 2-tuples containing elements of the form
     `(content-type, string-value)'.

  Changed in version 2.4: The `dump_address_pair()' function has been
removed; use *note formataddr(): 17d8.  instead.

  Changed in version 2.4: The `decode()' function has been removed; use
the `Header.decode_header()' method instead.

  Changed in version 2.4: The `encode()' function has been removed; use
the `Header.encode()' method instead.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html

  (2) http://tools.ietf.org/html/rfc2822.html

  (3) Note that the sign of the timezone offset is the opposite of the
sign of the `time.timezone' variable for the same timezone; the latter
variable follows the POSIX standard while this module follows RFC 2822
(http://tools.ietf.org/html/rfc2822.html).

  (4) http://tools.ietf.org/html/rfc2822.html

  (5) http://tools.ietf.org/html/rfc2822.html

  (6) http://tools.ietf.org/html/rfc2231.html

  (7) http://tools.ietf.org/html/rfc2231.html

  (8) http://tools.ietf.org/html/rfc2231.html

  (9) http://tools.ietf.org/html/rfc2231.html

  (10) http://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email Iterators,  Next: email Examples,  Prev: email Miscellaneous utilities,  Up: email --- An email and MIME handling package

5.18.1.13 `email': Iterators
............................

Iterating over a message object tree is fairly easy with the
`Message.walk()' method.  The *note email.iterators: c2. module
provides some useful higher level iterations over message object trees.

 -- Function: email.iterators.body_line_iterator (msg[, decode])
     This iterates over all the payloads in all the subparts of _msg_,
     returning the string payloads line-by-line.  It skips over all the
     subpart headers, and it skips over any subpart with a payload that
     isn't a Python string.  This is somewhat equivalent to reading the
     flat text representation of the message from a file using *note
     readline(): 145, skipping over all the intervening headers.

     Optional _decode_ is passed through to `Message.get_payload()'.

 -- Function: email.iterators.typed_subpart_iterator (msg[, maintype[,
          subtype]])
     This iterates over all the subparts of _msg_, returning only those
     subparts that match the MIME type specified by _maintype_ and
     _subtype_.

     Note that _subtype_ is optional; if omitted, then subpart MIME
     type matching is done only with the main type.  _maintype_ is
     optional too; it defaults to `text'.

     Thus, by default *note typed_subpart_iterator(): 17e5. returns
     each subpart that has a MIME type of `text/*'.

  The following function has been added as a useful debugging tool.  It
should _not_ be considered part of the supported public interface for
the package.

 -- Function: email.iterators._structure (msg[, fp[, level]])
     Prints an indented representation of the content types of the
     message object structure.  For example:

         >>> msg = email.message_from_file(somefile)
         >>> _structure(msg)
         multipart/mixed
             text/plain
             text/plain
             multipart/digest
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
             text/plain

     Optional _fp_ is a file-like object to print the output to.  It
     must be suitable for Python's extended print statement.  _level_
     is used internally.


File: python.info,  Node: email Examples,  Next: Package History,  Prev: email Iterators,  Up: email --- An email and MIME handling package

5.18.1.14 `email': Examples
...........................

Here are a few examples of how to use the *note email: bc. package to
read, write, and send simple email messages, as well as more complex
MIME messages.

  First, let's see how to create and send a simple text message:

    # Import smtplib for the actual sending function
    import smtplib

    # Import the email modules we'll need
    from email.mime.text import MIMEText

    # Open a plain text file for reading.  For this example, assume that
    # the text file contains only ASCII characters.
    fp = open(textfile, 'rb')
    # Create a text/plain message
    msg = MIMEText(fp.read())
    fp.close()

    # me == the sender's email address
    # you == the recipient's email address
    msg['Subject'] = 'The contents of %s' % textfile
    msg['From'] = me
    msg['To'] = you

    # Send the message via our own SMTP server, but don't include the
    # envelope header.
    s = smtplib.SMTP('localhost')
    s.sendmail(me, [you], msg.as_string())
    s.quit()

And parsing RFC822 headers can easily be done by the parse(filename) or
parsestr(message_as_string) methods of the Parser() class:

    # Import the email modules we'll need
    from email.parser import Parser

    #  If the e-mail headers are in a file, uncomment this line:
    #headers = Parser().parse(open(messagefile, 'r'))

    #  Or for parsing headers in a string, use:
    headers = Parser().parsestr('From: <user@example.com>\n'
            'To: <someone_else@example.com>\n'
            'Subject: Test message\n'
            '\n'
            'Body would go here\n')

    #  Now the header items can be accessed as a dictionary:
    print 'To: %s' % headers['to']
    print 'From: %s' % headers['from']
    print 'Subject: %s' % headers['subject']

Here's an example of how to send a MIME message containing a bunch of
family pictures that may be residing in a directory:

    # Import smtplib for the actual sending function
    import smtplib

    # Here are the email package modules we'll need
    from email.mime.image import MIMEImage
    from email.mime.multipart import MIMEMultipart

    COMMASPACE = ', '

    # Create the container (outer) email message.
    msg = MIMEMultipart()
    msg['Subject'] = 'Our family reunion'
    # me == the sender's email address
    # family = the list of all recipients' email addresses
    msg['From'] = me
    msg['To'] = COMMASPACE.join(family)
    msg.preamble = 'Our family reunion'

    # Assume we know that the image files are all in PNG format
    for file in pngfiles:
        # Open the files in binary mode.  Let the MIMEImage class automatically
        # guess the specific image type.
        fp = open(file, 'rb')
        img = MIMEImage(fp.read())
        fp.close()
        msg.attach(img)

    # Send the email via our own SMTP server.
    s = smtplib.SMTP('localhost')
    s.sendmail(me, family, msg.as_string())
    s.quit()

Here's an example of how to send the entire contents of a directory as
an email message: (1)

    #!/usr/bin/env python

    """Send the contents of a directory as a MIME message."""

    import os
    import sys
    import smtplib
    # For guessing MIME type based on file name extension
    import mimetypes

    from optparse import OptionParser

    from email import encoders
    from email.message import Message
    from email.mime.audio import MIMEAudio
    from email.mime.base import MIMEBase
    from email.mime.image import MIMEImage
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText

    COMMASPACE = ', '


    def main():
        parser = OptionParser(usage="""\
    Send the contents of a directory as a MIME message.

    Usage: %prog [options]

    Unless the -o option is given, the email is sent by forwarding to your local
    SMTP server, which then does the normal delivery process.  Your local machine
    must be running an SMTP server.
    """)
        parser.add_option('-d', '--directory',
                          type='string', action='store',
                          help="""Mail the contents of the specified directory,
                          otherwise use the current directory.  Only the regular
                          files in the directory are sent, and we don't recurse to
                          subdirectories.""")
        parser.add_option('-o', '--output',
                          type='string', action='store', metavar='FILE',
                          help="""Print the composed message to FILE instead of
                          sending the message to the SMTP server.""")
        parser.add_option('-s', '--sender',
                          type='string', action='store', metavar='SENDER',
                          help='The value of the From: header (required)')
        parser.add_option('-r', '--recipient',
                          type='string', action='append', metavar='RECIPIENT',
                          default=[], dest='recipients',
                          help='A To: header value (at least one required)')
        opts, args = parser.parse_args()
        if not opts.sender or not opts.recipients:
            parser.print_help()
            sys.exit(1)
        directory = opts.directory
        if not directory:
            directory = '.'
        # Create the enclosing (outer) message
        outer = MIMEMultipart()
        outer['Subject'] = 'Contents of directory %s' % os.path.abspath(directory)
        outer['To'] = COMMASPACE.join(opts.recipients)
        outer['From'] = opts.sender
        outer.preamble = 'You will not see this in a MIME-aware mail reader.\n'

        for filename in os.listdir(directory):
            path = os.path.join(directory, filename)
            if not os.path.isfile(path):
                continue
            # Guess the content type based on the file's extension.  Encoding
            # will be ignored, although we should check for simple things like
            # gzip'd or compressed files.
            ctype, encoding = mimetypes.guess_type(path)
            if ctype is None or encoding is not None:
                # No guess could be made, or the file is encoded (compressed), so
                # use a generic bag-of-bits type.
                ctype = 'application/octet-stream'
            maintype, subtype = ctype.split('/', 1)
            if maintype == 'text':
                fp = open(path)
                # Note: we should handle calculating the charset
                msg = MIMEText(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'image':
                fp = open(path, 'rb')
                msg = MIMEImage(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'audio':
                fp = open(path, 'rb')
                msg = MIMEAudio(fp.read(), _subtype=subtype)
                fp.close()
            else:
                fp = open(path, 'rb')
                msg = MIMEBase(maintype, subtype)
                msg.set_payload(fp.read())
                fp.close()
                # Encode the payload using Base64
                encoders.encode_base64(msg)
            # Set the filename parameter
            msg.add_header('Content-Disposition', 'attachment', filename=filename)
            outer.attach(msg)
        # Now send or store the message
        composed = outer.as_string()
        if opts.output:
            fp = open(opts.output, 'w')
            fp.write(composed)
            fp.close()
        else:
            s = smtplib.SMTP('localhost')
            s.sendmail(opts.sender, opts.recipients, composed)
            s.quit()


    if __name__ == '__main__':
        main()

Here's an example of how to unpack a MIME message like the one above,
into a directory of files:

    #!/usr/bin/env python

    """Unpack a MIME message into a directory of files."""

    import os
    import sys
    import email
    import errno
    import mimetypes

    from optparse import OptionParser


    def main():
        parser = OptionParser(usage="""\
    Unpack a MIME message into a directory of files.

    Usage: %prog [options] msgfile
    """)
        parser.add_option('-d', '--directory',
                          type='string', action='store',
                          help="""Unpack the MIME message into the named
                          directory, which will be created if it doesn't already
                          exist.""")
        opts, args = parser.parse_args()
        if not opts.directory:
            parser.print_help()
            sys.exit(1)

        try:
            msgfile = args[0]
        except IndexError:
            parser.print_help()
            sys.exit(1)

        try:
            os.mkdir(opts.directory)
        except OSError, e:
            # Ignore directory exists error
            if e.errno != errno.EEXIST:
                raise

        fp = open(msgfile)
        msg = email.message_from_file(fp)
        fp.close()

        counter = 1
        for part in msg.walk():
            # multipart/* are just containers
            if part.get_content_maintype() == 'multipart':
                continue
            # Applications should really sanitize the given filename so that an
            # email message can't be used to overwrite important files
            filename = part.get_filename()
            if not filename:
                ext = mimetypes.guess_extension(part.get_content_type())
                if not ext:
                    # Use a generic bag-of-bits extension
                    ext = '.bin'
                filename = 'part-%03d%s' % (counter, ext)
            counter += 1
            fp = open(os.path.join(opts.directory, filename), 'wb')
            fp.write(part.get_payload(decode=True))
            fp.close()


    if __name__ == '__main__':
        main()

Here's an example of how to create an HTML message with an alternative
plain text version: (2)

    #!/usr/bin/env python

    import smtplib

    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText

    # me == my email address
    # you == recipient's email address
    me = "my@email.com"
    you = "your@email.com"

    # Create message container - the correct MIME type is multipart/alternative.
    msg = MIMEMultipart('alternative')
    msg['Subject'] = "Link"
    msg['From'] = me
    msg['To'] = you

    # Create the body of the message (a plain-text and an HTML version).
    text = "Hi!\nHow are you?\nHere is the link you wanted:\nhttp://www.python.org"
    html = """\
    <html>
      <head></head>
      <body>
        <p>Hi!<br>
           How are you?<br>
           Here is the <a href="http://www.python.org">link</a> you wanted.
        </p>
      </body>
    </html>
    """

    # Record the MIME types of both parts - text/plain and text/html.
    part1 = MIMEText(text, 'plain')
    part2 = MIMEText(html, 'html')

    # Attach parts into message container.
    # According to RFC 2046, the last part of a multipart message, in this case
    # the HTML message, is best and preferred.
    msg.attach(part1)
    msg.attach(part2)

    # Send the message via local SMTP server.
    s = smtplib.SMTP('localhost')
    # sendmail function takes 3 arguments: sender's address, recipient's address
    # and message to send - here it is sent as one string.
    s.sendmail(me, you, msg.as_string())
    s.quit()


See also
........

Module *note smtplib: 15b.
     SMTP protocol client

Module *note nntplib: 125.
     NNTP protocol client

  ---------- Footnotes ----------

  (1) Thanks to Matthew Dixon Cowles for the original inspiration and
examples.

  (2) Contributed by Martin Matejek.


File: python.info,  Node: Package History,  Next: Differences from mimelib,  Prev: email Examples,  Up: email --- An email and MIME handling package

5.18.1.15 Package History
.........................

This table describes the release history of the email package,
corresponding to the version of Python that the package was released
with.  For purposes of this document, when you see a note about change
or added versions, these refer to the Python version the change was
made in, _not_ the email package version.  This table also describes
the Python compatibility of each version of the package.

email version       distributed with                   compatible with
----------------------------------------------------------------------------------- 
`1.x'               Python 2.2.0 to Python 2.2.1       _no longer supported_
`2.5'               Python 2.2.2+ and Python 2.3       Python 2.1 to 2.5
`3.0'               Python 2.4                         Python 2.3 to 2.5
`4.0'               Python 2.5                         Python 2.3 to 2.5

  Here are the major differences between *note email: bc. version 4 and
version 3:

   * All modules have been renamed according to PEP 8(1) standards.
     For example, the version 3 module `email.Message' was renamed to
     *note email.message: c3. in version 4.

   * A new subpackage *note email.mime: c4. was added and all the
     version 3 `email.MIME*' modules were renamed and situated into the
     *note email.mime: c4.  subpackage.  For example, the version 3
     module `email.MIMEText' was renamed to `email.mime.text'.

     _Note that the version 3 names will continue to work until Python
     2.6_.

   * The `email.mime.application' module was added, which contains the
     `MIMEApplication' class.

   * Methods that were deprecated in version 3 have been removed.
     These include `Generator.__call__()', `Message.get_type()',
     `Message.get_main_type()', `Message.get_subtype()'.

   * Fixes have been added for RFC 2231(2) support which can change
     some of the return types for `Message.get_param()' and friends.
     Under some circumstances, values which used to return a 3-tuple
     now return simple strings (specifically, if all extended parameter
     segments were unencoded, there is no language and charset
     designation expected, so the return type is now a simple string).
     Also, %-decoding used to be done for both encoded and unencoded
     segments; this decoding is now done only for encoded segments.

  Here are the major differences between *note email: bc. version 3 and
version 2:

   * The `FeedParser' class was introduced, and the `Parser' class was
     implemented in terms of the `FeedParser'.  All parsing therefore is
     non-strict, and parsing will make a best effort never to raise an
     exception.  Problems found while parsing messages are stored in
     the message's _defect_ attribute.

   * All aspects of the API which raised *note DeprecationWarning:
     1b9.s in version 2 have been removed.  These include the
     __encoder_ argument to the `MIMEText' constructor, the
     `Message.add_payload()' method, the `Utils.dump_address_pair()'
     function, and the functions `Utils.decode()' and `Utils.encode()'.

   * New *note DeprecationWarning: 1b9.s have been added to:
     `Generator.__call__()', `Message.get_type()',
     `Message.get_main_type()', `Message.get_subtype()', and the
     _strict_ argument to the `Parser' class.  These are expected to be
     removed in future versions.

   * Support for Pythons earlier than 2.3 has been removed.

  Here are the differences between *note email: bc. version 2 and
version 1:

   * The `email.Header' and `email.Charset' modules have been added.

   * The pickle format for `Message' instances has changed. Since this
     was never (and still isn't) formally defined, this isn't
     considered a backward incompatibility.  However if your
     application pickles and unpickles `Message' instances, be aware
     that in *note email: bc. version 2, `Message' instances now have
     private variables __charset_ and __default_type_.

   * Several methods in the `Message' class have been deprecated, or
     their signatures changed.  Also, many new methods have been added.
     See the documentation for the `Message' class for details.  The
     changes should be completely backward compatible.

   * The object structure has changed in the face of `message/rfc822'
     content types.  In *note email: bc. version 1, such a type would
     be represented by a scalar payload, i.e. the container message's
     `is_multipart()' returned false, `get_payload()' was not a list
     object, but a single `Message' instance.

     This structure was inconsistent with the rest of the package, so
     the object representation for `message/rfc822' content types was
     changed.  In *note email: bc. version 2, the container _does_
     return `True' from `is_multipart()', and `get_payload()' returns a
     list containing a single `Message' item.

     Note that this is one place that backward compatibility could not
     be completely maintained.  However, if you're already testing the
     return type of `get_payload()', you should be fine.  You just need
     to make sure your code doesn't do a `set_payload()' with a
     `Message' instance on a container with a content type of
     `message/rfc822'.

   * The `Parser' constructor's _strict_ argument was added, and its
     `parse()' and `parsestr()' methods grew a _headersonly_ argument.
     The _strict_ flag was also added to functions *note
     email.message_from_file(): 1794. and *note
     email.message_from_string(): 1793.

   * `Generator.__call__()' is deprecated; use `Generator.flatten()'
     instead.  The `Generator' class has also grown the `clone()'
     method.

   * The `DecodedGenerator' class in the `email.Generator' module was
     added.

   * The intermediate base classes `MIMENonMultipart' and
     `MIMEMultipart' have been added, and interposed in the class
     hierarchy for most of the other MIME-related derived classes.

   * The __encoder_ argument to the `MIMEText' constructor has been
     deprecated.  Encoding  now happens implicitly based on the
     __charset_ argument.

   * The following functions in the `email.Utils' module have been
     deprecated: `dump_address_pairs()', `decode()', and `encode()'.
     The following functions have been added to the module:
     `make_msgid()', `decode_rfc2231()', `encode_rfc2231()', and
     `decode_params()'.

   * The non-public function `email.Iterators._structure()' was added.

  ---------- Footnotes ----------

  (1) http://www.python.org/dev/peps/pep-0008

  (2) http://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: Differences from mimelib,  Prev: Package History,  Up: email --- An email and MIME handling package

5.18.1.16 Differences from `mimelib'
....................................

The *note email: bc. package was originally prototyped as a separate
library called mimelib(1). Changes have been made so that method names
are more consistent, and some methods or modules have either been added
or removed.  The semantics of some of the methods have also changed.
For the most part, any functionality available in `mimelib' is still
available in the *note email: bc. package, albeit often in a different
way.  Backward compatibility between the `mimelib' package and the
*note email: bc. package was not a priority.

  Here is a brief description of the differences between the `mimelib'
and the *note email: bc. packages, along with hints on how to port your
applications.

  Of course, the most visible difference between the two packages is
that the package name has been changed to *note email: bc.  In
addition, the top-level package has the following differences:

   * `messageFromString()' has been renamed to *note
     message_from_string(): 1793.

   * `messageFromFile()' has been renamed to *note message_from_file():
     1794.

  The `Message' class has the following differences:

   * The method `asString()' was renamed to `as_string()'.

   * The method `ismultipart()' was renamed to `is_multipart()'.

   * The `get_payload()' method has grown a _decode_ optional argument.

   * The method `getall()' was renamed to `get_all()'.

   * The method `addheader()' was renamed to `add_header()'.

   * The method `gettype()' was renamed to `get_type()'.

   * The method `getmaintype()' was renamed to `get_main_type()'.

   * The method `getsubtype()' was renamed to `get_subtype()'.

   * The method `getparams()' was renamed to `get_params()'. Also,
     whereas `getparams()' returned a list of strings, `get_params()'
     returns a list of 2-tuples, effectively the key/value pairs of the
     parameters, split on the `'='' sign.

   * The method `getparam()' was renamed to `get_param()'.

   * The method `getcharsets()' was renamed to `get_charsets()'.

   * The method `getfilename()' was renamed to `get_filename()'.

   * The method `getboundary()' was renamed to `get_boundary()'.

   * The method `setboundary()' was renamed to `set_boundary()'.

   * The method `getdecodedpayload()' was removed.  To get similar
     functionality, pass the value 1 to the _decode_ flag of the
     get_payload() method.

   * The method `getpayloadastext()' was removed.  Similar
     functionality is supported by the `DecodedGenerator' class in the
     *note email.generator: c0.  module.

   * The method `getbodyastext()' was removed.  You can get similar
     functionality by creating an iterator with
     `typed_subpart_iterator()' in the *note email.iterators: c2.
     module.

  The `Parser' class has no differences in its public interface. It does
have some additional smarts to recognize `message/delivery-status' type
messages, which it represents as a `Message' instance containing
separate `Message' subparts for each header block in the delivery status
notification (2).

  The `Generator' class has no differences in its public interface.
There is a new class in the *note email.generator: c0. module though,
called `DecodedGenerator' which provides most of the functionality
previously available in the `Message.getpayloadastext()' method.

  The following modules and classes have been changed:

   * The `MIMEBase' class constructor arguments __major_ and __minor_
     have changed to __maintype_ and __subtype_ respectively.

   * The `Image' class/module has been renamed to `MIMEImage'.  The
     __minor_ argument has been renamed to __subtype_.

   * The `Text' class/module has been renamed to `MIMEText'.  The
     __minor_ argument has been renamed to __subtype_.

   * The `MessageRFC822' class/module has been renamed to
     `MIMEMessage'.  Note that an earlier version of `mimelib' called
     this class/module `RFC822', but that clashed with the Python
     standard library module *note rfc822: 149. on some
     case-insensitive file systems.

     Also, the `MIMEMessage' class now represents any kind of MIME
     message with main type `message'.  It takes an optional argument
     __subtype_ which is used to set the MIME subtype.  __subtype_
     defaults to `rfc822'.

  `mimelib' provided some utility functions in its `address' and `date'
modules.  All of these functions have been moved to the *note
email.utils: c6. module.

  The `MsgReader' class/module has been removed.  Its functionality is
most closely supported in the `body_line_iterator()' function in the
*note email.iterators: c2. module.

  ---------- Footnotes ----------

  (1) http://mimelib.sf.net/

  (2) Delivery Status Notifications (DSN) are defined in RFC 1894
(http://tools.ietf.org/html/rfc1894.html).


File: python.info,  Node: json --- JSON encoder and decoder,  Next: mailcap --- Mailcap file handling,  Prev: email --- An email and MIME handling package,  Up: Internet Data Handling

5.18.2 `json' -- JSON encoder and decoder
-----------------------------------------

New in version 2.6.

  JSON (JavaScript Object Notation)(1) is a subset of JavaScript syntax
(ECMA-262 3rd edition) used as a lightweight data interchange format.

  *note json: fd. exposes an API familiar to users of the standard
library *note marshal: 10c. and *note pickle: 12e. modules.

  Encoding basic Python object hierarchies:

    >>> import json
    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
    '["foo", {"bar": ["baz", null, 1.0, 2]}]'
    >>> print json.dumps("\"foo\bar")
    "\"foo\bar"
    >>> print json.dumps(u'\u1234')
    "\u1234"
    >>> print json.dumps('\\')
    "\\"
    >>> print json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)
    {"a": 0, "b": 0, "c": 0}
    >>> from StringIO import StringIO
    >>> io = StringIO()
    >>> json.dump(['streaming API'], io)
    >>> io.getvalue()
    '["streaming API"]'

Compact encoding:

    >>> import json
    >>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',',':'))
    '[1,2,3,{"4":5,"6":7}]'

Pretty printing:

    >>> import json
    >>> print json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)
    {
        "4": 5,
        "6": 7
    }

Decoding JSON:

    >>> import json
    >>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
    [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]
    >>> json.loads('"\\"foo\\bar"')
    u'"foo\x08ar'
    >>> from StringIO import StringIO
    >>> io = StringIO('["streaming API"]')
    >>> json.load(io)
    [u'streaming API']

Specializing JSON object decoding:

    >>> import json
    >>> def as_complex(dct):
    ...     if '__complex__' in dct:
    ...         return complex(dct['real'], dct['imag'])
    ...     return dct
    ...
    >>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
    ...     object_hook=as_complex)
    (1+2j)
    >>> import decimal
    >>> json.loads('1.1', parse_float=decimal.Decimal)
    Decimal('1.1')

Extending *note JSONEncoder: 17ef.:

    >>> import json
    >>> class ComplexEncoder(json.JSONEncoder):
    ...     def default(self, obj):
    ...         if isinstance(obj, complex):
    ...             return [obj.real, obj.imag]
    ...         return json.JSONEncoder.default(self, obj)
    ...
    >>> dumps(2 + 1j, cls=ComplexEncoder)
    '[2.0, 1.0]'
    >>> ComplexEncoder().encode(2 + 1j)
    '[2.0, 1.0]'
    >>> list(ComplexEncoder().iterencode(2 + 1j))
    ['[', '2.0', ', ', '1.0', ']']

Using json.tool from the shell to validate and pretty-print:

    $ echo '{"json":"obj"}' | python -mjson.tool
    {
        "json": "obj"
    }
    $ echo '{ 1.2:3.4}' | python -mjson.tool
    Expecting property name: line 1 column 2 (char 2)


     Note: The JSON produced by this module's default settings is a
     subset of YAML, so it may be used as a serializer for that as well.

* Menu:

* Basic Usage::
* Encoders and decoders::

  ---------- Footnotes ----------

  (1) http://json.org


File: python.info,  Node: Basic Usage,  Next: Encoders and decoders,  Up: json --- JSON encoder and decoder

5.18.2.1 Basic Usage
....................

 -- Function: json.dump (obj, fp[, skipkeys[, ensure_ascii[,
          check_circular[, allow_nan[, cls[, indent[, separators[,
          encoding[, default[, **kw]]]]]]]]]])
     Serialize _obj_ as a JSON formatted stream to _fp_ (a
     `.write()'-supporting file-like object).

     If _skipkeys_ is `True' (default: `False'), then dict keys that
     are not of a basic type (*note str: 1e7, *note unicode: 1f2, *note
     int: 1ef, *note long: 1f0, *note float: 1e8, *note bool: 42b,
     `None') will be skipped instead of raising a *note TypeError: 215.

     If _ensure_ascii_ is `False' (default: `True'), then some chunks
     written to _fp_ may be *note unicode: 1f2. instances, subject to
     normal Python *note str: 1e7. to *note unicode: 1f2. coercion
     rules.  Unless `fp.write()' explicitly understands *note unicode:
     1f2. (as in *note codecs.getwriter(): a1c.) this is likely to
     cause an error.

     If _check_circular_ is `False' (default: `True'), then the circular
     reference check for container types will be skipped and a circular
     reference will result in an *note OverflowError: 2cf. (or worse).

     If _allow_nan_ is `False' (default: `True'), then it will be a
     *note ValueError: 233. to serialize out of range *note float: 1e8.
     values (`nan', `inf', `-inf') in strict compliance of the JSON
     specification, instead of using the JavaScript equivalents (`NaN',
     `Infinity', `-Infinity').

     If _indent_ is a non-negative integer, then JSON array elements
     and object members will be pretty-printed with that indent level.
     An indent level of 0, or negative, will only insert newlines.
     `None' (the default) selects the most compact representation.

     If _separators_ is an `(item_separator, dict_separator)' tuple,
     then it will be used instead of the default `(', ', ': ')'
     separators.  `(',', ':')' is the most compact JSON representation.

     _encoding_ is the character encoding for str instances, default is
     UTF-8.

     _default(obj)_ is a function that should return a serializable
     version of _obj_ or raise *note TypeError: 215.  The default
     simply raises *note TypeError: 215.

     To use a custom *note JSONEncoder: 17ef. subclass (e.g. one that
     overrides the `default()' method to serialize additional types),
     specify it with the _cls_ kwarg; otherwise *note JSONEncoder:
     17ef. is used.

          Note: Unlike *note pickle: 12e. and *note marshal: 10c, JSON
          is not a framed protocol so trying to serialize more objects
          with repeated calls to *note dump(): 17f1. and the same _fp_
          will result in an invalid JSON file.

 -- Function: json.dumps (obj[, skipkeys[, ensure_ascii[,
          check_circular[, allow_nan[, cls[, indent[, separators[,
          encoding[, default[, **kw]]]]]]]]]])
     Serialize _obj_ to a JSON formatted *note str: 1e7.

     If _ensure_ascii_ is `False', then the return value will be a
     *note unicode: 1f2. instance.  The other arguments have the same
     meaning as in *note dump(): 17f1.

 -- Function: json.load (fp[, encoding[, cls[, object_hook[,
          parse_float[, parse_int[, parse_constant[,
          object_pairs_hook[, **kw]]]]]]]])
     Deserialize _fp_ (a `.read()'-supporting file-like object
     containing a JSON document) to a Python object.

     If the contents of _fp_ are encoded with an ASCII based encoding
     other than UTF-8 (e.g. latin-1), then an appropriate _encoding_
     name must be specified.  Encodings that are not ASCII based (such
     as UCS-2) are not allowed, and should be wrapped with
     `codecs.getreader(encoding)(fp)', or simply decoded to a *note
     unicode: 1f2. object and passed to *note loads(): 17f3.

     _object_hook_ is an optional function that will be called with the
     result of any object literal decoded (a *note dict: 2f6.).  The
     return value of _object_hook_ will be used instead of the *note
     dict: 2f6.  This feature can be used to implement custom decoders
     (e.g. JSON-RPC class hinting).

     _object_pairs_hook_ is an optional function that will be called
     with the result of any object literal decoded with an ordered list
     of pairs.  The return value of _object_pairs_hook_ will be used
     instead of the *note dict: 2f6.  This feature can be used to
     implement custom decoders that rely on the order that the key and
     value pairs are decoded (for example, *note
     collections.OrderedDict(): 1b5. will remember the order of
     insertion). If _object_hook_ is also defined, the
     _object_pairs_hook_ takes priority.

     Changed in version 2.7: Added support for _object_pairs_hook_.

     _parse_float_, if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     `float(num_str)'.  This can be used to use another datatype or
     parser for JSON floats (e.g. *note decimal.Decimal: 1b4.).

     _parse_int_, if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     `int(num_str)'.  This can be used to use another datatype or
     parser for JSON integers (e.g. *note float: 1e8.).

     _parse_constant_, if specified, will be called with one of the
     following strings: `'-Infinity'', `'Infinity'', `'NaN'', `'null'',
     `'true'', `'false''.  This can be used to raise an exception if
     invalid JSON numbers are encountered.

     To use a custom *note JSONDecoder: 1cd. subclass, specify it with
     the `cls' kwarg; otherwise *note JSONDecoder: 1cd. is used.
     Additional keyword arguments will be passed to the constructor of
     the class.

 -- Function: json.loads (s[, encoding[, cls[, object_hook[,
          parse_float[, parse_int[, parse_constant[,
          object_pairs_hook[, **kw]]]]]]]])
     Deserialize _s_ (a *note str: 1e7. or *note unicode: 1f2. instance
     containing a JSON document) to a Python object.

     If _s_ is a *note str: 1e7. instance and is encoded with an ASCII
     based encoding other than UTF-8 (e.g. latin-1), then an
     appropriate _encoding_ name must be specified.  Encodings that are
     not ASCII based (such as UCS-2) are not allowed and should be
     decoded to *note unicode: 1f2. first.

     The other arguments have the same meaning as in *note load(): 234.


File: python.info,  Node: Encoders and decoders,  Prev: Basic Usage,  Up: json --- JSON encoder and decoder

5.18.2.2 Encoders and decoders
..............................

 -- Class: json.JSONDecoder ([encoding[, object_hook[, parse_float[,
          parse_int[, parse_constant[, strict[,
          object_pairs_hook]]]]]]])
     Simple JSON decoder.

     Performs the following translations in decoding by default:

     JSON                Python
     -------------------------------------------- 
     object              dict
     array               list
     string              unicode
     number (int)        int, long
     number (real)       float
     true                True
     false               False
     null                None

     It also understands `NaN', `Infinity', and `-Infinity' as their
     corresponding `float' values, which is outside the JSON spec.

     _encoding_ determines the encoding used to interpret any *note
     str: 1e7. objects decoded by this instance (UTF-8 by default).  It
     has no effect when decoding *note unicode: 1f2. objects.

     Note that currently only encodings that are a superset of ASCII
     work, strings of other encodings should be passed in as *note
     unicode: 1f2.

     _object_hook_, if specified, will be called with the result of
     every JSON object decoded and its return value will be used in
     place of the given *note dict: 2f6.  This can be used to provide
     custom deserializations (e.g. to support JSON-RPC class hinting).

     _object_pairs_hook_, if specified will be called with the result
     of every JSON object decoded with an ordered list of pairs.  The
     return value of _object_pairs_hook_ will be used instead of the
     *note dict: 2f6.  This feature can be used to implement custom
     decoders that rely on the order that the key and value pairs are
     decoded (for example, *note collections.OrderedDict(): 1b5. will
     remember the order of insertion). If _object_hook_ is also
     defined, the _object_pairs_hook_ takes priority.

     Changed in version 2.7: Added support for _object_pairs_hook_.

     _parse_float_, if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     `float(num_str)'.  This can be used to use another datatype or
     parser for JSON floats (e.g. *note decimal.Decimal: 1b4.).

     _parse_int_, if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     `int(num_str)'.  This can be used to use another datatype or
     parser for JSON integers (e.g. *note float: 1e8.).

     _parse_constant_, if specified, will be called with one of the
     following strings: `'-Infinity'', `'Infinity'', `'NaN'', `'null'',
     `'true'', `'false''.  This can be used to raise an exception if
     invalid JSON numbers are encountered.

     If _strict_ is `False' (`True' is the default), then control
     characters will be allowed inside strings.  Control characters in
     this context are those with character codes in the 0-31 range,
     including `'\t'' (tab), `'\n'', `'\r'' and `'\0''.

      -- Method: decode (s)
          Return the Python representation of _s_ (a *note str: 1e7. or
          *note unicode: 1f2. instance containing a JSON document)

      -- Method: raw_decode (s)
          Decode a JSON document from _s_ (a *note str: 1e7. or *note
          unicode: 1f2.  beginning with a JSON document) and return a
          2-tuple of the Python representation and the index in _s_
          where the document ended.

          This can be used to decode a JSON document from a string that
          may have extraneous data at the end.

 -- Class: json.JSONEncoder ([skipkeys[, ensure_ascii[,
          check_circular[, allow_nan[, sort_keys[, indent[,
          separators[, encoding[, default]]]]]]]]])
     Extensible JSON encoder for Python data structures.

     Supports the following objects and types by default:

     Python                  JSON
     -------------------------------------------- 
     dict                    object
     list, tuple             array
     str, unicode            string
     int, long, float        number
     True                    true
     False                   false
     None                    null

     To extend this to recognize other objects, subclass and implement a
     *note default(): 17f7. method with another method that returns a
     serializable object for `o' if possible, otherwise it should call
     the superclass implementation (to raise *note TypeError: 215.).

     If _skipkeys_ is `False' (the default), then it is a *note
     TypeError: 215. to attempt encoding of keys that are not str, int,
     long, float or None.  If _skipkeys_ is `True', such items are
     simply skipped.

     If _ensure_ascii_ is `True' (the default), the output is
     guaranteed to be *note str: 1e7. objects with all incoming unicode
     characters escaped.  If _ensure_ascii_ is `False', the output will
     be a unicode object.

     If _check_circular_ is `True' (the default), then lists, dicts,
     and custom encoded objects will be checked for circular references
     during encoding to prevent an infinite recursion (which would
     cause an *note OverflowError: 2cf.).  Otherwise, no such check
     takes place.

     If _allow_nan_ is `True' (the default), then `NaN', `Infinity', and
     `-Infinity' will be encoded as such.  This behavior is not JSON
     specification compliant, but is consistent with most JavaScript
     based encoders and decoders.  Otherwise, it will be a *note
     ValueError: 233. to encode such floats.

     If _sort_keys_ is `True' (default `False'), then the output of
     dictionaries will be sorted by key; this is useful for regression
     tests to ensure that JSON serializations can be compared on a
     day-to-day basis.

     If _indent_ is a non-negative integer (it is `None' by default),
     then JSON array elements and object members will be pretty-printed
     with that indent level.  An indent level of 0 will only insert
     newlines.  `None' is the most compact representation.

     If specified, _separators_ should be an `(item_separator,
     key_separator)' tuple.  The default is `(', ', ': ')'.  To get the
     most compact JSON representation, you should specify `(',', ':')'
     to eliminate whitespace.

     If specified, _default_ is a function that gets called for objects
     that can't otherwise be serialized.  It should return a JSON
     encodable version of the object or raise a *note TypeError: 215.

     If _encoding_ is not `None', then all input strings will be
     transformed into unicode using that encoding prior to
     JSON-encoding.  The default is UTF-8.

      -- Method: default (o)
          Implement this method in a subclass such that it returns a
          serializable object for _o_, or calls the base implementation
          (to raise a *note TypeError: 215.).

          For example, to support arbitrary iterators, you could
          implement default like this:

              def default(self, o):
                 try:
                     iterable = iter(o)
                 except TypeError:
                     pass
                 else:
                     return list(iterable)
                 return JSONEncoder.default(self, o)



      -- Method: encode (o)
          Return a JSON string representation of a Python data
          structure, _o_.  For example:

              >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
              '{"foo": ["bar", "baz"]}'



      -- Method: iterencode (o)
          Encode the given object, _o_, and yield each string
          representation as available.  For example:

              for chunk in JSONEncoder().iterencode(bigobject):
                  mysocket.write(chunk)




File: python.info,  Node: mailcap --- Mailcap file handling,  Next: mailbox --- Manipulate mailboxes in various formats,  Prev: json --- JSON encoder and decoder,  Up: Internet Data Handling

5.18.3 `mailcap' -- Mailcap file handling
-----------------------------------------

Mailcap files are used to configure how MIME-aware applications such as
mail readers and Web browsers react to files with different MIME types.
(The name "mailcap" is derived from the phrase "mail capability".)  For
example, a mailcap file might contain a line like `video/mpeg; xmpeg
%s'.  Then, if the user encounters an email message or Web document
with the MIME type `video/mpeg', `%s' will be replaced by a filename
(usually one belonging to a temporary file) and the *xmpeg* program can
be automatically started to view the file.

  The mailcap format is documented in RFC 1524(1), "A User Agent
Configuration Mechanism For Multimedia Mail Format Information," but is
not an Internet standard.  However, mailcap files are supported on most
Unix systems.

 -- Function: mailcap.findmatch (caps, MIMEtype[, key[, filename[,
          plist]]])
     Return a 2-tuple; the first element is a string containing the
     command line to be executed (which can be passed to *note
     os.system(): 3e9.), and the second element is the mailcap entry
     for a given MIME type.  If no matching MIME type can be found,
     `(None, None)' is returned.

     _key_ is the name of the field desired, which represents the type
     of activity to be performed; the default value is 'view', since in
     the  most common case you simply want to view the body of the
     MIME-typed data.  Other possible values might be 'compose' and
     'edit', if you wanted to create a new body of the given MIME type
     or alter the existing body data.  See RFC 1524(2) for a complete
     list of these fields.

     _filename_ is the filename to be substituted for `%s' in the
     command line; the default value is `'/dev/null'' which is almost
     certainly not what you want, so usually you'll override it by
     specifying a filename.

     _plist_ can be a list containing named parameters; the default
     value is simply an empty list.  Each entry in the list must be a
     string containing the parameter name, an equals sign (`'=''), and
     the parameter's value.  Mailcap entries can contain  named
     parameters like `%{foo}', which will be replaced by the value of
     the parameter named 'foo'.  For example, if the command line
     `showpartial %{id} %{number} %{total}' was in a mailcap file, and
     _plist_ was set to `['id=1', 'number=2', 'total=3']', the
     resulting command line would be `'showpartial 1 2 3''.

     In a mailcap file, the "test" field can optionally be specified to
     test some external condition (such as the machine architecture, or
     the window system in use) to determine whether or not the mailcap
     line applies.  *note findmatch(): 17fc.  will automatically check
     such conditions and skip the entry if the check fails.

 -- Function: mailcap.getcaps ()
     Returns a dictionary mapping MIME types to a list of mailcap file
     entries. This dictionary must be passed to the *note findmatch():
     17fc. function.  An entry is stored as a list of dictionaries, but
     it shouldn't be necessary to know the details of this
     representation.

     The information is derived from all of the mailcap files found on
     the system.  Settings in the user's mailcap file `$HOME/.mailcap'
     will override settings in the system mailcap files `/etc/mailcap',
     `/usr/etc/mailcap', and `/usr/local/etc/mailcap'.

  An example usage:

    >>> import mailcap
    >>> d=mailcap.getcaps()
    >>> mailcap.findmatch(d, 'video/mpeg', filename='/tmp/tmp1223')
    ('xmpeg /tmp/tmp1223', {'view': 'xmpeg %s'})


  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc1524.html

  (2) http://tools.ietf.org/html/rfc1524.html


File: python.info,  Node: mailbox --- Manipulate mailboxes in various formats,  Next: mhlib --- Access to MH mailboxes,  Prev: mailcap --- Mailcap file handling,  Up: Internet Data Handling

5.18.4 `mailbox' -- Manipulate mailboxes in various formats
-----------------------------------------------------------

This module defines two classes, *note Mailbox: 1800. and *note
Message: 1801, for accessing and manipulating on-disk mailboxes and the
messages they contain.  *note Mailbox: 1800. offers a dictionary-like
mapping from keys to messages.  *note Message: 1801. extends the
`email.Message' module's *note Message: 1801.  class with
format-specific state and behavior. Supported mailbox formats are
Maildir, mbox, MH, Babyl, and MMDF.

See also
........

Module *note email: bc.
     Represent and manipulate messages.

* Menu:

* Mailbox objects::
* Message objects::
* Exceptions: Exceptions<5>.
* Deprecated classes and methods::
* Examples: Examples<9>.

Mailbox objects

* Maildir::
* mbox::
* MH::
* Babyl::
* MMDF::

Message objects

* MaildirMessage::
* mboxMessage::
* MHMessage::
* BabylMessage::
* MMDFMessage::


File: python.info,  Node: Mailbox objects,  Next: Message objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.1 `Mailbox' objects
..........................

 -- Class: mailbox.Mailbox
     A mailbox, which may be inspected and modified.

     The *note Mailbox: 1800. class defines an interface and is not
     intended to be instantiated.  Instead, format-specific subclasses
     should inherit from *note Mailbox: 1800. and your code should
     instantiate a particular subclass.

     The *note Mailbox: 1800. interface is dictionary-like, with small
     keys corresponding to messages. Keys are issued by the *note
     Mailbox: 1800. instance with which they will be used and are only
     meaningful to that *note Mailbox: 1800.  instance. A key continues
     to identify a message even if the corresponding message is
     modified, such as by replacing it with another message.

     Messages may be added to a *note Mailbox: 1800. instance using the
     set-like method *note add(): 1804. and removed using a `del'
     statement or the set-like methods *note remove(): 1805. and *note
     discard(): 1806.

     *note Mailbox: 1800. interface semantics differ from dictionary
     semantics in some noteworthy ways. Each time a message is
     requested, a new representation (typically a *note Message: 1801.
     instance) is generated based upon the current state of the
     mailbox. Similarly, when a message is added to a *note Mailbox:
     1800. instance, the provided message representation's contents are
     copied. In neither case is a reference to the message
     representation kept by the *note Mailbox: 1800. instance.

     The default *note Mailbox: 1800. iterator iterates over message
     representations, not keys as the default dictionary iterator does.
     Moreover, modification of a mailbox during iteration is safe and
     well-defined. Messages added to the mailbox after an iterator is
     created will not be seen by the iterator. Messages removed from
     the mailbox before the iterator yields them will be silently
     skipped, though using a key from an iterator may result in a *note
     KeyError: 202. exception if the corresponding message is
     subsequently removed.

          Warning: Be very cautious when modifying mailboxes that might
          be simultaneously changed by some other process.  The safest
          mailbox format to use for such tasks is Maildir; try to avoid
          using single-file formats such as mbox for concurrent
          writing.  If you're modifying a mailbox, you _must_ lock it by
          calling the *note lock(): 1807. and *note unlock(): 1808.
          methods _before_ reading any messages in the file or making
          any changes by adding or deleting a message.  Failing to lock
          the mailbox runs the risk of losing messages or corrupting
          the entire mailbox.

     *note Mailbox: 1800. instances have the following methods:

      -- Method: add (message)
          Add _message_ to the mailbox and return the key that has been
          assigned to it.

          Parameter _message_ may be a *note Message: 1801. instance, an
          `email.Message.Message' instance, a string, or a file-like
          object (which should be open in text mode). If _message_ is
          an instance of the appropriate format-specific *note Message:
          1801. subclass (e.g., if it's an *note mboxMessage: 1809.
          instance and this is an *note mbox: 180a. instance), its
          format-specific information is used. Otherwise, reasonable
          defaults for format-specific information are used.

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)
          Delete the message corresponding to _key_ from the mailbox.

          If no such message exists, a *note KeyError: 202. exception
          is raised if the method was called as *note remove(): 1805.
          or *note __delitem__(): 180b. but no exception is raised if
          the method was called as *note discard(): 1806. The behavior
          of *note discard(): 1806. may be preferred if the underlying
          mailbox format supports concurrent modification by other
          processes.

      -- Method: __setitem__ (key, message)
          Replace the message corresponding to _key_ with _message_.
          Raise a *note KeyError: 202. exception if no message already
          corresponds to _key_.

          As with *note add(): 1804, parameter _message_ may be a *note
          Message: 1801.  instance, an `email.Message.Message'
          instance, a string, or a file-like object (which should be
          open in text mode). If _message_ is an instance of the
          appropriate format-specific *note Message: 1801. subclass
          (e.g., if it's an *note mboxMessage: 1809. instance and this
          is an *note mbox: 180a. instance), its format-specific
          information is used. Otherwise, the format-specific
          information of the message that currently corresponds to
          _key_ is left unchanged.

      -- Method: iterkeys ()
      -- Method: keys ()
          Return an iterator over all keys if called as *note
          iterkeys(): 180d. or return a list of keys if called as *note
          keys(): 180e.

      -- Method: itervalues ()
      -- Method: __iter__ ()
      -- Method: values ()
          Return an iterator over representations of all messages if
          called as *note itervalues(): 180f. or *note __iter__():
          1810. or return a list of such representations if called as
          *note values(): 1811. The messages are represented as
          instances of the appropriate format-specific *note Message:
          1801. subclass unless a custom message factory was specified
          when the *note Mailbox: 1800.  instance was initialized.

               Note: The behavior of *note __iter__(): 1810. is unlike
               that of dictionaries, which iterate over keys.

      -- Method: iteritems ()
      -- Method: items ()
          Return an iterator over (_key_, _message_) pairs, where _key_
          is a key and _message_ is a message representation, if called
          as *note iteritems(): 1812. or return a list of such pairs if
          called as *note items(): 1813. The messages are represented
          as instances of the appropriate format-specific *note
          Message: 1801. subclass unless a custom message factory was
          specified when the *note Mailbox: 1800. instance was
          initialized.

      -- Method: get (key[, default=None])
      -- Method: __getitem__ (key)
          Return a representation of the message corresponding to
          _key_. If no such message exists, _default_ is returned if
          the method was called as *note get(): 1814. and a *note
          KeyError: 202. exception is raised if the method was called
          as *note __getitem__(): 1815. The message is represented as
          an instance of the appropriate format-specific *note Message:
          1801. subclass unless a custom message factory was specified
          when the *note Mailbox: 1800. instance was initialized.

      -- Method: get_message (key)
          Return a representation of the message corresponding to _key_
          as an instance of the appropriate format-specific *note
          Message: 1801. subclass, or raise a *note KeyError: 202.
          exception if no such message exists.

      -- Method: get_string (key)
          Return a string representation of the message corresponding
          to _key_, or raise a *note KeyError: 202. exception if no
          such message exists.

      -- Method: get_file (key)
          Return a file-like representation of the message
          corresponding to _key_, or raise a *note KeyError: 202.
          exception if no such message exists. The file-like object
          behaves as if open in binary mode. This file should be closed
          once it is no longer needed.

               Note: Unlike other representations of messages,
               file-like representations are not necessarily
               independent of the *note Mailbox: 1800. instance that
               created them or of the underlying mailbox. More specific
               documentation is provided by each subclass.

      -- Method: has_key (key)
      -- Method: __contains__ (key)
          Return `True' if _key_ corresponds to a message, `False'
          otherwise.

      -- Method: __len__ ()
          Return a count of messages in the mailbox.

      -- Method: clear ()
          Delete all messages from the mailbox.

      -- Method: pop (key[, default])
          Return a representation of the message corresponding to _key_
          and delete the message. If no such message exists, return
          _default_ if it was supplied or else raise a *note KeyError:
          202. exception. The message is represented as an instance of
          the appropriate format-specific *note Message: 1801. subclass
          unless a custom message factory was specified when the *note
          Mailbox: 1800. instance was initialized.

      -- Method: popitem ()
          Return an arbitrary (_key_, _message_) pair, where _key_ is a
          key and _message_ is a message representation, and delete the
          corresponding message. If the mailbox is empty, raise a *note
          KeyError: 202. exception. The message is represented as an
          instance of the appropriate format-specific *note Message:
          1801. subclass unless a custom message factory was specified
          when the *note Mailbox: 1800. instance was initialized.

      -- Method: update (arg)
          Parameter _arg_ should be a _key_-to-_message_ mapping or an
          iterable of (_key_, _message_) pairs. Updates the mailbox so
          that, for each given _key_ and _message_, the message
          corresponding to _key_ is set to _message_ as if by using
          *note __setitem__(): 180c. As with *note __setitem__(): 180c,
          each _key_ must already correspond to a message in the
          mailbox or else a *note KeyError: 202. exception will be
          raised, so in general it is incorrect for _arg_ to be a *note
          Mailbox: 1800. instance.

               Note: Unlike with dictionaries, keyword arguments are
               not supported.

      -- Method: flush ()
          Write any pending changes to the filesystem. For some *note
          Mailbox: 1800.  subclasses, changes are always written
          immediately and *note flush(): 1820. does nothing, but you
          should still make a habit of calling this method.

      -- Method: lock ()
          Acquire an exclusive advisory lock on the mailbox so that
          other processes know not to modify it. An *note
          ExternalClashError: 1821. is raised if the lock is not
          available. The particular locking mechanisms used depend upon
          the mailbox format.  You should _always_ lock the mailbox
          before making any modifications to its contents.

      -- Method: unlock ()
          Release the lock on the mailbox, if any.

      -- Method: close ()
          Flush the mailbox, unlock it if necessary, and close any open
          files. For some *note Mailbox: 1800. subclasses, this method
          does nothing.

* Menu:

* Maildir::
* mbox::
* MH::
* Babyl::
* MMDF::


File: python.info,  Node: Maildir,  Next: mbox,  Up: Mailbox objects

5.18.4.2 `Maildir'
..................

 -- Class: mailbox.Maildir (dirname[, factory=rfc822.Message[,
          create=True]])
     A subclass of *note Mailbox: 1800. for mailboxes in Maildir
     format. Parameter _factory_ is a callable object that accepts a
     file-like message representation (which behaves as if opened in
     binary mode) and returns a custom representation.  If _factory_ is
     `None', *note MaildirMessage: 1825. is used as the default message
     representation. If _create_ is `True', the mailbox is created if
     it does not exist.

     It is for historical reasons that _factory_ defaults to *note
     rfc822.Message: 1826.  and that _dirname_ is named as such rather
     than _path_. For a *note Maildir: 235.  instance that behaves like
     instances of other *note Mailbox: 1800. subclasses, set _factory_
     to `None'.

     Maildir is a directory-based mailbox format invented for the qmail
     mail transfer agent and now widely supported by other programs.
     Messages in a Maildir mailbox are stored in separate files within
     a common directory structure. This design allows Maildir mailboxes
     to be accessed and modified by multiple unrelated programs without
     data corruption, so file locking is unnecessary.

     Maildir mailboxes contain three subdirectories, namely: `tmp',
     `new', and `cur'. Messages are created momentarily in the `tmp'
     subdirectory and then moved to the `new' subdirectory to finalize
     delivery. A mail user agent may subsequently move the message to
     the `cur' subdirectory and store information about the state of
     the message in a special "info" section appended to its file name.

     Folders of the style introduced by the Courier mail transfer agent
     are also supported. Any subdirectory of the main mailbox is
     considered a folder if `'.'' is the first character in its name.
     Folder names are represented by *note Maildir: 235. without the
     leading `'.''. Each folder is itself a Maildir mailbox but should
     not contain other folders. Instead, a logical nesting is indicated
     using `'.'' to delimit levels, e.g., "Archived.2005.07".

          Note: The Maildir specification requires the use of a colon
          (`':'') in certain message file names. However, some
          operating systems do not permit this character in file names,
          If you wish to use a Maildir-like format on such an operating
          system, you should specify another character to use instead.
          The exclamation point (`'!'') is a popular choice. For
          example:

              import mailbox
              mailbox.Maildir.colon = '!'

          The `colon' attribute may also be set on a per-instance basis.

     *note Maildir: 235. instances have all of the methods of *note
     Mailbox: 1800. in addition to the following:

      -- Method: list_folders ()
          Return a list of the names of all folders.

      -- Method: get_folder (folder)
          Return a *note Maildir: 235. instance representing the folder
          whose name is _folder_. A *note NoSuchMailboxError: 1829.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)
          Create a folder whose name is _folder_ and return a *note
          Maildir: 235.  instance representing it.

      -- Method: remove_folder (folder)
          Delete the folder whose name is _folder_. If the folder
          contains any messages, a *note NotEmptyError: 182c. exception
          will be raised and the folder will not be deleted.

      -- Method: clean ()
          Delete temporary files from the mailbox that have not been
          accessed in the last 36 hours. The Maildir specification says
          that mail-reading programs should do this occasionally.

     Some *note Mailbox: 1800. methods implemented by *note Maildir:
     235. deserve special remarks:

      -- Method: add (message)
      -- Method: __setitem__ (key, message)
      -- Method: update (arg)
               Warning: These methods generate unique file names based
               upon the current process ID. When using multiple
               threads, undetected name clashes may occur and cause
               corruption of the mailbox unless threads are coordinated
               to avoid using these methods to manipulate the same
               mailbox simultaneously.

      -- Method: flush ()
          All changes to Maildir mailboxes are immediately applied, so
          this method does nothing.

      -- Method: lock ()
      -- Method: unlock ()
          Maildir mailboxes do not support (or require) locking, so
          these methods do nothing.

      -- Method: close ()
          *note Maildir: 235. instances do not keep any open files and
          the underlying mailboxes do not support locking, so this
          method does nothing.

      -- Method: get_file (key)
          Depending upon the host platform, it may not be possible to
          modify or remove the underlying message while the returned
          file remains open.

See also
........

maildir man page from qmail(1)
     The original specification of the format.

Using maildir format(2)
     Notes on Maildir by its inventor. Includes an updated
     name-creation scheme and details on "info" semantics.

maildir man page from Courier(3)
     Another specification of the format. Describes a common extension
     for supporting folders.

  ---------- Footnotes ----------

  (1) http://www.qmail.org/man/man5/maildir.html

  (2) http://cr.yp.to/proto/maildir.html

  (3) http://www.courier-mta.org/maildir.html


File: python.info,  Node: mbox,  Next: MH,  Prev: Maildir,  Up: Mailbox objects

5.18.4.3 `mbox'
...............

 -- Class: mailbox.mbox (path[, factory=None[, create=True]])
     A subclass of *note Mailbox: 1800. for mailboxes in mbox format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation. If _factory_ is `None', *note
     mboxMessage: 1809. is used as the default message representation.
     If _create_ is `True', the mailbox is created if it does not exist.

     The mbox format is the classic format for storing mail on Unix
     systems. All messages in an mbox mailbox are stored in a single
     file with the beginning of each message indicated by a line whose
     first five characters are "From ".

     Several variations of the mbox format exist to address perceived
     shortcomings in the original. In the interest of compatibility,
     *note mbox: 180a. implements the original format, which is
     sometimes referred to as _mboxo_. This means that the
     `Content-Length' header, if present, is ignored and that any
     occurrences of "From " at the beginning of a line in a message
     body are transformed to ">From " when storing the message,
     although occurrences of ">From " are not transformed to "From "
     when reading the message.

     Some *note Mailbox: 1800. methods implemented by *note mbox: 180a.
     deserve special remarks:

      -- Method: get_file (key)
          Using the file after calling `flush()' or `close()' on the
          *note mbox: 180a. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used--dot locking and, if
          available, the `flock()' and `lockf()' system calls.

See also
........

mbox man page from qmail(1)
     A specification of the format and its variations.

mbox man page from tin(2)
     Another specification of the format, with details on locking.

Configuring Netscape Mail on Unix: Why The Content-Length Format is Bad(3)
     An argument for using the original mbox format rather than a
     variation.

"mbox" is a family of several mutually incompatible mailbox formats(4)
     A history of mbox variations.

  ---------- Footnotes ----------

  (1) http://www.qmail.org/man/man5/mbox.html

  (2) http://www.tin.org/bin/man.cgi?section=5&topic=mbox

  (3) http://www.jwz.org/doc/content-length.html

  (4)
http://homepages.tesco.net./~J.deBoynePollard/FGA/mail-mbox-formats.html


File: python.info,  Node: MH,  Next: Babyl,  Prev: mbox,  Up: Mailbox objects

5.18.4.4 `MH'
.............

 -- Class: mailbox.MH (path[, factory=None[, create=True]])
     A subclass of *note Mailbox: 1800. for mailboxes in MH format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation. If _factory_ is `None', *note
     MHMessage: 183e. is used as the default message representation. If
     _create_ is `True', the mailbox is created if it does not exist.

     MH is a directory-based mailbox format invented for the MH Message
     Handling System, a mail user agent. Each message in an MH mailbox
     resides in its own file. An MH mailbox may contain other MH
     mailboxes (called _folders_) in addition to messages. Folders may
     be nested indefinitely. MH mailboxes also support _sequences_,
     which are named lists used to logically group messages without
     moving them to sub-folders. Sequences are defined in a file called
     `.mh_sequences' in each folder.

     The *note MH: 183d. class manipulates MH mailboxes, but it does
     not attempt to emulate all of *mh*'s behaviors. In particular, it
     does not modify and is not affected by the `context' or
     `.mh_profile' files that are used by *mh* to store its state and
     configuration.

     *note MH: 183d. instances have all of the methods of *note
     Mailbox: 1800. in addition to the following:

      -- Method: list_folders ()
          Return a list of the names of all folders.

      -- Method: get_folder (folder)
          Return an *note MH: 183d. instance representing the folder
          whose name is _folder_. A *note NoSuchMailboxError: 1829.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)
          Create a folder whose name is _folder_ and return an *note
          MH: 183d. instance representing it.

      -- Method: remove_folder (folder)
          Delete the folder whose name is _folder_. If the folder
          contains any messages, a *note NotEmptyError: 182c. exception
          will be raised and the folder will not be deleted.

      -- Method: get_sequences ()
          Return a dictionary of sequence names mapped to key lists. If
          there are no sequences, the empty dictionary is returned.

      -- Method: set_sequences (sequences)
          Re-define the sequences that exist in the mailbox based upon
          _sequences_, a dictionary of names mapped to key lists, like
          returned by *note get_sequences(): 1843.

      -- Method: pack ()
          Rename messages in the mailbox as necessary to eliminate gaps
          in numbering.  Entries in the sequences list are updated
          correspondingly.

               Note: Already-issued keys are invalidated by this
               operation and should not be subsequently used.

     Some *note Mailbox: 1800. methods implemented by *note MH: 183d.
     deserve special remarks:

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)
          These methods immediately delete the message. The MH
          convention of marking a message for deletion by prepending a
          comma to its name is not used.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used--dot locking and, if
          available, the `flock()' and `lockf()' system calls. For MH
          mailboxes, locking the mailbox means locking the
          `.mh_sequences' file and, only for the duration of any
          operations that affect them, locking individual message files.

      -- Method: get_file (key)
          Depending upon the host platform, it may not be possible to
          remove the underlying message while the returned file remains
          open.

      -- Method: flush ()
          All changes to MH mailboxes are immediately applied, so this
          method does nothing.

      -- Method: close ()
          *note MH: 183d. instances do not keep any open files, so this
          method is equivalent to *note unlock(): 184a.

See also
........

nmh - Message Handling System(1)
     Home page of *nmh*, an updated version of the original *mh*.

MH & nmh: Email for Users & Programmers(2)
     A GPL-licensed book on *mh* and *nmh*, with some information on
     the mailbox format.

  ---------- Footnotes ----------

  (1) http://www.nongnu.org/nmh/

  (2) http://rand-mh.sourceforge.net/book/


File: python.info,  Node: Babyl,  Next: MMDF,  Prev: MH,  Up: Mailbox objects

5.18.4.5 `Babyl'
................

 -- Class: mailbox.Babyl (path[, factory=None[, create=True]])
     A subclass of *note Mailbox: 1800. for mailboxes in Babyl format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If _factory_ is `None',
     *note BabylMessage: 1851. is used as the default message
     representation. If _create_ is `True', the mailbox is created if
     it does not exist.

     Babyl is a single-file mailbox format used by the Rmail mail user
     agent included with Emacs. The beginning of a message is indicated
     by a line containing the two characters Control-Underscore
     (`'\037'') and Control-L (`'\014''). The end of a message is
     indicated by the start of the next message or, in the case of the
     last message, a line containing a Control-Underscore (`'\037'')
     character.

     Messages in a Babyl mailbox have two sets of headers, original
     headers and so-called visible headers. Visible headers are
     typically a subset of the original headers that have been
     reformatted or abridged to be more attractive. Each message in a
     Babyl mailbox also has an accompanying list of _labels_, or short
     strings that record extra information about the message, and a
     list of all user-defined labels found in the mailbox is kept in
     the Babyl options section.

     *note Babyl: 1850. instances have all of the methods of *note
     Mailbox: 1800. in addition to the following:

      -- Method: get_labels ()
          Return a list of the names of all user-defined labels used in
          the mailbox.

               Note: The actual messages are inspected to determine
               which labels exist in the mailbox rather than consulting
               the list of labels in the Babyl options section, but the
               Babyl section is updated whenever the mailbox is
               modified.

     Some *note Mailbox: 1800. methods implemented by *note Babyl:
     1850. deserve special remarks:

      -- Method: get_file (key)
          In Babyl mailboxes, the headers of a message are not stored
          contiguously with the body of the message. To generate a
          file-like representation, the headers and body are copied
          together into a *note StringIO: 165. instance (from the *note
          StringIO: 165. module), which has an API identical to that of
          a file. As a result, the file-like object is truly
          independent of the underlying mailbox but does not save
          memory compared to a string representation.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used--dot locking and, if
          available, the `flock()' and `lockf()' system calls.

See also
........

Format of Version 5 Babyl Files(1)
     A specification of the Babyl format.

Reading Mail with Rmail(2)
     The Rmail manual, with some information on Babyl semantics.

  ---------- Footnotes ----------

  (1) http://quimby.gnus.org/notes/BABYL

  (2)
http://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html


File: python.info,  Node: MMDF,  Prev: Babyl,  Up: Mailbox objects

5.18.4.6 `MMDF'
...............

 -- Class: mailbox.MMDF (path[, factory=None[, create=True]])
     A subclass of *note Mailbox: 1800. for mailboxes in MMDF format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation. If _factory_ is `None', *note
     MMDFMessage: 1859. is used as the default message representation.
     If _create_ is `True', the mailbox is created if it does not exist.

     MMDF is a single-file mailbox format invented for the Multichannel
     Memorandum Distribution Facility, a mail transfer agent. Each
     message is in the same form as an mbox message but is bracketed
     before and after by lines containing four Control-A (`'\001'')
     characters. As with the mbox format, the beginning of each message
     is indicated by a line whose first five characters are "From ",
     but additional occurrences of "From " are not transformed to
     ">From " when storing messages because the extra message separator
     lines prevent mistaking such occurrences for the starts of
     subsequent messages.

     Some *note Mailbox: 1800. methods implemented by *note MMDF: 1858.
     deserve special remarks:

      -- Method: get_file (key)
          Using the file after calling `flush()' or `close()' on the
          *note MMDF: 1858. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used--dot locking and, if
          available, the `flock()' and `lockf()' system calls.

See also
........

mmdf man page from tin(1)
     A specification of MMDF format from the documentation of tin, a
     newsreader.

MMDF(2)
     A Wikipedia article describing the Multichannel Memorandum
     Distribution Facility.

  ---------- Footnotes ----------

  (1) http://www.tin.org/bin/man.cgi?section=5&topic=mmdf

  (2) http://en.wikipedia.org/wiki/MMDF


File: python.info,  Node: Message objects,  Next: Exceptions<5>,  Prev: Mailbox objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.7 `Message' objects
..........................

 -- Class: mailbox.Message ([message])
     A subclass of the `email.Message' module's *note Message: 1801.
     Subclasses of *note mailbox.Message: 1801. add
     mailbox-format-specific state and behavior.

     If _message_ is omitted, the new instance is created in a default,
     empty state.  If _message_ is an `email.Message.Message' instance,
     its contents are copied; furthermore, any format-specific
     information is converted insofar as possible if _message_ is a
     *note Message: 1801. instance. If _message_ is a string or a file,
     it should contain an RFC 2822(1)-compliant message, which is read
     and parsed.

     The format-specific state and behaviors offered by subclasses
     vary, but in general it is only the properties that are not
     specific to a particular mailbox that are supported (although
     presumably the properties are specific to a particular mailbox
     format). For example, file offsets for single-file mailbox formats
     and file names for directory-based mailbox formats are not
     retained, because they are only applicable to the original
     mailbox. But state such as whether a message has been read by the
     user or marked as important is retained, because it applies to the
     message itself.

     There is no requirement that *note Message: 1801. instances be
     used to represent messages retrieved using *note Mailbox: 1800.
     instances. In some situations, the time and memory required to
     generate *note Message: 1801. representations might not not
     acceptable. For such situations, *note Mailbox: 1800. instances
     also offer string and file-like representations, and a custom
     message factory may be specified when a *note Mailbox: 1800.
     instance is initialized.

* Menu:

* MaildirMessage::
* mboxMessage::
* MHMessage::
* BabylMessage::
* MMDFMessage::

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: MaildirMessage,  Next: mboxMessage,  Up: Message objects

5.18.4.8 `MaildirMessage'
.........................

 -- Class: mailbox.MaildirMessage ([message])
     A message with Maildir-specific behaviors. Parameter _message_ has
     the same meaning as with the *note Message: 1801. constructor.

     Typically, a mail user agent application moves all of the messages
     in the `new' subdirectory to the `cur' subdirectory after the
     first time the user opens and closes the mailbox, recording that
     the messages are old whether or not they've actually been read.
     Each message in `cur' has an "info" section added to its file name
     to store information about its state.  (Some mail readers may also
     add an "info" section to messages in `new'.)  The "info" section
     may take one of two forms: it may contain "2," followed by a list
     of standardized flags (e.g., "2,FR") or it may contain "1,"
     followed by so-called experimental information. Standard flags for
     Maildir messages are as follows:

     Flag       Meaning       Explanation
     -------------------------------------------------------------- 
     D          Draft         Under composition
     F          Flagged       Marked as important
     P          Passed        Forwarded, resent, or bounced
     R          Replied       Replied to
     S          Seen          Read
     T          Trashed       Marked for subsequent deletion

     *note MaildirMessage: 1825. instances offer the following methods:

      -- Method: get_subdir ()
          Return either "new" (if the message should be stored in the
          `new' subdirectory) or "cur" (if the message should be stored
          in the `cur' subdirectory).

               Note: A message is typically moved from `new' to `cur'
               after its mailbox has been accessed, whether or not the
               message is has been read. A message `msg' has been read
               if `"S" in msg.get_flags()' is `True'.

      -- Method: set_subdir (subdir)
          Set the subdirectory the message should be stored in.
          Parameter _subdir_ must be either "new" or "cur".

      -- Method: get_flags ()
          Return a string specifying the flags that are currently set.
          If the message complies with the standard Maildir format, the
          result is the concatenation in alphabetical order of zero or
          one occurrence of each of `'D'', `'F'', `'P'', `'R'', `'S'',
          and `'T''. The empty string is returned if no flags are set
          or if "info" contains experimental semantics.

      -- Method: set_flags (flags)
          Set the flags specified by _flags_ and unset all others.

      -- Method: add_flag (flag)
          Set the flag(s) specified by _flag_ without changing other
          flags. To add more than one flag at a time, _flag_ may be a
          string of more than one character. The current "info" is
          overwritten whether or not it contains experimental
          information rather than flags.

      -- Method: remove_flag (flag)
          Unset the flag(s) specified by _flag_ without changing other
          flags. To remove more than one flag at a time, _flag_ maybe a
          string of more than one character.  If "info" contains
          experimental information rather than flags, the current
          "info" is not modified.

      -- Method: get_date ()
          Return the delivery date of the message as a floating-point
          number representing seconds since the epoch.

      -- Method: set_date (date)
          Set the delivery date of the message to _date_, a
          floating-point number representing seconds since the epoch.

      -- Method: get_info ()
          Return a string containing the "info" for a message. This is
          useful for accessing and modifying "info" that is
          experimental (i.e., not a list of flags).

      -- Method: set_info (info)
          Set "info" to _info_, which should be a string.

When a *note MaildirMessage: 1825. instance is created based upon an
*note mboxMessage: 1809. or *note MMDFMessage: 1859. instance, the
`Status' and `X-Status' headers are omitted and the following
conversions take place:

Resulting state          *note mboxMessage: 1809. or *note MMDFMessage:
                         1859.  state
---------------------------------------------------------------------------- 
"cur" subdirectory       O flag
F flag                   F flag
R flag                   A flag
S flag                   R flag
T flag                   D flag

  When a *note MaildirMessage: 1825. instance is created based upon an
*note MHMessage: 183e. instance, the following conversions take place:

Resulting state                     *note MHMessage: 183e. state
------------------------------------------------------------------- 
"cur" subdirectory                  "unseen" sequence
"cur" subdirectory and S flag       no "unseen" sequence
F flag                              "flagged" sequence
R flag                              "replied" sequence

  When a *note MaildirMessage: 1825. instance is created based upon a
*note BabylMessage: 1851. instance, the following conversions take
place:

Resulting state                     *note BabylMessage: 1851. state
------------------------------------------------------------------------ 
"cur" subdirectory                  "unseen" label
"cur" subdirectory and S flag       no "unseen" label
P flag                              "forwarded" or "resent" label
R flag                              "answered" label
T flag                              "deleted" label


File: python.info,  Node: mboxMessage,  Next: MHMessage,  Prev: MaildirMessage,  Up: Message objects

5.18.4.9 `mboxMessage'
......................

 -- Class: mailbox.mboxMessage ([message])
     A message with mbox-specific behaviors. Parameter _message_ has
     the same meaning as with the *note Message: 1801. constructor.

     Messages in an mbox mailbox are stored together in a single file.
     The sender's envelope address and the time of delivery are
     typically stored in a line beginning with "From " that is used to
     indicate the start of a message, though there is considerable
     variation in the exact format of this data among mbox
     implementations. Flags that indicate the state of the message,
     such as whether it has been read or marked as important, are
     typically stored in `Status' and `X-Status' headers.

     Conventional flags for mbox messages are as follows:

     Flag       Meaning        Explanation
     --------------------------------------------------------------- 
     R          Read           Read
     O          Old            Previously detected by MUA
     D          Deleted        Marked for subsequent deletion
     F          Flagged        Marked as important
     A          Answered       Replied to

     The "R" and "O" flags are stored in the `Status' header, and the
     "D", "F", and "A" flags are stored in the `X-Status' header. The
     flags and headers typically appear in the order mentioned.

     *note mboxMessage: 1809. instances offer the following methods:

      -- Method: get_from ()
          Return a string representing the "From " line that marks the
          start of the message in an mbox mailbox. The leading "From "
          and the trailing newline are excluded.

      -- Method: set_from (from_[, time_=None])
          Set the "From " line to _from__, which should be specified
          without a leading "From " or trailing newline. For
          convenience, _time__ may be specified and will be formatted
          appropriately and appended to _from__. If _time__ is
          specified, it should be a `struct_time' instance, a tuple
          suitable for passing to *note time.strftime(): 3ad, or `True'
          (to use *note time.gmtime(): b0b.).

      -- Method: get_flags ()
          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of `'R'', `'O'', `'D'', `'F'', and
          `'A''.

      -- Method: set_flags (flags)
          Set the flags specified by _flags_ and unset all others.
          Parameter _flags_ should be the concatenation in any order of
          zero or more occurrences of each of `'R'', `'O'', `'D'',
          `'F'', and `'A''.

      -- Method: add_flag (flag)
          Set the flag(s) specified by _flag_ without changing other
          flags. To add more than one flag at a time, _flag_ may be a
          string of more than one character.

      -- Method: remove_flag (flag)
          Unset the flag(s) specified by _flag_ without changing other
          flags. To remove more than one flag at a time, _flag_ maybe a
          string of more than one character.

When an *note mboxMessage: 1809. instance is created based upon a *note
MaildirMessage: 1825. instance, a "From " line is generated based upon
the *note MaildirMessage: 1825. instance's delivery date, and the
following conversions take place:

Resulting state       *note MaildirMessage: 1825. state
---------------------------------------------------------- 
R flag                S flag
O flag                "cur" subdirectory
D flag                T flag
F flag                F flag
A flag                R flag

  When an *note mboxMessage: 1809. instance is created based upon an
*note MHMessage: 183e. instance, the following conversions take place:

Resulting state         *note MHMessage: 183e. state
------------------------------------------------------- 
R flag and O flag       no "unseen" sequence
O flag                  "unseen" sequence
F flag                  "flagged" sequence
A flag                  "replied" sequence

  When an *note mboxMessage: 1809. instance is created based upon a
*note BabylMessage: 1851. instance, the following conversions take
place:

Resulting state         *note BabylMessage: 1851. state
---------------------------------------------------------- 
R flag and O flag       no "unseen" label
O flag                  "unseen" label
D flag                  "deleted" label
A flag                  "answered" label

  When a *note Message: 1801. instance is created based upon an *note
MMDFMessage: 1859.  instance, the "From " line is copied and all flags
directly correspond:

Resulting state       *note MMDFMessage: 1859. state
------------------------------------------------------- 
R flag                R flag
O flag                O flag
D flag                D flag
F flag                F flag
A flag                A flag


File: python.info,  Node: MHMessage,  Next: BabylMessage,  Prev: mboxMessage,  Up: Message objects

5.18.4.10 `MHMessage'
.....................

 -- Class: mailbox.MHMessage ([message])
     A message with MH-specific behaviors. Parameter _message_ has the
     same meaning as with the *note Message: 1801. constructor.

     MH messages do not support marks or flags in the traditional
     sense, but they do support sequences, which are logical groupings
     of arbitrary messages. Some mail reading programs (although not
     the standard *mh* and *nmh*) use sequences in much the same way
     flags are used with other formats, as follows:

     Sequence       Explanation
     -------------------------------------------------------------- 
     unseen         Not read, but previously detected by MUA
     replied        Replied to
     flagged        Marked as important

     *note MHMessage: 183e. instances offer the following methods:

      -- Method: get_sequences ()
          Return a list of the names of sequences that include this
          message.

      -- Method: set_sequences (sequences)
          Set the list of sequences that include this message.

      -- Method: add_sequence (sequence)
          Add _sequence_ to the list of sequences that include this
          message.

      -- Method: remove_sequence (sequence)
          Remove _sequence_ from the list of sequences that include
          this message.

When an *note MHMessage: 183e. instance is created based upon a *note
MaildirMessage: 1825. instance, the following conversions take place:

Resulting state          *note MaildirMessage: 1825. state
------------------------------------------------------------- 
"unseen" sequence        no S flag
"replied" sequence       R flag
"flagged" sequence       F flag

  When an *note MHMessage: 183e. instance is created based upon an
*note mboxMessage: 1809. or *note MMDFMessage: 1859. instance, the
`Status' and `X-Status' headers are omitted and the following
conversions take place:

Resulting state          *note mboxMessage: 1809. or *note MMDFMessage:
                         1859.  state
---------------------------------------------------------------------------- 
"unseen" sequence        no R flag
"replied" sequence       A flag
"flagged" sequence       F flag

  When an *note MHMessage: 183e. instance is created based upon a *note
BabylMessage: 1851. instance, the following conversions take place:

Resulting state          *note BabylMessage: 1851. state
----------------------------------------------------------- 
"unseen" sequence        "unseen" label
"replied" sequence       "answered" label


File: python.info,  Node: BabylMessage,  Next: MMDFMessage,  Prev: MHMessage,  Up: Message objects

5.18.4.11 `BabylMessage'
........................

 -- Class: mailbox.BabylMessage ([message])
     A message with Babyl-specific behaviors. Parameter _message_ has
     the same meaning as with the *note Message: 1801. constructor.

     Certain message labels, called _attributes_, are defined by
     convention to have special meanings. The attributes are as follows:

     Label           Explanation
     --------------------------------------------------------------- 
     unseen          Not read, but previously detected by MUA
     deleted         Marked for subsequent deletion
     filed           Copied to another file or mailbox
     answered        Replied to
     forwarded       Forwarded
     edited          Modified by the user
     resent          Resent

     By default, Rmail displays only visible headers. The *note
     BabylMessage: 1851.  class, though, uses the original headers
     because they are more complete. Visible headers may be accessed
     explicitly if desired.

     *note BabylMessage: 1851. instances offer the following methods:

      -- Method: get_labels ()
          Return a list of labels on the message.

      -- Method: set_labels (labels)
          Set the list of labels on the message to _labels_.

      -- Method: add_label (label)
          Add _label_ to the list of labels on the message.

      -- Method: remove_label (label)
          Remove _label_ from the list of labels on the message.

      -- Method: get_visible ()
          Return an *note Message: 1801. instance whose headers are the
          message's visible headers and whose body is empty.

      -- Method: set_visible (visible)
          Set the message's visible headers to be the same as the
          headers in _message_.  Parameter _visible_ should be a *note
          Message: 1801. instance, an `email.Message.Message' instance,
          a string, or a file-like object (which should be open in text
          mode).

      -- Method: update_visible ()
          When a *note BabylMessage: 1851. instance's original headers
          are modified, the visible headers are not automatically
          modified to correspond. This method updates the visible
          headers as follows: each visible header with a corresponding
          original header is set to the value of the original header,
          each visible header without a corresponding original header
          is removed, and any of `Date', `From', `Reply-To', `To',
          `CC', and `Subject' that are present in the original headers
          but not the visible headers are added to the visible headers.

When a *note BabylMessage: 1851. instance is created based upon a *note
MaildirMessage: 1825. instance, the following conversions take place:

Resulting state         *note MaildirMessage: 1825. state
------------------------------------------------------------ 
"unseen" label          no S flag
"deleted" label         T flag
"answered" label        R flag
"forwarded" label       P flag

  When a *note BabylMessage: 1851. instance is created based upon an
*note mboxMessage: 1809. or *note MMDFMessage: 1859. instance, the
`Status' and `X-Status' headers are omitted and the following
conversions take place:

Resulting state        *note mboxMessage: 1809. or *note MMDFMessage:
                       1859.  state
-------------------------------------------------------------------------- 
"unseen" label         no R flag
"deleted" label        D flag
"answered" label       A flag

  When a *note BabylMessage: 1851. instance is created based upon an
*note MHMessage: 183e. instance, the following conversions take place:

Resulting state        *note MHMessage: 183e. state
------------------------------------------------------ 
"unseen" label         "unseen" sequence
"answered" label       "replied" sequence


File: python.info,  Node: MMDFMessage,  Prev: BabylMessage,  Up: Message objects

5.18.4.12 `MMDFMessage'
.......................

 -- Class: mailbox.MMDFMessage ([message])
     A message with MMDF-specific behaviors. Parameter _message_ has
     the same meaning as with the *note Message: 1801. constructor.

     As with message in an mbox mailbox, MMDF messages are stored with
     the sender's address and the delivery date in an initial line
     beginning with "From ".  Likewise, flags that indicate the state
     of the message are typically stored in `Status' and `X-Status'
     headers.

     Conventional flags for MMDF messages are identical to those of
     mbox message and are as follows:

     Flag       Meaning        Explanation
     --------------------------------------------------------------- 
     R          Read           Read
     O          Old            Previously detected by MUA
     D          Deleted        Marked for subsequent deletion
     F          Flagged        Marked as important
     A          Answered       Replied to

     The "R" and "O" flags are stored in the `Status' header, and the
     "D", "F", and "A" flags are stored in the `X-Status' header. The
     flags and headers typically appear in the order mentioned.

     *note MMDFMessage: 1859. instances offer the following methods,
     which are identical to those offered by *note mboxMessage: 1809.:

      -- Method: get_from ()
          Return a string representing the "From " line that marks the
          start of the message in an mbox mailbox. The leading "From "
          and the trailing newline are excluded.

      -- Method: set_from (from_[, time_=None])
          Set the "From " line to _from__, which should be specified
          without a leading "From " or trailing newline. For
          convenience, _time__ may be specified and will be formatted
          appropriately and appended to _from__. If _time__ is
          specified, it should be a `struct_time' instance, a tuple
          suitable for passing to *note time.strftime(): 3ad, or `True'
          (to use *note time.gmtime(): b0b.).

      -- Method: get_flags ()
          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of `'R'', `'O'', `'D'', `'F'', and
          `'A''.

      -- Method: set_flags (flags)
          Set the flags specified by _flags_ and unset all others.
          Parameter _flags_ should be the concatenation in any order of
          zero or more occurrences of each of `'R'', `'O'', `'D'',
          `'F'', and `'A''.

      -- Method: add_flag (flag)
          Set the flag(s) specified by _flag_ without changing other
          flags. To add more than one flag at a time, _flag_ may be a
          string of more than one character.

      -- Method: remove_flag (flag)
          Unset the flag(s) specified by _flag_ without changing other
          flags. To remove more than one flag at a time, _flag_ maybe a
          string of more than one character.

When an *note MMDFMessage: 1859. instance is created based upon a *note
MaildirMessage: 1825. instance, a "From " line is generated based upon
the *note MaildirMessage: 1825. instance's delivery date, and the
following conversions take place:

Resulting state       *note MaildirMessage: 1825. state
---------------------------------------------------------- 
R flag                S flag
O flag                "cur" subdirectory
D flag                T flag
F flag                F flag
A flag                R flag

  When an *note MMDFMessage: 1859. instance is created based upon an
*note MHMessage: 183e. instance, the following conversions take place:

Resulting state         *note MHMessage: 183e. state
------------------------------------------------------- 
R flag and O flag       no "unseen" sequence
O flag                  "unseen" sequence
F flag                  "flagged" sequence
A flag                  "replied" sequence

  When an *note MMDFMessage: 1859. instance is created based upon a
*note BabylMessage: 1851. instance, the following conversions take
place:

Resulting state         *note BabylMessage: 1851. state
---------------------------------------------------------- 
R flag and O flag       no "unseen" label
O flag                  "unseen" label
D flag                  "deleted" label
A flag                  "answered" label

  When an *note MMDFMessage: 1859. instance is created based upon an
*note mboxMessage: 1809. instance, the "From " line is copied and all
flags directly correspond:

Resulting state       *note mboxMessage: 1809. state
------------------------------------------------------- 
R flag                R flag
O flag                O flag
D flag                D flag
F flag                F flag
A flag                A flag


File: python.info,  Node: Exceptions<5>,  Next: Deprecated classes and methods,  Prev: Message objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.13 Exceptions
....................

The following exception classes are defined in the *note mailbox: 10a.
module:

 -- Exception: mailbox.Error
     The based class for all other module-specific exceptions.

 -- Exception: mailbox.NoSuchMailboxError
     Raised when a mailbox is expected but is not found, such as when
     instantiating a *note Mailbox: 1800. subclass with a path that
     does not exist (and with the _create_ parameter set to `False'),
     or when opening a folder that does not exist.

 -- Exception: mailbox.NotEmptyError
     Raised when a mailbox is not empty but is expected to be, such as
     when deleting a folder that contains messages.

 -- Exception: mailbox.ExternalClashError
     Raised when some mailbox-related condition beyond the control of
     the program causes it to be unable to proceed, such as when
     failing to acquire a lock that another program already holds a
     lock, or when a uniquely-generated file name already exists.

 -- Exception: mailbox.FormatError
     Raised when the data in a file cannot be parsed, such as when an
     *note MH: 183d.  instance attempts to read a corrupted
     `.mh_sequences' file.


File: python.info,  Node: Deprecated classes and methods,  Next: Examples<9>,  Prev: Exceptions<5>,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.14 Deprecated classes and methods
........................................

Deprecated since version 2.6.

  Older versions of the *note mailbox: 10a. module do not support
modification of mailboxes, such as adding or removing message, and do
not provide classes to represent format-specific message properties.
For backward compatibility, the older mailbox classes are still
available, but the newer classes should be used in preference to them.
The old classes will be removed in Python 3.0.

  Older mailbox objects support only iteration and provide a single
public method:

 -- Method: oldmailbox.next ()
     Return the next message in the mailbox, created with the optional
     _factory_ argument passed into the mailbox object's constructor.
     By default this is an *note rfc822.Message: 1826. object (see the
     *note rfc822: 149. module).  Depending on the mailbox
     implementation the _fp_ attribute of this object may be a true file
     object or a class instance simulating a file object, taking care
     of things like message boundaries if multiple mail messages are
     contained in a single file, etc.  If no more messages are
     available, this method returns `None'.

  Most of the older mailbox classes have names that differ from the
current mailbox class names, except for *note Maildir: 235. For this
reason, the new *note Maildir: 235. class defines a `next()' method and
its constructor differs slightly from those of the other new mailbox
classes.

  The older mailbox classes whose names are not the same as their newer
counterparts are as follows:

 -- Class: mailbox.UnixMailbox (fp[, factory])
     Access to a classic Unix-style mailbox, where all messages are
     contained in a single file and separated by `From' (a.k.a.
     `From_') lines.  The file object _fp_ points to the mailbox file.
     The optional _factory_ parameter is a callable that should create
     new message objects.  _factory_ is called with one argument, _fp_
     by the `next()' method of the mailbox object.  The default is the
     *note rfc822.Message: 1826. class (see the *note rfc822: 149.
     module - and the note below).

          Note: For reasons of this module's internal implementation,
          you will probably want to open the _fp_ object in binary
          mode.  This is especially important on Windows.

     For maximum portability, messages in a Unix-style mailbox are
     separated by any line that begins exactly with the string `'From
     '' (note the trailing space) if preceded by exactly two newlines.
     Because of the wide-range of variations in practice, nothing else
     on the `From_' line should be considered.  However, the current
     implementation doesn't check for the leading two newlines.  This is
     usually fine for most applications.

     The *note UnixMailbox: 1890. class implements a more strict
     version of `From_' line checking, using a regular expression that
     usually correctly matched `From_' delimiters.  It considers
     delimiter line to be separated by `From name time' lines.  For
     maximum portability, use the *note PortableUnixMailbox: 1891.
     class instead.  This class is identical to *note UnixMailbox:
     1890. except that individual messages are separated by only `From'
     lines.

 -- Class: mailbox.PortableUnixMailbox (fp[, factory])
     A less-strict version of *note UnixMailbox: 1890, which considers
     only the `From' at the beginning of the line separating messages.
     The "_name_ _time_" portion of the From line is ignored, to
     protect against some variations that are observed in practice.
     This works since lines in the message which begin with `'From ''
     are quoted by mail handling software at delivery-time.

 -- Class: mailbox.MmdfMailbox (fp[, factory])
     Access an MMDF-style mailbox, where all messages are contained in
     a single file and separated by lines consisting of 4 control-A
     characters.  The file object _fp_ points to the mailbox file.
     Optional _factory_ is as with the *note UnixMailbox: 1890. class.

 -- Class: mailbox.MHMailbox (dirname[, factory])
     Access an MH mailbox, a directory with each message in a separate
     file with a numeric name. The name of the mailbox directory is
     passed in _dirname_.  _factory_ is as with the *note UnixMailbox:
     1890. class.

 -- Class: mailbox.BabylMailbox (fp[, factory])
     Access a Babyl mailbox, which is similar to an MMDF mailbox.  In
     Babyl format, each message has two sets of headers, the _original_
     headers and the _visible_ headers.  The original headers appear
     before a line containing only `'*** EOOH ***''
     (End-Of-Original-Headers) and the visible headers appear after the
     `EOOH' line.  Babyl-compliant mail readers will show you only the
     visible headers, and *note BabylMailbox: 1894. objects will return
     messages containing only the visible headers.  You'll have to do
     your own parsing of the mailbox file to get at the original
     headers.  Mail messages start with the EOOH line and end with a
     line containing only `'\037\014''.  _factory_ is as with the *note
     UnixMailbox: 1890. class.

  If you wish to use the older mailbox classes with the *note email:
bc. module rather than the deprecated *note rfc822: 149. module, you
can do so as follows:

    import email
    import email.Errors
    import mailbox

    def msgfactory(fp):
        try:
            return email.message_from_file(fp)
        except email.Errors.MessageParseError:
            # Don't return None since that will
            # stop the mailbox iterator
            return ''

    mbox = mailbox.UnixMailbox(fp, msgfactory)

Alternatively, if you know your mailbox contains only well-formed MIME
messages, you can simplify this to:

    import email
    import mailbox

    mbox = mailbox.UnixMailbox(fp, email.message_from_file)



File: python.info,  Node: Examples<9>,  Prev: Deprecated classes and methods,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.15 Examples
..................

A simple example of printing the subjects of all messages in a mailbox
that seem interesting:

    import mailbox
    for message in mailbox.mbox('~/mbox'):
        subject = message['subject']       # Could possibly be None.
        if subject and 'python' in subject.lower():
            print subject

To copy all mail from a Babyl mailbox to an MH mailbox, converting all
of the format-specific information that can be converted:

    import mailbox
    destination = mailbox.MH('~/Mail')
    destination.lock()
    for message in mailbox.Babyl('~/RMAIL'):
        destination.add(mailbox.MHMessage(message))
    destination.flush()
    destination.unlock()

This example sorts mail from several mailing lists into different
mailboxes, being careful to avoid mail corruption due to concurrent
modification by other programs, mail loss due to interruption of the
program, or premature termination due to malformed messages in the
mailbox:

    import mailbox
    import email.Errors

    list_names = ('python-list', 'python-dev', 'python-bugs')

    boxes = dict((name, mailbox.mbox('~/email/%s' % name)) for name in list_names)
    inbox = mailbox.Maildir('~/Maildir', factory=None)

    for key in inbox.iterkeys():
        try:
            message = inbox[key]
        except email.Errors.MessageParseError:
            continue                # The message is malformed. Just leave it.

        for name in list_names:
            list_id = message['list-id']
            if list_id and name in list_id:
                # Get mailbox to use
                box = boxes[name]

                # Write copy to disk before removing original.
                # If there's a crash, you might duplicate a message, but
                # that's better than losing a message completely.
                box.lock()
                box.add(message)
                box.flush()
                box.unlock()

                # Remove original message
                inbox.lock()
                inbox.discard(key)
                inbox.flush()
                inbox.unlock()
                break               # Found destination, so stop looking.

    for box in boxes.itervalues():
        box.close()



File: python.info,  Node: mhlib --- Access to MH mailboxes,  Next: mimetools --- Tools for parsing MIME messages,  Prev: mailbox --- Manipulate mailboxes in various formats,  Up: Internet Data Handling

5.18.5 `mhlib' -- Access to MH mailboxes
----------------------------------------

Deprecated since version 2.6: The *note mhlib: 10f. module has been
removed in Python 3.0. Use the *note mailbox: 10a. instead.

  The *note mhlib: 10f. module provides a Python interface to MH
folders and their contents.

  The module contains three basic classes, *note MH: 1899, which
represents a particular collection of folders, *note Folder: 189a,
which represents a single folder, and *note Message: 189b, which
represents a single message.

 -- Class: mhlib.MH ([path[, profile]])
     *note MH: 1899. represents a collection of MH folders.

 -- Class: mhlib.Folder (mh, name)
     The *note Folder: 189a. class represents a single folder and its
     messages.

 -- Class: mhlib.Message (folder, number[, name])
     *note Message: 189b. objects represent individual messages in a
     folder.  The Message class is derived from *note
     mimetools.Message: 189c.

* Menu:

* MH Objects::
* Folder Objects::
* Message Objects::


File: python.info,  Node: MH Objects,  Next: Folder Objects,  Up: mhlib --- Access to MH mailboxes

5.18.5.1 MH Objects
...................

*note MH: 1899. instances have the following methods:

 -- Method: MH.error (format[, ...])
     Print an error message - can be overridden.

 -- Method: MH.getprofile (key)
     Return a profile entry (`None' if not set).

 -- Method: MH.getpath ()
     Return the mailbox pathname.

 -- Method: MH.getcontext ()
     Return the current folder name.

 -- Method: MH.setcontext (name)
     Set the current folder name.

 -- Method: MH.listfolders ()
     Return a list of top-level folders.

 -- Method: MH.listallfolders ()
     Return a list of all folders.

 -- Method: MH.listsubfolders (name)
     Return a list of direct subfolders of the given folder.

 -- Method: MH.listallsubfolders (name)
     Return a list of all subfolders of the given folder.

 -- Method: MH.makefolder (name)
     Create a new folder.

 -- Method: MH.deletefolder (name)
     Delete a folder - must have no subfolders.

 -- Method: MH.openfolder (name)
     Return a new open folder object.


File: python.info,  Node: Folder Objects,  Next: Message Objects,  Prev: MH Objects,  Up: mhlib --- Access to MH mailboxes

5.18.5.2 Folder Objects
.......................

*note Folder: 189a. instances represent open folders and have the
following methods:

 -- Method: Folder.error (format[, ...])
     Print an error message - can be overridden.

 -- Method: Folder.getfullname ()
     Return the folder's full pathname.

 -- Method: Folder.getsequencesfilename ()
     Return the full pathname of the folder's sequences file.

 -- Method: Folder.getmessagefilename (n)
     Return the full pathname of message _n_ of the folder.

 -- Method: Folder.listmessages ()
     Return a list of messages in the folder (as numbers).

 -- Method: Folder.getcurrent ()
     Return the current message number.

 -- Method: Folder.setcurrent (n)
     Set the current message number to _n_.

 -- Method: Folder.parsesequence (seq)
     Parse msgs syntax into list of messages.

 -- Method: Folder.getlast ()
     Get last message, or `0' if no messages are in the folder.

 -- Method: Folder.setlast (n)
     Set last message (internal use only).

 -- Method: Folder.getsequences ()
     Return dictionary of sequences in folder.  The sequence names are
     used  as keys, and the values are the lists of message numbers in
     the sequences.

 -- Method: Folder.putsequences (dict)
     Return dictionary of sequences in folder name: list.

 -- Method: Folder.removemessages (list)
     Remove messages in list from folder.

 -- Method: Folder.refilemessages (list, tofolder)
     Move messages in list to other folder.

 -- Method: Folder.movemessage (n, tofolder, ton)
     Move one message to a given destination in another folder.

 -- Method: Folder.copymessage (n, tofolder, ton)
     Copy one message to a given destination in another folder.


File: python.info,  Node: Message Objects,  Prev: Folder Objects,  Up: mhlib --- Access to MH mailboxes

5.18.5.3 Message Objects
........................

The *note Message: 189b. class adds one method to those of *note
mimetools.Message: 189c.:

 -- Method: Message.openmessage (n)
     Return a new open message object (costs a file descriptor).


File: python.info,  Node: mimetools --- Tools for parsing MIME messages,  Next: mimetypes --- Map filenames to MIME types,  Prev: mhlib --- Access to MH mailboxes,  Up: Internet Data Handling

5.18.6 `mimetools' -- Tools for parsing MIME messages
-----------------------------------------------------

Deprecated since version 2.3: The *note email: bc. package should be
used in preference to the *note mimetools: 110.  module.  This module
is present only to maintain backward compatibility, and it has been
removed in 3.x.

  This module defines a subclass of the *note rfc822: 149. module's
*note Message: 189c.  class and a number of utility functions that are
useful for the manipulation for MIME multipart or encoded message.

  It defines the following items:

 -- Class: mimetools.Message (fp[, seekable])
     Return a new instance of the *note Message: 189c. class.  This is
     a subclass of the *note rfc822.Message: 1826. class, with some
     additional methods (see below).  The _seekable_ argument has the
     same meaning as for *note rfc822.Message: 1826.

 -- Function: mimetools.choose_boundary ()
     Return a unique string that has a high likelihood of being usable
     as a part boundary.  The string has the form
     `'hostipaddr.uid.pid.timestamp.random''.

 -- Function: mimetools.decode (input, output, encoding)
     Read data encoded using the allowed MIME _encoding_ from open file
     object _input_ and write the decoded data to open file object
     _output_.  Valid values for _encoding_ include `'base64'',
     `'quoted-printable'', `'uuencode'', `'x-uuencode'', `'uue'',
     `'x-uue'', `'7bit'', and  `'8bit''.  Decoding messages encoded in
     `'7bit'' or `'8bit'' has no effect.  The input is simply copied to
     the output.

 -- Function: mimetools.encode (input, output, encoding)
     Read data from open file object _input_ and write it encoded using
     the allowed MIME _encoding_ to open file object _output_. Valid
     values for _encoding_ are the same as for *note decode(): 18c3.

 -- Function: mimetools.copyliteral (input, output)
     Read lines from open file _input_ until EOF and write them to open
     file _output_.

 -- Function: mimetools.copybinary (input, output)
     Read blocks until EOF from open file _input_ and write them to
     open file _output_.  The block size is currently fixed at 8192.

See also
........

Module *note email: bc.
     Comprehensive email handling package; supersedes the *note
     mimetools: 110. module.

Module *note rfc822: 149.
     Provides the base class for *note mimetools.Message: 189c.

Module *note multifile: 119.
     Support for reading files which contain distinct parts, such as
     MIME data.

<http://faqs.cs.uu.nl/na-dir/mail/mime-faq/.html>
     The MIME Frequently Asked Questions document.  For an overview of
     MIME, see the answer to question 1.1 in Part 1 of this document.

* Menu:

* Additional Methods of Message Objects::


File: python.info,  Node: Additional Methods of Message Objects,  Up: mimetools --- Tools for parsing MIME messages

5.18.6.1 Additional Methods of Message Objects
..............................................

The *note Message: 189c. class defines the following methods in
addition to the *note rfc822.Message: 1826. methods:

 -- Method: Message.getplist ()
     Return the parameter list of the `Content-Type' header. This is a
     list of strings.  For parameters of the form `key=value', _key_ is
     converted to lower case but _value_ is not.  For example, if the
     message contains the header `Content-type: text/html; spam=1;
     Spam=2; Spam' then *note getplist(): 18c9.  will return the Python
     list `['spam=1', 'spam=2', 'Spam']'.

 -- Method: Message.getparam (name)
     Return the _value_ of the first parameter (as returned by *note
     getplist(): 18c9.) of the form `name=value' for the given _name_.
     If _value_ is surrounded by quotes of the form '`<'...`>'' or
     '`"'...`"'', these are removed.

 -- Method: Message.getencoding ()
     Return the encoding specified in the `Content-Transfer-Encoding'
     message header.  If no such header exists, return `'7bit''.  The
     encoding is converted to lower case.

 -- Method: Message.gettype ()
     Return the message type (of the form `type/subtype') as specified
     in the `Content-Type' header.  If no such header exists, return
     `'text/plain''.  The type is converted to lower case.

 -- Method: Message.getmaintype ()
     Return the main type as specified in the `Content-Type' header.  If
     no such header exists, return `'text''.  The main type is
     converted to lower case.

 -- Method: Message.getsubtype ()
     Return the subtype as specified in the `Content-Type' header.  If
     no such header exists, return `'plain''.  The subtype is converted
     to lower case.


File: python.info,  Node: mimetypes --- Map filenames to MIME types,  Next: MimeWriter --- Generic MIME file writer,  Prev: mimetools --- Tools for parsing MIME messages,  Up: Internet Data Handling

5.18.7 `mimetypes' -- Map filenames to MIME types
-------------------------------------------------

The *note mimetypes: 111. module converts between a filename or URL and
the MIME type associated with the filename extension.  Conversions are
provided from filename to MIME type and from MIME type to filename
extension; encodings are not supported for the latter conversion.

  The module provides one class and a number of convenience functions.
The functions are the normal interface to this module, but some
applications may be interested in the class as well.

  The functions described below provide the primary interface for this
module.  If the module has not been initialized, they will call *note
init(): 18d1. if they rely on the information *note init(): 18d1. sets
up.

 -- Function: mimetypes.guess_type (filename[, strict])
     Guess the type of a file based on its filename or URL, given by
     _filename_.  The return value is a tuple `(type, encoding)' where
     _type_ is `None' if the type can't be guessed (missing or unknown
     suffix) or a string of the form `'type/subtype'', usable for a
     MIME `content-type' header.

     _encoding_ is `None' for no encoding or the name of the program
     used to encode (e.g. *compress* or *gzip*). The encoding is
     suitable for use as a `Content-Encoding' header, _not_ as a
     `Content-Transfer-Encoding' header. The mappings are table driven.
     Encoding suffixes are case sensitive; type suffixes are first
     tried case sensitively, then case insensitively.

     Optional _strict_ is a flag specifying whether the list of known
     MIME types is limited to only the official types registered with
     IANA(1) are recognized.  When _strict_ is true (the default), only
     the IANA types are supported; when _strict_ is false, some
     additional non-standard but commonly used MIME types are also
     recognized.

 -- Function: mimetypes.guess_all_extensions (type[, strict])
     Guess the extensions for a file based on its MIME type, given by
     _type_. The return value is a list of strings giving all possible
     filename extensions, including the leading dot (`'.'').  The
     extensions are not guaranteed to have been associated with any
     particular data stream, but would be mapped to the MIME type
     _type_ by *note guess_type(): 18d2.

     Optional _strict_ has the same meaning as with the *note
     guess_type(): 18d2. function.

 -- Function: mimetypes.guess_extension (type[, strict])
     Guess the extension for a file based on its MIME type, given by
     _type_. The return value is a string giving a filename extension,
     including the leading dot (`'.'').  The extension is not
     guaranteed to have been associated with any particular data
     stream, but would be mapped to the  MIME type _type_ by *note
     guess_type(): 18d2.  If no extension can be guessed for _type_,
     `None' is returned.

     Optional _strict_ has the same meaning as with the *note
     guess_type(): 18d2. function.

  Some additional functions and data items are available for
controlling the behavior of the module.

 -- Function: mimetypes.init ([files])
     Initialize the internal data structures.  If given, _files_ must
     be a sequence of file names which should be used to augment the
     default type map.  If omitted, the file names to use are taken
     from *note knownfiles: 18d5.; on Windows, the current registry
     settings are loaded.  Each file named in _files_ or *note
     knownfiles: 18d5. takes precedence over those named before it.
     Calling *note init(): 18d1. repeatedly is allowed.

     Changed in version 2.7: Previously, Windows registry settings were
     ignored.

 -- Function: mimetypes.read_mime_types (filename)
     Load the type map given in the file _filename_, if it exists.  The
     type map is returned as a dictionary mapping filename extensions,
     including the leading dot (`'.''), to strings of the form
     `'type/subtype''.  If the file _filename_ does not exist or cannot
     be read, `None' is returned.

 -- Function: mimetypes.add_type (type, ext[, strict])
     Add a mapping from the mimetype _type_ to the extension _ext_.
     When the extension is already known, the new type will replace the
     old one. When the type is already known the extension will be
     added to the list of known extensions.

     When _strict_ is True (the default), the mapping will added to the
     official MIME types, otherwise to the non-standard ones.

 -- Data: mimetypes.inited
     Flag indicating whether or not the global data structures have
     been initialized.  This is set to true by *note init(): 18d1.

 -- Data: mimetypes.knownfiles
     List of type map file names commonly installed.  These files are
     typically named `mime.types' and are installed in different
     locations by different packages.

 -- Data: mimetypes.suffix_map
     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the `.tgz'
     extension is mapped to `.tar.gz' to allow the encoding and type to
     be recognized separately.

 -- Data: mimetypes.encodings_map
     Dictionary mapping filename extensions to encoding types.

 -- Data: mimetypes.types_map
     Dictionary mapping filename extensions to MIME types.

 -- Data: mimetypes.common_types
     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.

  The *note MimeTypes: 18dd. class may be useful for applications which
may want more than one MIME-type database:

 -- Class: mimetypes.MimeTypes ([filenames])
     This class represents a MIME-types database.  By default, it
     provides access to the same database as the rest of this module.
     The initial database is a copy of that provided by the module, and
     may be extended by loading additional `mime.types'-style files
     into the database using the *note read(): 18de. or *note readfp():
     18df. methods.  The mapping dictionaries may also be cleared before
     loading additional data if the default data is not desired.

     The optional _filenames_ parameter can be used to cause additional
     files to be loaded "on top" of the default database.

     New in version 2.2.

  An example usage of the module:

    >>> import mimetypes
    >>> mimetypes.init()
    >>> mimetypes.knownfiles
    ['/etc/mime.types', '/etc/httpd/mime.types', ... ]
    >>> mimetypes.suffix_map['.tgz']
    '.tar.gz'
    >>> mimetypes.encodings_map['.gz']
    'gzip'
    >>> mimetypes.types_map['.tgz']
    'application/x-tar-gz'


* Menu:

* MimeTypes Objects::

  ---------- Footnotes ----------

  (1) http://www.iana.org/assignments/media-types/


File: python.info,  Node: MimeTypes Objects,  Up: mimetypes --- Map filenames to MIME types

5.18.7.1 MimeTypes Objects
..........................

*note MimeTypes: 18dd. instances provide an interface which is very
like that of the *note mimetypes: 111. module.

 -- Attribute: MimeTypes.suffix_map
     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the `.tgz'
     extension is mapped to `.tar.gz' to allow the encoding and type to
     be recognized separately.  This is initially a copy of the global
     `suffix_map' defined in the module.

 -- Attribute: MimeTypes.encodings_map
     Dictionary mapping filename extensions to encoding types.  This is
     initially a copy of the global `encodings_map' defined in the
     module.

 -- Attribute: MimeTypes.types_map
     Dictionary mapping filename extensions to MIME types.  This is
     initially a copy of the global `types_map' defined in the module.

 -- Attribute: MimeTypes.common_types
     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.  This is initially a copy of the global
     `common_types' defined in the module.

 -- Method: MimeTypes.guess_extension (type[, strict])
     Similar to the *note guess_extension(): 18d4. function, using the
     tables stored as part of the object.

 -- Method: MimeTypes.guess_all_extensions (type[, strict])
     Similar to the *note guess_all_extensions(): 18d3. function, using
     the tables stored as part of the object.

 -- Method: MimeTypes.guess_type (url[, strict])
     Similar to the *note guess_type(): 18d2. function, using the
     tables stored as part of the object.

 -- Method: MimeTypes.read (path)
     Load MIME information from a file named _path_.  This uses *note
     readfp(): 18df. to parse the file.

 -- Method: MimeTypes.readfp (file)
     Load MIME type information from an open file.  The file must have
     the format of the standard `mime.types' files.

 -- Method: MimeTypes.read_windows_registry ()
     Load MIME type information from the Windows registry.
     Availability: Windows.

     New in version 2.7.


File: python.info,  Node: MimeWriter --- Generic MIME file writer,  Next: mimify --- MIME processing of mail messages,  Prev: mimetypes --- Map filenames to MIME types,  Up: Internet Data Handling

5.18.8 `MimeWriter' -- Generic MIME file writer
-----------------------------------------------

Deprecated since version 2.3: The *note email: bc. package should be
used in preference to the *note MimeWriter: 112.  module.  This module
is present only to maintain backward compatibility.

  This module defines the class *note MimeWriter: 112.  The *note
MimeWriter: 112.  class implements a basic formatter for creating MIME
multi-part files.  It doesn't seek around the output file nor does it
use large amounts of buffer space. You must write the parts out in the
order that they should occur in the final file. *note MimeWriter: 112.
does buffer the headers you add, allowing you to rearrange their order.

 -- Class: MimeWriter.MimeWriter (fp)
     Return a new instance of the *note MimeWriter: 112. class.  The
     only argument passed, _fp_, is a file object to be used for
     writing. Note that a *note StringIO: 165. object could also be
     used.

* Menu:

* MimeWriter Objects::


File: python.info,  Node: MimeWriter Objects,  Up: MimeWriter --- Generic MIME file writer

5.18.8.1 MimeWriter Objects
...........................

*note MimeWriter: 112. instances have the following methods:

 -- Method: MimeWriter.addheader (key, value[, prefix])
     Add a header line to the MIME message. The _key_ is the name of
     the header, where the _value_ obviously provides the value of the
     header. The optional argument _prefix_ determines where the header
     is inserted; `0' means append at the end, `1' is insert at the
     start. The default is to append.

 -- Method: MimeWriter.flushheaders ()
     Causes all headers accumulated so far to be written out (and
     forgotten). This is useful if you don't need a body part at all,
     e.g. for a subpart of type `message/rfc822' that's (mis)used to
     store some header-like information.

 -- Method: MimeWriter.startbody (ctype[, plist[, prefix]])
     Returns a file-like object which can be used to write to the body
     of the message.  The content-type is set to the provided _ctype_,
     and the optional parameter _plist_ provides additional parameters
     for the content-type declaration. _prefix_ functions as in *note
     addheader(): 18ef. except that the default is to insert at the
     start.

 -- Method: MimeWriter.startmultipartbody (subtype[, boundary[, plist[,
          prefix]]])
     Returns a file-like object which can be used to write to the body
     of the message.  Additionally, this method initializes the
     multi-part code, where _subtype_ provides the multipart subtype,
     _boundary_ may provide a user-defined boundary specification, and
     _plist_ provides optional parameters for the subtype. _prefix_
     functions as in *note startbody(): 18f1.  Subparts should be
     created using *note nextpart(): 18f3.

 -- Method: MimeWriter.nextpart ()
     Returns a new instance of *note MimeWriter: 112. which represents
     an individual part in a multipart message.  This may be used to
     write the  part as well as used for creating recursively complex
     multipart messages. The message must first be initialized with
     *note startmultipartbody(): 18f2. before using *note nextpart():
     18f3.

 -- Method: MimeWriter.lastpart ()
     This is used to designate the last part of a multipart message,
     and should _always_ be used when writing multipart messages.


File: python.info,  Node: mimify --- MIME processing of mail messages,  Next: multifile --- Support for files containing distinct parts,  Prev: MimeWriter --- Generic MIME file writer,  Up: Internet Data Handling

5.18.9 `mimify' -- MIME processing of mail messages
---------------------------------------------------

Deprecated since version 2.3: The *note email: bc. package should be
used in preference to the *note mimify: 113.  module.  This module is
present only to maintain backward compatibility.

  The *note mimify: 113. module defines two functions to convert mail
messages to and from MIME format.  The mail message can be either a
simple message or a so-called multipart message.  Each part is treated
separately. Mimifying (a part of) a message entails encoding the
message as quoted-printable if it contains any characters that cannot
be represented using 7-bit ASCII.  Unmimifying (a part of) a message
entails undoing the quoted-printable encoding.  Mimify and unmimify are
especially useful when a message has to be edited before being sent.
Typical use would be:

    unmimify message
    edit message
    mimify message
    send message

The modules defines the following user-callable functions and
user-settable variables:

 -- Function: mimify.mimify (infile, outfile)
     Copy the message in _infile_ to _outfile_, converting parts to
     quoted-printable and adding MIME mail headers when necessary.
     _infile_ and _outfile_ can be file objects (actually, any object
     that has a *note readline(): 145. method (for _infile_) or a
     `write()' method (for _outfile_)) or strings naming the files. If
     _infile_ and _outfile_ are both strings, they may have the same
     value.

 -- Function: mimify.unmimify (infile, outfile[, decode_base64])
     Copy the message in _infile_ to _outfile_, decoding all
     quoted-printable parts.  _infile_ and _outfile_ can be file
     objects (actually, any object that has a *note readline(): 145.
     method (for _infile_) or a `write()' method (for _outfile_)) or
     strings naming the files.  If _infile_ and _outfile_ are both
     strings, they may have the same value. If the _decode_base64_
     argument is provided and tests true, any parts that are coded in
     the base64 encoding are decoded as well.

 -- Function: mimify.mime_decode_header (line)
     Return a decoded version of the encoded header line in _line_.
     This only supports the ISO 8859-1 charset (Latin-1).

 -- Function: mimify.mime_encode_header (line)
     Return a MIME-encoded version of the header line in _line_.

 -- Data: mimify.MAXLEN
     By default, a part will be encoded as quoted-printable when it
     contains any non-ASCII characters (characters with the 8th bit
     set), or if there are any lines longer than *note MAXLEN: 18fb.
     characters (default value 200).

 -- Data: mimify.CHARSET
     When not specified in the mail headers, a character set must be
     filled in.  The string used is stored in *note CHARSET: 18fc, and
     the default value is ISO-8859-1 (also known as Latin1 (latin-one)).

  This module can also be used from the command line.  Usage is as
follows:

    mimify.py -e [-l length] [infile [outfile]]
    mimify.py -d [-b] [infile [outfile]]

to encode (mimify) and decode (unmimify) respectively.  _infile_
defaults to standard input, _outfile_ defaults to standard output. The
same file can be specified for input and output.

  If the *-l* option is given when encoding, if there are any lines
longer than the specified _length_, the containing part will be encoded.

  If the *-b* option is given when decoding, any base64 parts will be
decoded as well.

See also
........

Module *note quopri: 142.
     Encode and decode MIME quoted-printable files.


File: python.info,  Node: multifile --- Support for files containing distinct parts,  Next: rfc822 --- Parse RFC 2822 mail headers,  Prev: mimify --- MIME processing of mail messages,  Up: Internet Data Handling

5.18.10 `multifile' -- Support for files containing distinct parts
------------------------------------------------------------------

Deprecated since version 2.5: The *note email: bc. package should be
used in preference to the *note multifile: 119.  module. This module is
present only to maintain backward compatibility.

  The *note MultiFile: 18ff. object enables you to treat sections of a
text file as file-like input objects, with `''' being returned by *note
readline(): 145. when a given delimiter pattern is encountered.  The
defaults of this class are designed to make it useful for parsing MIME
multipart messages, but by subclassing it and overriding methods  it
can be easily adapted for more general use.

 -- Class: multifile.MultiFile (fp[, seekable])
     Create a multi-file.  You must instantiate this class with an
     input object argument for the *note MultiFile: 18ff. instance to
     get lines from, such as a file object returned by *note open():
     2cb.

     *note MultiFile: 18ff. only ever looks at the input object's *note
     readline(): 145, *note seek(): 1900. and *note tell(): 1901.
     methods, and the latter two are only needed if you want random
     access to the individual MIME parts. To use *note MultiFile: 18ff.
     on a non-seekable stream object, set the optional _seekable_
     argument to false; this will prevent using the input object's
     *note seek(): 1900. and *note tell(): 1901. methods.

  It will be useful to know that in *note MultiFile: 18ff.'s view of
the world, text is composed of three kinds of lines: data,
section-dividers, and end-markers.  MultiFile is designed to support
parsing of messages that may have multiple nested message parts, each
with its own pattern for section-divider and end-marker lines.

See also
........

Module *note email: bc.
     Comprehensive email handling package; supersedes the *note
     multifile: 119. module.

* Menu:

* MultiFile Objects::
* MultiFile Example::


File: python.info,  Node: MultiFile Objects,  Next: MultiFile Example,  Up: multifile --- Support for files containing distinct parts

5.18.10.1 MultiFile Objects
...........................

A *note MultiFile: 18ff. instance has the following methods:

 -- Method: MultiFile.readline (str)
     Read a line.  If the line is data (not a section-divider or
     end-marker or real EOF) return it.  If the line matches the
     most-recently-stacked boundary, return `''' and set `self.last' to
     1 or 0 according as the match is or is not an end-marker.  If the
     line matches any other stacked boundary, raise an error.  On
     encountering end-of-file on the underlying stream object, the
     method raises `Error' unless all boundaries have been popped.

 -- Method: MultiFile.readlines (str)
     Return all lines remaining in this part as a list of strings.

 -- Method: MultiFile.read ()
     Read all lines, up to the next section.  Return them as a single
     (multiline) string.  Note that this doesn't take a size argument!

 -- Method: MultiFile.seek (pos[, whence])
     Seek.  Seek indices are relative to the start of the current
     section. The _pos_ and _whence_ arguments are interpreted as for a
     file seek.

 -- Method: MultiFile.tell ()
     Return the file position relative to the start of the current
     section.

 -- Method: MultiFile.next ()
     Skip lines to the next section (that is, read lines until a
     section-divider or end-marker has been consumed).  Return true if
     there is such a section, false if an end-marker is seen.
     Re-enable the most-recently-pushed boundary.

 -- Method: MultiFile.is_data (str)
     Return true if _str_ is data and false if it might be a section
     boundary.  As written, it tests for a prefix other than `'-'`-''
     at start of line (which all MIME boundaries have) but it is
     declared so it can be overridden in derived classes.

     Note that this test is used intended as a fast guard for the real
     boundary tests; if it always returns false it will merely slow
     processing, not cause it to fail.

 -- Method: MultiFile.push (str)
     Push a boundary string.  When a decorated version of this boundary
     is found as an input line, it will be interpreted as a
     section-divider  or end-marker (depending on the decoration, see RFC
     2045(1)).  All subsequent reads will return the empty string to
     indicate end-of-file, until a call to *note pop(): 190a.  removes
     the boundary a or *note next(): 1907. call reenables it.

     It is possible to push more than one boundary.  Encountering the
     most-recently-pushed boundary will return EOF; encountering any
     other boundary will raise an error.

 -- Method: MultiFile.pop ()
     Pop a section boundary.  This boundary will no longer be
     interpreted as EOF.

 -- Method: MultiFile.section_divider (str)
     Turn a boundary into a section-divider line.  By default, this
     method prepends `'--'' (which MIME section boundaries have) but it
     is declared so it can be overridden in derived classes.  This
     method need not append LF or CR-LF, as comparison with the result
     ignores trailing whitespace.

 -- Method: MultiFile.end_marker (str)
     Turn a boundary string into an end-marker line.  By default, this
     method prepends `'--'' and appends `'--'' (like a MIME-multipart
     end-of-message marker) but it is declared so it can be overridden
     in derived classes.  This method need not append LF or CR-LF, as
     comparison with the result ignores trailing whitespace.

  Finally, *note MultiFile: 18ff. instances have two public instance
variables:

 -- Attribute: MultiFile.level
     Nesting depth of the current part.

 -- Attribute: MultiFile.last
     True if the last end-of-file was for an end-of-message marker.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2045.html


File: python.info,  Node: MultiFile Example,  Prev: MultiFile Objects,  Up: multifile --- Support for files containing distinct parts

5.18.10.2 `MultiFile' Example
.............................

    import mimetools
    import multifile
    import StringIO

    def extract_mime_part_matching(stream, mimetype):
        """Return the first element in a multipart MIME message on stream
        matching mimetype."""

        msg = mimetools.Message(stream)
        msgtype = msg.gettype()
        params = msg.getplist()

        data = StringIO.StringIO()
        if msgtype[:10] == "multipart/":

            file = multifile.MultiFile(stream)
            file.push(msg.getparam("boundary"))
            while file.next():
                submsg = mimetools.Message(file)
                try:
                    data = StringIO.StringIO()
                    mimetools.decode(file, data, submsg.getencoding())
                except ValueError:
                    continue
                if submsg.gettype() == mimetype:
                    break
            file.pop()
        return data.getvalue()



File: python.info,  Node: rfc822 --- Parse RFC 2822 mail headers,  Next: base64 --- RFC 3548 Base16 Base32 Base64 Data Encodings,  Prev: multifile --- Support for files containing distinct parts,  Up: Internet Data Handling

5.18.11 `rfc822' -- Parse RFC 2822 mail headers
-----------------------------------------------

Deprecated since version 2.3: The *note email: bc. package should be
used in preference to the *note rfc822: 149.  module.  This module is
present only to maintain backward compatibility, and has been removed
in 3.0.

  This module defines a class, *note Message: 1826, which represents an
"email message" as defined by the Internet standard RFC 2822(1). (2)
Such messages consist of a collection of message headers, and a message
body.  This module also defines a helper class *note AddressList: 1913.
for parsing RFC 2822(3) addresses.  Please refer to the RFC for
information on the specific syntax of RFC 2822(4) messages.

  The *note mailbox: 10a. module provides classes  to read mailboxes
produced by various end-user mail programs.

 -- Class: rfc822.Message (file[, seekable])
     A *note Message: 1826. instance is instantiated with an input
     object as parameter.  Message relies only on the input object
     having a *note readline(): 145. method; in particular, ordinary
     file objects qualify.  Instantiation reads headers from the input
     object up to a delimiter line (normally a blank line) and stores
     them in the instance.  The message body, following the headers, is
     not consumed.

     This class can work with any input object that supports a *note
     readline(): 145.  method.  If the input object has seek and tell
     capability, the *note rewindbody(): 1914. method will work; also,
     illegal lines will be pushed back onto the input stream.  If the
     input object lacks seek but has an `unread()' method that can push
     back a line of input, *note Message: 1826. will use that to push
     back illegal lines.  Thus this class can be used to parse messages
     coming from a buffered stream.

     The optional _seekable_ argument is provided as a workaround for
     certain stdio libraries in which `tell()' discards buffered data
     before discovering that the `lseek()' system call doesn't work.
     For maximum portability, you should set the seekable argument to
     zero to prevent that initial `tell()' when passing in an
     unseekable object such as a file object created from a socket
     object.

     Input lines as read from the file may either be terminated by
     CR-LF or by a single linefeed; a terminating CR-LF is replaced by
     a single linefeed before the line is stored.

     All header matching is done independent of upper or lower case;
     e.g.  `m['From']', `m['from']' and `m['FROM']' all yield the same
     result.

 -- Class: rfc822.AddressList (field)
     You may instantiate the *note AddressList: 1913. helper class
     using a single string parameter, a comma-separated list of RFC
     2822(5) addresses to be parsed.  (The parameter `None' yields an
     empty list.)

 -- Function: rfc822.quote (str)
     Return a new string with backslashes in _str_ replaced by two
     backslashes and double quotes replaced by backslash-double quote.

 -- Function: rfc822.unquote (str)
     Return a new string which is an _unquoted_ version of _str_. If
     _str_ ends and begins with double quotes, they are stripped off.
     Likewise if _str_ ends and begins with angle brackets, they are
     stripped off.

 -- Function: rfc822.parseaddr (address)
     Parse _address_, which should be the value of some
     address-containing field such as `To' or `Cc', into its
     constituent "realname" and "email address" parts. Returns a tuple
     of that information, unless the parse fails, in which case a
     2-tuple `(None, None)' is returned.

 -- Function: rfc822.dump_address_pair (pair)
     The inverse of *note parseaddr(): 1917, this takes a 2-tuple of
     the form `(realname, email_address)' and returns the string value
     suitable for a `To' or `Cc' header.  If the first element of
     _pair_ is false, then the second element is returned unmodified.

 -- Function: rfc822.parsedate (date)
     Attempts to parse a date according to the rules in RFC 2822(6).
     however, some mailers don't follow that format as specified, so
     *note parsedate(): 1919. tries to guess correctly in such cases.
     _date_ is a string containing an RFC 2822(7) date, such as  `'Mon,
     20 Nov 1995 19:12:08 -0500''.  If it succeeds in parsing the date,
     *note parsedate(): 1919. returns a 9-tuple that can be passed
     directly to *note time.mktime(): 119a.; otherwise `None' will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: rfc822.parsedate_tz (date)
     Performs the same function as *note parsedate(): 1919, but returns
     either `None' or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *note time.mktime(): 119a, and the
     tenth is the offset of the date's timezone from UTC (which is the
     official term for Greenwich Mean Time).  (Note that the sign of
     the timezone offset is the opposite of the sign of the
     `time.timezone' variable for the same timezone; the latter
     variable follows the POSIX standard while this module follows RFC
     2822(8).)  If the input string has no timezone, the last element
     of the tuple returned is `None'.  Note that indexes 6, 7, and 8 of
     the result tuple are not usable.

 -- Function: rfc822.mktime_tz (tuple)
     Turn a 10-tuple as returned by *note parsedate_tz(): 191a. into a
     UTC timestamp.  If the timezone item in the tuple is `None',
     assume local time.  Minor deficiency: this first interprets the
     first 8 elements as a local time and then compensates for the
     timezone difference; this may yield a slight error around daylight
     savings time switch dates.  Not enough to worry about for common
     use.

See also
........

Module *note email: bc.
     Comprehensive email handling package; supersedes the *note rfc822:
     149. module.

Module *note mailbox: 10a.
     Classes to read various mailbox formats produced  by end-user mail
     programs.

Module *note mimetools: 110.
     Subclass of *note rfc822.Message: 1826. that handles MIME encoded
     messages.

* Menu:

* Message Objects: Message Objects<2>.
* AddressList Objects::

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html

  (2) This module originally conformed to RFC 822
(http://tools.ietf.org/html/rfc822.html), hence the name.  Since then, RFC
2822 (http://tools.ietf.org/html/rfc2822.html) has been released as an
update to RFC 822 (http://tools.ietf.org/html/rfc822.html).  This
module should be considered RFC 2822
(http://tools.ietf.org/html/rfc2822.html)-conformant, especially in
cases where the syntax or semantics have changed since RFC 822
(http://tools.ietf.org/html/rfc822.html).

  (3) http://tools.ietf.org/html/rfc2822.html

  (4) http://tools.ietf.org/html/rfc2822.html

  (5) http://tools.ietf.org/html/rfc2822.html

  (6) http://tools.ietf.org/html/rfc2822.html

  (7) http://tools.ietf.org/html/rfc2822.html

  (8) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: Message Objects<2>,  Next: AddressList Objects,  Up: rfc822 --- Parse RFC 2822 mail headers

5.18.11.1 Message Objects
.........................

A *note Message: 1826. instance has the following methods:

 -- Method: Message.rewindbody ()
     Seek to the start of the message body.  This only works if the
     file object is seekable.

 -- Method: Message.isheader (line)
     Returns a line's canonicalized fieldname (the dictionary key that
     will be used to index it) if the line is a legal RFC 2822(1)
     header; otherwise returns `None' (implying that parsing should
     stop here and the line be pushed back on the input stream).  It is
     sometimes useful to override this method in a subclass.

 -- Method: Message.islast (line)
     Return true if the given line is a delimiter on which Message
     should stop.  The delimiter line is consumed, and the file
     object's read location positioned immediately after it.  By
     default this method just checks that the line is blank, but you
     can override it in a subclass.

 -- Method: Message.iscomment (line)
     Return `True' if the given line should be ignored entirely, just
     skipped. By default this is a stub that always returns `False',
     but you can override it in a subclass.

 -- Method: Message.getallmatchingheaders (name)
     Return a list of lines consisting of all headers matching _name_,
     if any.  Each physical line, whether it is a continuation line or
     not, is a separate list item.  Return the empty list if no header
     matches _name_.

 -- Method: Message.getfirstmatchingheader (name)
     Return a list of lines comprising the first header matching
     _name_, and its continuation line(s), if any.  Return `None' if
     there is no header matching _name_.

 -- Method: Message.getrawheader (name)
     Return a single string consisting of the text after the colon in
     the first header matching _name_.  This includes leading
     whitespace, the trailing linefeed, and internal linefeeds and
     whitespace if there any continuation line(s) were present.  Return
     `None' if there is no header matching _name_.

 -- Method: Message.getheader (name[, default])
     Return a single string consisting of the last header matching
     _name_, but strip leading and trailing whitespace.  Internal
     whitespace is not stripped.  The optional _default_ argument can be
     used to specify a different default to be returned when there is
     no header matching _name_; it defaults to `None'.  This is the
     preferred way to get parsed headers.

 -- Method: Message.get (name[, default])
     An alias for *note getheader(): 1924, to make the interface more
     compatible  with regular dictionaries.

 -- Method: Message.getaddr (name)
     Return a pair `(full name, email address)' parsed from the string
     returned by `getheader(name)'.  If no header matching _name_
     exists, return `(None, None)'; otherwise both the full name and
     the address are (possibly empty) strings.

     Example: If _m_'s first `From' header contains the string
     `'jack@cwi.nl (Jack Jansen)'', then `m.getaddr('From')' will yield
     the pair `('Jack Jansen', 'jack@cwi.nl')'. If the header contained
     `'Jack Jansen <jack@cwi.nl>'' instead, it would yield the exact
     same result.

 -- Method: Message.getaddrlist (name)
     This is similar to `getaddr(list)', but parses a header containing
     a list of email addresses (e.g. a `To' header) and returns a list
     of `(full name, email address)' pairs (even if there was only one
     address in the header).  If there is no header matching _name_,
     return an empty list.

     If multiple headers exist that match the named header (e.g. if
     there are several `Cc' headers), all are parsed for addresses. Any
     continuation lines the named headers contain are also parsed.

 -- Method: Message.getdate (name)
     Retrieve a header using *note getheader(): 1924. and parse it into
     a 9-tuple compatible with *note time.mktime(): 119a.; note that
     fields 6, 7, and 8  are not usable.  If there is no header
     matching _name_, or it is unparsable, return `None'.

     Date parsing appears to be a black art, and not all mailers adhere
     to the standard.  While it has been tested and found correct on a
     large collection of email from many sources, it is still possible
     that this function may occasionally yield an incorrect result.

 -- Method: Message.getdate_tz (name)
     Retrieve a header using *note getheader(): 1924. and parse it into
     a 10-tuple; the first 9 elements will make a tuple compatible with
     *note time.mktime(): 119a, and the 10th is a number giving the
     offset of the date's timezone from UTC.  Note that fields 6, 7,
     and 8  are not usable.  Similarly to *note getdate(): 1928, if
     there is no header matching _name_, or it is unparsable, return
     `None'.

  *note Message: 1826. instances also support a limited mapping
interface. In particular: `m[name]' is like `m.getheader(name)' but
raises *note KeyError: 202.  if there is no matching header; and
`len(m)', `m.get(name[, default])', `name in m', `m.keys()',
`m.values()' `m.items()', and `m.setdefault(name[, default])' act as
expected, with the one difference that `setdefault()' uses an empty
string as the default value.  *note Message: 1826. instances also
support the mapping writable interface `m[name] = value' and `del
m[name]'.  *note Message: 1826. objects do not support the `clear()',
*note copy(): 71, `popitem()', or `update()' methods of the mapping
interface.  (Support for `get()' and `setdefault()' was only added in
Python 2.2.)

  Finally, *note Message: 1826. instances have some public instance
variables:

 -- Attribute: Message.headers
     A list containing the entire set of header lines, in the order in
     which they were read (except that setitem calls may disturb this
     order). Each line contains a trailing newline.  The blank line
     terminating the headers is not contained in the list.

 -- Attribute: Message.fp
     The file or file-like object passed at instantiation time.  This
     can be used to read the message content.

 -- Attribute: Message.unixfrom
     The Unix `From' line, if the message had one, or an empty string.
     This is needed to regenerate the message in some contexts, such as
     an `mbox'-style mailbox file.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: AddressList Objects,  Prev: Message Objects<2>,  Up: rfc822 --- Parse RFC 2822 mail headers

5.18.11.2 AddressList Objects
.............................

An *note AddressList: 1913. instance has the following methods:

 -- Method: AddressList.__len__ ()
     Return the number of addresses in the address list.

 -- Method: AddressList.__str__ ()
     Return a canonicalized string representation of the address list.
     Addresses are rendered in "name" <<host@domain>> form,
     comma-separated.

 -- Method: AddressList.__add__ (alist)
     Return a new *note AddressList: 1913. instance that contains all
     addresses in both *note AddressList: 1913. operands, with
     duplicates removed (set union).

 -- Method: AddressList.__iadd__ (alist)
     In-place version of *note __add__(): 1931.; turns this *note
     AddressList: 1913. instance into the union of itself and the
     right-hand instance, _alist_.

 -- Method: AddressList.__sub__ (alist)
     Return a new *note AddressList: 1913. instance that contains every
     address in the left-hand *note AddressList: 1913. operand that is
     not present in the right-hand address operand (set difference).

 -- Method: AddressList.__isub__ (alist)
     In-place version of *note __sub__(): 1933, removing addresses in
     this list which are also in _alist_.

  Finally, *note AddressList: 1913. instances have one public instance
variable:

 -- Attribute: AddressList.addresslist
     A list of tuple string pairs, one per address.  In each member,
     the first is the canonicalized name part, the second is the actual
     route-address (`'@''-separated username-host.domain pair).


File: python.info,  Node: base64 --- RFC 3548 Base16 Base32 Base64 Data Encodings,  Next: binhex --- Encode and decode binhex4 files,  Prev: rfc822 --- Parse RFC 2822 mail headers,  Up: Internet Data Handling

5.18.12 `base64' -- RFC 3548: Base16, Base32, Base64 Data Encodings
-------------------------------------------------------------------

This module provides data encoding and decoding as specified in RFC
3548(1).  This standard defines the Base16, Base32, and Base64
algorithms for encoding and decoding arbitrary binary strings into text
strings that can be safely sent by email, used as parts of URLs, or
included as part of an HTTP POST request.  The encoding algorithm is
not the same as the *uuencode* program.

  There are two interfaces provided by this module.  The modern
interface supports encoding and decoding string objects using all three
alphabets.  The legacy interface provides for encoding and decoding to
and from file-like objects as well as strings, but only using the
Base64 standard alphabet.

  The modern interface, which was introduced in Python 2.4, provides:

 -- Function: base64.b64encode (s[, altchars])
     Encode a string use Base64.

     _s_ is the string to encode.  Optional _altchars_ must be a string
     of at least length 2 (additional characters are ignored) which
     specifies an alternative alphabet for the `+' and `/' characters.
     This allows an application to e.g.  generate URL or filesystem
     safe Base64 strings.  The default is `None', for which the
     standard Base64 alphabet is used.

     The encoded string is returned.

 -- Function: base64.b64decode (s[, altchars])
     Decode a Base64 encoded string.

     _s_ is the string to decode.  Optional _altchars_ must be a string
     of at least length 2 (additional characters are ignored) which
     specifies the alternative alphabet used instead of the `+' and `/'
     characters.

     The decoded string is returned.  A *note TypeError: 215. is raised
     if _s_ were incorrectly padded or if there are non-alphabet
     characters present in the string.

 -- Function: base64.standard_b64encode (s)
     Encode string _s_ using the standard Base64 alphabet.

 -- Function: base64.standard_b64decode (s)
     Decode string _s_ using the standard Base64 alphabet.

 -- Function: base64.urlsafe_b64encode (s)
     Encode string _s_ using a URL-safe alphabet, which substitutes `-'
     instead of `+' and `_' instead of `/' in the standard Base64
     alphabet.  The result can still contain `='.

 -- Function: base64.urlsafe_b64decode (s)
     Decode string _s_ using a URL-safe alphabet, which substitutes `-'
     instead of `+' and `_' instead of `/' in the standard Base64
     alphabet.

 -- Function: base64.b32encode (s)
     Encode a string using Base32.  _s_ is the string to encode.  The
     encoded string is returned.

 -- Function: base64.b32decode (s[, casefold[, map01]])
     Decode a Base32 encoded string.

     _s_ is the string to decode.  Optional _casefold_ is a flag
     specifying whether a lowercase alphabet is acceptable as input.
     For security purposes, the default is `False'.

     RFC 3548(2) allows for optional mapping of the digit 0 (zero) to
     the letter O (oh), and for optional mapping of the digit 1 (one)
     to either the letter I (eye) or letter L (el).  The optional
     argument _map01_ when not `None', specifies which letter the digit
     1 should be mapped to (when _map01_ is not `None', the digit 0 is
     always mapped to the letter O).  For security purposes the default
     is `None', so that 0 and 1 are not allowed in the input.

     The decoded string is returned.  A *note TypeError: 215. is raised
     if _s_ were incorrectly padded or if there are non-alphabet
     characters present in the string.

 -- Function: base64.b16encode (s)
     Encode a string using Base16.

     _s_ is the string to encode.  The encoded string is returned.

 -- Function: base64.b16decode (s[, casefold])
     Decode a Base16 encoded string.

     _s_ is the string to decode.  Optional _casefold_ is a flag
     specifying whether a lowercase alphabet is acceptable as input.
     For security purposes, the default is `False'.

     The decoded string is returned.  A *note TypeError: 215. is raised
     if _s_ were incorrectly padded or if there are non-alphabet
     characters present in the string.

  The legacy interface:

 -- Function: base64.decode (input, output)
     Decode the contents of the _input_ file and write the resulting
     binary data to the _output_ file. _input_ and _output_ must either
     be file objects or objects that mimic the file object interface.
     _input_ will be read until `input.read()' returns an empty string.

 -- Function: base64.decodestring (s)
     Decode the string _s_, which must contain one or more lines of
     base64 encoded data, and return a string containing the resulting
     binary data.

 -- Function: base64.encode (input, output)
     Encode the contents of the _input_ file and write the resulting
     base64 encoded data to the _output_ file. _input_ and _output_
     must either be file objects or objects that mimic the file object
     interface. _input_ will be read until `input.read()' returns an
     empty string.  *note encode(): 1944. returns the encoded data plus
     a trailing newline character (`'\n'').

 -- Function: base64.encodestring (s)
     Encode the string _s_, which can contain arbitrary binary data,
     and return a string containing one or more lines of base64-encoded
     data.  *note encodestring(): 1945. returns a string containing one
     or more lines of base64-encoded data always including an extra
     trailing newline (`'\n'').

  An example usage of the module:

    >>> import base64
    >>> encoded = base64.b64encode('data to be encoded')
    >>> encoded
    'ZGF0YSB0byBiZSBlbmNvZGVk'
    >>> data = base64.b64decode(encoded)
    >>> data
    'data to be encoded'


See also
........

Module *note binascii: 19.
     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

RFC 1521(3) - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies
     Section 5.2, "Base64 Content-Transfer-Encoding," provides the
     definition of the base64 encoding.

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc3548.html

  (2) http://tools.ietf.org/html/rfc3548.html

  (3) http://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: binhex --- Encode and decode binhex4 files,  Next: binascii --- Convert between binary and ASCII,  Prev: base64 --- RFC 3548 Base16 Base32 Base64 Data Encodings,  Up: Internet Data Handling

5.18.13 `binhex' -- Encode and decode binhex4 files
---------------------------------------------------

This module encodes and decodes files in binhex4 format, a format
allowing representation of Macintosh files in ASCII.  On the Macintosh,
both forks of a file and the finder information are encoded (or
decoded), on other platforms only the data fork is handled.

     Note: In Python 3.x, special Macintosh support has been removed.

  The *note binhex: 1a. module defines the following functions:

 -- Function: binhex.binhex (input, output)
     Convert a binary file with filename _input_ to binhex file
     _output_. The _output_ parameter can either be a filename or a
     file-like object (any object supporting a `write()' and `close()'
     method).

 -- Function: binhex.hexbin (input[, output])
     Decode a binhex file _input_. _input_ may be a filename or a
     file-like object supporting `read()' and `close()' methods. The
     resulting file is written to a file named _output_, unless the
     argument is omitted in which case the output filename is read from
     the binhex file.

  The following exception is also defined:

 -- Exception: binhex.Error
     Exception raised when something can't be encoded using the binhex
     format (for example, a filename is too long to fit in the filename
     field), or when input is not properly encoded binhex data.

See also
........

Module *note binascii: 19.
     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

* Menu:

* Notes: Notes<2>.


File: python.info,  Node: Notes<2>,  Up: binhex --- Encode and decode binhex4 files

5.18.13.1 Notes
...............

There is an alternative, more powerful interface to the coder and
decoder, see the source for details.

  If you code or decode textfiles on non-Macintosh platforms they will
still use the old Macintosh newline convention (carriage-return as end
of line).

  As of this writing, *note hexbin(): 1949. appears to not work in all
cases.


File: python.info,  Node: binascii --- Convert between binary and ASCII,  Next: quopri --- Encode and decode MIME quoted-printable data,  Prev: binhex --- Encode and decode binhex4 files,  Up: Internet Data Handling

5.18.14 `binascii' -- Convert between binary and ASCII
------------------------------------------------------

The *note binascii: 19. module contains a number of methods to convert
between binary and various ASCII-encoded binary representations.
Normally, you will not use these functions directly but use wrapper
modules like *note uu: 190, *note base64: 15, or *note binhex: 1a.
instead. The *note binascii: 19. module contains low-level functions
written in C for greater speed that are used by the higher-level
modules.

  The *note binascii: 19. module defines the following functions:

 -- Function: binascii.a2b_uu (string)
     Convert a single line of uuencoded data back to binary and return
     the binary data. Lines normally contain 45 (binary) bytes, except
     for the last line. Line data may be followed by whitespace.

 -- Function: binascii.b2a_uu (data)
     Convert binary data to a line of ASCII characters, the return
     value is the converted line, including a newline char. The length
     of _data_ should be at most 45.

 -- Function: binascii.a2b_base64 (string)
     Convert a block of base64 data back to binary and return the
     binary data. More than one line may be passed at a time.

 -- Function: binascii.b2a_base64 (data)
     Convert binary data to a line of ASCII characters in base64
     coding. The return value is the converted line, including a
     newline char. The length of _data_ should be at most 57 to adhere
     to the base64 standard.

 -- Function: binascii.a2b_qp (string[, header])
     Convert a block of quoted-printable data back to binary and return
     the binary data. More than one line may be passed at a time. If
     the optional argument _header_ is present and true, underscores
     will be decoded as spaces.

 -- Function: binascii.b2a_qp (data[, quotetabs, istext, header])
     Convert binary data to a line(s) of ASCII characters in
     quoted-printable encoding.  The return value is the converted
     line(s). If the optional argument _quotetabs_ is present and true,
     all tabs and spaces will be encoded.   If the optional argument
     _istext_ is present and true, newlines are not encoded but
     trailing whitespace will be encoded. If the optional argument
     _header_ is present and true, spaces will be encoded as
     underscores per RFC1522. If the optional argument _header_ is
     present and false, newline characters will be encoded as well;
     otherwise linefeed conversion might corrupt the binary data stream.

 -- Function: binascii.a2b_hqx (string)
     Convert binhex4 formatted ASCII data to binary, without doing
     RLE-decompression.  The string should contain a complete number of
     binary bytes, or (in case of the last portion of the binhex4 data)
     have the remaining bits zero.

 -- Function: binascii.rledecode_hqx (data)
     Perform RLE-decompression on the data, as per the binhex4
     standard. The algorithm uses `0x90' after a byte as a repeat
     indicator, followed by a count.  A count of `0' specifies a byte
     value of `0x90'. The routine returns the decompressed data, unless
     data input data ends in an orphaned repeat indicator, in which
     case the *note Incomplete: 1957. exception is raised.

 -- Function: binascii.rlecode_hqx (data)
     Perform binhex4 style RLE-compression on _data_ and return the
     result.

 -- Function: binascii.b2a_hqx (data)
     Perform hexbin4 binary-to-ASCII translation and return the
     resulting string. The argument should already be RLE-coded, and
     have a length divisible by 3 (except possibly the last fragment).

 -- Function: binascii.crc_hqx (data, crc)
     Compute the binhex4 crc value of _data_, starting with an initial
     _crc_ and returning the result.

 -- Function: binascii.crc32 (data[, crc])
     Compute CRC-32, the 32-bit checksum of data, starting with an
     initial crc.  This is consistent with the ZIP file checksum.
     Since the algorithm is designed for use as a checksum algorithm,
     it is not suitable for use as a general hash algorithm.  Use as
     follows:

         print binascii.crc32("hello world")
         # Or, in two pieces:
         crc = binascii.crc32("hello")
         crc = binascii.crc32(" world", crc) & 0xffffffff
         print 'crc32 = 0x%08x' % crc



     Note: To generate the same numeric value across all Python
     versions and platforms use crc32(data) & 0xffffffff.  If you are
     only using the checksum in packed binary format this is not
     necessary as the return value is the correct 32bit binary
     representation regardless of sign.

  Changed in version 2.6: The return value is in the range [-2**31,
2**31-1] regardless of platform.  In the past the value would be signed
on some platforms and unsigned on others.  Use & 0xffffffff on the
value if you want it to match 3.0 behavior.

  Changed in version 3.0: The return value is unsigned and in the range
[0, 2**32-1] regardless of platform.

 -- Function: binascii.b2a_hex (data)
 -- Function: binascii.hexlify (data)
     Return the hexadecimal representation of the binary _data_.  Every
     byte of _data_ is converted into the corresponding 2-digit hex
     representation.  The resulting string is therefore twice as long
     as the length of _data_.

 -- Function: binascii.a2b_hex (hexstr)
 -- Function: binascii.unhexlify (hexstr)
     Return the binary data represented by the hexadecimal string
     _hexstr_.  This function is the inverse of *note b2a_hex(): 195c.
     _hexstr_ must contain an even number of hexadecimal digits (which
     can be upper or lower case), otherwise a *note TypeError: 215. is
     raised.

 -- Exception: binascii.Error
     Exception raised on errors. These are usually programming errors.

 -- Exception: binascii.Incomplete
     Exception raised on incomplete data. These are usually not
     programming errors, but may be handled by reading a little more
     data and trying again.

See also
........

Module *note base64: 15.
     Support for base64 encoding used in MIME email messages.

Module *note binhex: 1a.
     Support for the binhex format used on the Macintosh.

Module *note uu: 190.
     Support for UU encoding used on Unix.

Module *note quopri: 142.
     Support for quoted-printable encoding used in MIME email messages.


File: python.info,  Node: quopri --- Encode and decode MIME quoted-printable data,  Next: uu --- Encode and decode uuencode files,  Prev: binascii --- Convert between binary and ASCII,  Up: Internet Data Handling

5.18.15 `quopri' -- Encode and decode MIME quoted-printable data
----------------------------------------------------------------

This module performs quoted-printable transport encoding and decoding,
as defined in RFC 1521(1): "MIME (Multipurpose Internet Mail
Extensions) Part One: Mechanisms for Specifying and Describing the
Format of Internet Message Bodies".  The quoted-printable encoding is
designed for data where there are relatively few nonprintable
characters; the base64 encoding scheme available via the *note base64:
15. module is more compact if there are many such characters, as when
sending a graphics file.

See also
........

Latest version of the quopri module Python source code(2)

 -- Function: quopri.decode (input, output[, header])
     Decode the contents of the _input_ file and write the resulting
     decoded binary data to the _output_ file. _input_ and _output_
     must either be file objects or objects that mimic the file object
     interface. _input_ will be read until `input.readline()' returns
     an empty string. If the optional argument _header_ is present and
     true, underscore will be decoded as space. This is used to decode
     "Q"-encoded headers as described in RFC 1522(3): "MIME
     (Multipurpose Internet Mail Extensions) Part Two: Message Header
     Extensions for Non-ASCII Text".

 -- Function: quopri.encode (input, output, quotetabs)
     Encode the contents of the _input_ file and write the resulting
     quoted-printable data to the _output_ file. _input_ and _output_
     must either be file objects or objects that mimic the file object
     interface. _input_ will be read until `input.readline()' returns
     an empty string. _quotetabs_ is a flag which controls whether to
     encode embedded spaces and tabs; when true it encodes such
     embedded whitespace, and when false it leaves them unencoded.
     Note that spaces and tabs appearing at the end of lines are always
     encoded, as per RFC 1521(4).

 -- Function: quopri.decodestring (s[, header])
     Like *note decode(): 1963, except that it accepts a source string
     and returns the corresponding decoded string.

 -- Function: quopri.encodestring (s[, quotetabs])
     Like *note encode(): 1964, except that it accepts a source string
     and returns the corresponding encoded string.  _quotetabs_ is
     optional (defaulting to 0), and is passed straight through to
     *note encode(): 1964.

See also
........

Module *note mimify: 113.
     General utilities for processing of MIME messages.

Module *note base64: 15.
     Encode and decode MIME base64 data

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc1521.html

  (2)
http://svn.python.org/view/python/branches/release27-maint/Lib/quopri.py?view=markup

  (3) http://tools.ietf.org/html/rfc1522.html

  (4) http://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: uu --- Encode and decode uuencode files,  Prev: quopri --- Encode and decode MIME quoted-printable data,  Up: Internet Data Handling

5.18.16 `uu' -- Encode and decode uuencode files
------------------------------------------------

This module encodes and decodes files in uuencode format, allowing
arbitrary binary data to be transferred over ASCII-only connections.
Wherever a file argument is expected, the methods accept a file-like
object.  For backwards compatibility, a string containing a pathname is
also accepted, and the corresponding file will be opened for reading
and writing; the pathname `'-'' is understood to mean the standard
input or output.  However, this interface is deprecated; it's better
for the caller to open the file itself, and be sure that, when
required, the mode is `'rb'' or `'wb'' on Windows.

  This code was contributed by Lance Ellinghouse, and modified by Jack
Jansen.

See also
........

Latest version of the uu module Python source code(1)

  The *note uu: 190. module defines the following functions:

 -- Function: uu.encode (in_file, out_file[, name[, mode]])
     Uuencode file _in_file_ into file _out_file_.  The uuencoded file
     will have the header specifying _name_ and _mode_ as the defaults
     for the results of decoding the file. The default defaults are
     taken from _in_file_, or `'-'' and `0666' respectively.

 -- Function: uu.decode (in_file[, out_file[, mode[, quiet]]])
     This call decodes uuencoded file _in_file_ placing the result on
     file _out_file_. If _out_file_ is a pathname, _mode_ is used to
     set the permission bits if the file must be created. Defaults for
     _out_file_ and _mode_ are taken from the uuencode header.
     However, if the file specified in the header already exists, a
     *note uu.Error: 196b. is raised.

     *note decode(): 196a. may print a warning to standard error if the
     input was produced by an incorrect uuencoder and Python could
     recover from that error.  Setting _quiet_ to a true value silences
     this warning.

 -- Exception: uu.Error
     Subclass of *note Exception: 328, this can be raised by *note
     uu.decode(): 196a. under various situations, such as described
     above, but also including a badly formatted header, or truncated
     input file.

See also
........

Module *note binascii: 19.
     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

  ---------- Footnotes ----------

  (1)
http://svn.python.org/view/python/branches/release27-maint/Lib/uu.py?view=markup


File: python.info,  Node: Structured Markup Processing Tools,  Next: Internet Protocols and Support,  Prev: Internet Data Handling,  Up: The Python Standard Library

5.19 Structured Markup Processing Tools
=======================================

Python supports a variety of modules to work with various forms of
structured data markup.  This includes modules to work with the
Standard Generalized Markup Language (SGML) and the Hypertext Markup
Language (HTML), and several interfaces for working with the Extensible
Markup Language (XML).

  It is important to note that modules in the `xml' package require that
there be at least one SAX-compliant XML parser available. Starting with
Python 2.3, the Expat parser is included with Python, so the *note
xml.parsers.expat: 1a5.  module will always be available. You may still
want to be aware of the PyXML add-on package(1); that package provides
an extended set of XML libraries for Python.

  The documentation for the *note xml.dom: 1a1. and *note xml.sax: 1a6.
packages are the definition of the Python bindings for the DOM and SAX
interfaces.

* Menu:

* HTMLParser: HTMLParser --- Simple HTML and XHTML parser. Simple HTML and XHTML parser
* sgmllib: sgmllib --- Simple SGML parser. Simple SGML parser
* htmllib: htmllib --- A parser for HTML documents. A parser for HTML documents
* htmlentitydefs: htmlentitydefs --- Definitions of HTML general entities. Definitions of HTML general entities
* xml.parsers.expat: xml parsers expat --- Fast XML parsing using Expat. Fast XML parsing using Expat
* xml.dom: xml dom --- The Document Object Model API. The Document Object Model API
* xml.dom.minidom: xml dom minidom --- Lightweight DOM implementation. Lightweight DOM implementation
* xml.dom.pulldom: xml dom pulldom --- Support for building partial DOM trees. Support for building partial DOM trees
* xml.sax: xml sax --- Support for SAX2 parsers. Support for SAX2 parsers
* xml.sax.handler: xml sax handler --- Base classes for SAX handlers. Base classes for SAX handlers
* xml.sax.saxutils: xml sax saxutils --- SAX Utilities. SAX Utilities
* xml.sax.xmlreader: xml sax xmlreader --- Interface for XML parsers. Interface for XML parsers
* xml.etree.ElementTree: xml etree ElementTree --- The ElementTree XML API. The ElementTree XML API

HTMLParser --- Simple HTML and XHTML parser

* Example HTML Parser Application::

htmllib --- A parser for HTML documents

* HTMLParser Objects::

xml.parsers.expat --- Fast XML parsing using Expat

* XMLParser Objects::
* ExpatError Exceptions::
* Example: Example<9>.
* Content Model Descriptions::
* Expat error constants::

xml.dom --- The Document Object Model API

* Module Contents: Module Contents<3>.
* Objects in the DOM::
* Conformance::

Objects in the DOM

* DOMImplementation Objects::
* Node Objects::
* NodeList Objects::
* DocumentType Objects::
* Document Objects::
* Element Objects::
* Attr Objects::
* NamedNodeMap Objects::
* Comment Objects::
* Text and CDATASection Objects::
* ProcessingInstruction Objects::
* Exceptions: Exceptions<6>.

Conformance

* Type Mapping::
* Accessor Methods::

xml.dom.minidom --- Lightweight DOM implementation

* DOM Objects::
* DOM Example::
* minidom and the DOM standard::

xml.dom.pulldom --- Support for building partial DOM trees

* DOMEventStream Objects::

xml.sax --- Support for SAX2 parsers

* SAXException Objects::

xml.sax.handler --- Base classes for SAX handlers

* ContentHandler Objects::
* DTDHandler Objects::
* EntityResolver Objects::
* ErrorHandler Objects::

xml.sax.xmlreader --- Interface for XML parsers

* XMLReader Objects::
* IncrementalParser Objects::
* Locator Objects::
* InputSource Objects::
* The Attributes Interface::
* The AttributesNS Interface::

xml.etree.ElementTree --- The ElementTree XML API

* Functions: Functions<4>.
* Element Objects: Element Objects<2>.
* ElementTree Objects::
* QName Objects::
* TreeBuilder Objects::
* XMLParser Objects: XMLParser Objects<2>.

  ---------- Footnotes ----------

  (1) http://pyxml.sourceforge.net/


File: python.info,  Node: HTMLParser --- Simple HTML and XHTML parser,  Next: sgmllib --- Simple SGML parser,  Up: Structured Markup Processing Tools

5.19.1 `HTMLParser' -- Simple HTML and XHTML parser
---------------------------------------------------

     Note: The *note HTMLParser: ee. module has been renamed to
     `html.parser' in Python 3.0.  The *note 2to3: bbf. tool will
     automatically adapt imports when converting your sources to 3.0.

New in version 2.2.

  This module defines a class *note HTMLParser: ee. which serves as the
basis for parsing text files formatted in HTML (HyperText Mark-up
Language) and XHTML.  Unlike the parser in *note htmllib: ed, this
parser is not based on the SGML parser in *note sgmllib: 151.

 -- Class: HTMLParser.HTMLParser
     The *note HTMLParser: ee. class is instantiated without arguments.

     An *note HTMLParser: ee. instance is fed HTML data and calls
     handler functions when tags begin and end.  The *note HTMLParser:
     ee. class is meant to be overridden by the user to provide a
     desired behavior.

     Unlike the parser in *note htmllib: ed, this parser does not check
     that end tags match start tags or call the end-tag handler for
     elements which are closed implicitly by closing an outer element.

  An exception is defined as well:

 -- Exception: HTMLParser.HTMLParseError
     Exception raised by the *note HTMLParser: ee. class when it
     encounters an error while parsing.  This exception provides three
     attributes: `msg' is a brief message explaining the error,
     `lineno' is the number of the line on which the broken construct
     was detected, and `offset' is the number of characters into the
     line at which the construct starts.

  *note HTMLParser: ee. instances have the following methods:

 -- Method: HTMLParser.reset ()
     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: HTMLParser.feed (data)
     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *note close(): 1975. is called.

 -- Method: HTMLParser.close ()
     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call the *note HTMLParser: ee.
     base class method *note close(): 1975.

 -- Method: HTMLParser.getpos ()
     Return current line number and offset.

 -- Method: HTMLParser.get_starttag_text ()
     Return the text of the most recently opened start tag.  This
     should not normally be needed for structured processing, but may
     be useful in dealing with HTML "as deployed" or for re-generating
     input with minimal changes (whitespace between attributes can be
     preserved, etc.).

 -- Method: HTMLParser.handle_starttag (tag, attrs)
     This method is called to handle the start of a tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

     The _tag_ argument is the name of the tag converted to lower case.
     The _attrs_ argument is a list of `(name, value)' pairs containing
     the attributes found inside the tag's `<>' brackets.  The _name_
     will be translated to lower case, and quotes in the _value_ have
     been removed, and character and entity references have been
     replaced.  For instance, for the tag `<A
     HREF="http://www.cwi.nl/">', this method would be called as
     `handle_starttag('a', [('href', 'http://www.cwi.nl/')])'.

     Changed in version 2.6: All entity references from *note
     htmlentitydefs: ec. are now replaced in the attribute values.

 -- Method: HTMLParser.handle_startendtag (tag, attrs)
     Similar to *note handle_starttag(): 1978, but called when the
     parser encounters an XHTML-style empty tag (`<a .../>').  This
     method may be overridden by subclasses which require this
     particular lexical information; the default implementation simple
     calls *note handle_starttag(): 1978. and *note handle_endtag():
     197a.

 -- Method: HTMLParser.handle_endtag (tag)
     This method is called to handle the end tag of an element.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.  The _tag_ argument is the name of
     the tag converted to lower case.

 -- Method: HTMLParser.handle_data (data)
     This method is called to process arbitrary data.  It is intended
     to be overridden by a derived class; the base class implementation
     does nothing.

 -- Method: HTMLParser.handle_charref (name)
     This method is called to process a character reference of the form
     `&#ref;'.  It is intended to be overridden by a derived class; the
     base class implementation does nothing.

 -- Method: HTMLParser.handle_entityref (name)
     This method is called to process a general entity reference of the
     form `&name;' where _name_ is an general entity reference.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: HTMLParser.handle_comment (data)
     This method is called when a comment is encountered.  The
     _comment_ argument is a string containing the text between the
     `--' and `--' delimiters, but not the delimiters themselves.  For
     example, the comment `<!--text-->' will cause this method to be
     called with the argument `'text''.  It is intended to be
     overridden by a derived class; the base class implementation does
     nothing.

 -- Method: HTMLParser.handle_decl (decl)
     Method called when an SGML `doctype' declaration is read by the
     parser.  The _decl_ parameter will be the entire contents of the
     declaration inside the `<!...>' markup.  It is intended to be
     overridden by a derived class; the base class implementation does
     nothing.

 -- Method: HTMLParser.unknown_decl (data)
     Method called when an unrecognized SGML declaration is read by the
     parser.  The _data_ parameter will be the entire contents of the
     declaration inside the `<!...>' markup.  It is sometimes useful to
     be overridden by a derived class; the base class implementation
     throws an *note HTMLParseError: 1972.

 -- Method: HTMLParser.handle_pi (data)
     Method called when a processing instruction is encountered.  The
     _data_ parameter will contain the entire processing instruction.
     For example, for the processing instruction `<?proc color='red'>',
     this method would be called as `handle_pi("proc color='red'")'.
     It is intended to be overridden by a derived class; the base class
     implementation does nothing.

          Note: The *note HTMLParser: ee. class uses the SGML syntactic
          rules for processing instructions.  An XHTML processing
          instruction using the trailing `'?'' will cause the `'?'' to
          be included in _data_.

* Menu:

* Example HTML Parser Application::


File: python.info,  Node: Example HTML Parser Application,  Up: HTMLParser --- Simple HTML and XHTML parser

5.19.1.1 Example HTML Parser Application
........................................

As a basic example, below is a very basic HTML parser that uses the
*note HTMLParser: ee. class to print out tags as they are encountered:

    from HTMLParser import HTMLParser

    class MyHTMLParser(HTMLParser):

        def handle_starttag(self, tag, attrs):
            print "Encountered the beginning of a %s tag" % tag

        def handle_endtag(self, tag):
            print "Encountered the end of a %s tag" % tag



File: python.info,  Node: sgmllib --- Simple SGML parser,  Next: htmllib --- A parser for HTML documents,  Prev: HTMLParser --- Simple HTML and XHTML parser,  Up: Structured Markup Processing Tools

5.19.2 `sgmllib' -- Simple SGML parser
--------------------------------------

Deprecated since version 2.6: The *note sgmllib: 151. module has been
removed in Python 3.0.

  This module defines a class *note SGMLParser: 1986. which serves as
the basis for parsing text files formatted in SGML (Standard
Generalized Mark-up Language).  In fact, it does not provide a full
SGML parser -- it only parses SGML insofar as it is used by HTML, and
the module only exists as a base for the *note htmllib: ed. module.
Another HTML parser which supports XHTML and offers a somewhat
different interface is available in the *note HTMLParser: ee. module.

 -- Class: sgmllib.SGMLParser
     The *note SGMLParser: 1986. class is instantiated without
     arguments. The parser is hardcoded to recognize the following
     constructs:

        * Opening and closing tags of the form `<tag attr="value" ...>'
          and `</tag>', respectively.

        * Numeric character references of the form `&#name;'.

        * Entity references of the form `&name;'.

        * SGML comments of the form `<!--text-->'.  Note that spaces,
          tabs, and newlines are allowed between the trailing `>' and
          the immediately preceding `--'.

  A single exception is defined as well:

 -- Exception: sgmllib.SGMLParseError
     Exception raised by the *note SGMLParser: 1986. class when it
     encounters an error while parsing.

     New in version 2.1.

  *note SGMLParser: 1986. instances have the following methods:

 -- Method: SGMLParser.reset ()
     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: SGMLParser.setnomoretags ()
     Stop processing tags.  Treat all following input as literal input
     (CDATA).  (This is only provided so the HTML tag `<PLAINTEXT>' can
     be implemented.)

 -- Method: SGMLParser.setliteral ()
     Enter literal mode (CDATA mode).

 -- Method: SGMLParser.feed (data)
     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *note close(): 198c. is called.

 -- Method: SGMLParser.close ()
     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call *note close(): 198c.

 -- Method: SGMLParser.get_starttag_text ()
     Return the text of the most recently opened start tag.  This
     should not normally be needed for structured processing, but may
     be useful in dealing with HTML "as deployed" or for re-generating
     input with minimal changes (whitespace between attributes can be
     preserved, etc.).

 -- Method: SGMLParser.handle_starttag (tag, method, attributes)
     This method is called to handle start tags for which either a
     `start_tag()' or `do_tag()' method has been defined.  The _tag_
     argument is the name of the tag converted to lower case, and the
     _method_ argument is the bound method which should be used to
     support semantic interpretation of the start tag. The _attributes_
     argument is a list of `(name, value)' pairs containing the
     attributes found inside the tag's `<>' brackets.

     The _name_ has been translated to lower case. Double quotes and
     backslashes in the _value_ have been interpreted, as well as known
     character references and known entity references terminated by a
     semicolon (normally, entity references can be terminated by any
     non-alphanumerical character, but this would break the very common
     case of `<A HREF="url?spam=1&eggs=2">' when `eggs' is a valid
     entity name).

     For instance, for the tag `<A HREF="http://www.cwi.nl/">', this
     method would be called as `unknown_starttag('a', [('href',
     'http://www.cwi.nl/')])'.  The base implementation simply calls
     _method_ with _attributes_ as the only argument.

     New in version 2.5: Handling of entity and character references
     within attribute values.

 -- Method: SGMLParser.handle_endtag (tag, method)
     This method is called to handle endtags for which an `end_tag()'
     method has been defined.  The _tag_ argument is the name of the
     tag converted to lower case, and the _method_ argument is the
     bound method which should be used to support semantic
     interpretation of the end tag.  If no `end_tag()' method is
     defined for the closing element, this handler is not called.  The
     base implementation simply calls _method_.

 -- Method: SGMLParser.handle_data (data)
     This method is called to process arbitrary data.  It is intended
     to be overridden by a derived class; the base class implementation
     does nothing.

 -- Method: SGMLParser.handle_charref (ref)
     This method is called to process a character reference of the form
     `&#ref;'.  The base implementation uses *note convert_charref():
     1992. to convert the reference to a string.  If that method
     returns a string, it is passed to *note handle_data(): 1990,
     otherwise `unknown_charref(ref)' is called to handle the error.

     Changed in version 2.5: Use *note convert_charref(): 1992. instead
     of hard-coding the conversion.

 -- Method: SGMLParser.convert_charref (ref)
     Convert a character reference to a string, or `None'.  _ref_ is
     the reference passed in as a string.  In the base implementation,
     _ref_ must be a decimal number in the range 0-255.  It converts
     the code point found using the *note convert_codepoint(): 1993.
     method. If _ref_ is invalid or out of range, this method returns
     `None'.  This method is called by the default *note
     handle_charref(): 1991. implementation and by the attribute value
     parser.

     New in version 2.5.

 -- Method: SGMLParser.convert_codepoint (codepoint)
     Convert a codepoint to a *note str: 1e7. value.  Encodings can be
     handled here if appropriate, though the rest of *note sgmllib:
     151. is oblivious on this matter.

     New in version 2.5.

 -- Method: SGMLParser.handle_entityref (ref)
     This method is called to process a general entity reference of the
     form `&ref;' where _ref_ is an general entity reference.  It
     converts _ref_ by passing it to *note convert_entityref(): 1995.
     If a translation is returned, it calls the method *note
     handle_data(): 1990. with the translation; otherwise, it calls the
     method `unknown_entityref(ref)'. The default `entitydefs' defines
     translations for `&amp;', `&apos', `&gt;', `&lt;', and `&quot;'.

     Changed in version 2.5: Use *note convert_entityref(): 1995.
     instead of hard-coding the conversion.

 -- Method: SGMLParser.convert_entityref (ref)
     Convert a named entity reference to a *note str: 1e7. value, or
     `None'.  The resulting value will not be parsed.  _ref_ will be
     only the name of the entity.  The default implementation looks for
     _ref_ in the instance (or class) variable `entitydefs' which
     should be a mapping from entity names to corresponding
     translations.  If no translation is available for _ref_, this
     method returns `None'.  This method is called by the default *note
     handle_entityref(): 1994.  implementation and by the attribute
     value parser.

     New in version 2.5.

 -- Method: SGMLParser.handle_comment (comment)
     This method is called when a comment is encountered.  The
     _comment_ argument is a string containing the text between the
     `<!--' and `-->' delimiters, but not the delimiters themselves.
     For example, the comment `<!--text-->' will cause this method to
     be called with the argument `'text''.  The default method does
     nothing.

 -- Method: SGMLParser.handle_decl (data)
     Method called when an SGML declaration is read by the parser.  In
     practice, the `DOCTYPE' declaration is the only thing observed in
     HTML, but the parser does not discriminate among different (or
     broken) declarations.  Internal subsets in a `DOCTYPE' declaration
     are not supported.  The _data_ parameter will be the entire
     contents of the declaration inside the `<!'...`>' markup.  The
     default implementation does nothing.

 -- Method: SGMLParser.report_unbalanced (tag)
     This method is called when an end tag is found which does not
     correspond to any open element.

 -- Method: SGMLParser.unknown_starttag (tag, attributes)
     This method is called to process an unknown start tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: SGMLParser.unknown_endtag (tag)
     This method is called to process an unknown end tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: SGMLParser.unknown_charref (ref)
     This method is called to process unresolvable numeric character
     references.  Refer to *note handle_charref(): 1991. to determine
     what is handled by default.  It is intended to be overridden by a
     derived class; the base class implementation does nothing.

 -- Method: SGMLParser.unknown_entityref (ref)
     This method is called to process an unknown entity reference.  It
     is intended to be overridden by a derived class; the base class
     implementation does nothing.

  Apart from overriding or extending the methods listed above, derived
classes may also define methods of the following form to define
processing of specific tags.  Tag names in the input stream are case
independent; the _tag_ occurring in method names must be in lower case:

 -- Method: SGMLParser.start_tag (attributes)
     This method is called to process an opening tag _tag_.  It has
     preference over `do_tag()'.  The _attributes_ argument has the
     same meaning as described for `handle_starttag()' above.

 -- Method: SGMLParser.do_tag (attributes)
     This method is called to process an opening tag _tag_  for which no
     `start_tag()' method is defined.   The _attributes_ argument has
     the same meaning as described for `handle_starttag()' above.

 -- Method: SGMLParser.end_tag ()
     This method is called to process a closing tag _tag_.

  Note that the parser maintains a stack of open elements for which no
end tag has been found yet.  Only tags processed by `start_tag()' are
pushed on this stack.  Definition of an `end_tag()' method is optional
for these tags.  For tags processed by `do_tag()' or by
`unknown_tag()', no `end_tag()' method must be defined; if defined, it
will not be used.  If both `start_tag()' and `do_tag()' methods exist
for a tag, the `start_tag()' method takes precedence.


File: python.info,  Node: htmllib --- A parser for HTML documents,  Next: htmlentitydefs --- Definitions of HTML general entities,  Prev: sgmllib --- Simple SGML parser,  Up: Structured Markup Processing Tools

5.19.3 `htmllib' -- A parser for HTML documents
-----------------------------------------------

Deprecated since version 2.6: The *note htmllib: ed. module has been
removed in Python 3.0.

  This module defines a class which can serve as a base for parsing
text files formatted in the HyperText Mark-up Language (HTML).  The
class is not directly concerned with I/O -- it must be provided with
input in string form via a method, and makes calls to methods of a
"formatter" object in order to produce output.  The *note HTMLParser:
ee. class is designed to be used as a base class for other classes in
order to add functionality, and allows most of its methods to be
extended or overridden.  In turn, this class is derived from and extends
the `SGMLParser' class defined in module *note sgmllib: 151.  The *note
HTMLParser: ee. implementation supports the HTML 2.0 language as
described in RFC 1866(1).  Two implementations of formatter objects are
provided in the *note formatter: d4. module; refer to the documentation
for that module for information on the formatter interface.

  The following is a summary of the interface defined by *note
sgmllib.SGMLParser: 1986.:

   * The interface to feed data to an instance is through the `feed()'
     method, which takes a string argument.  This can be called with as
     little or as much text at a time as desired; `p.feed(a);
     p.feed(b)' has the same effect as `p.feed(a+b)'.  When the data
     contains complete HTML markup constructs, these are processed
     immediately; incomplete constructs are saved in a buffer.  To
     force processing of all unprocessed data, call the `close()'
     method.

     For example, to parse the entire contents of a file, use:

         parser.feed(open('myfile.html').read())
         parser.close()


   * The interface to define semantics for HTML tags is very simple:
     derive a class and define methods called `start_tag()',
     `end_tag()', or `do_tag()'.  The parser will call these at
     appropriate moments: `start_tag()' or `do_tag()' is called when an
     opening tag of the form `<tag ...>' is encountered; `end_tag()' is
     called when a closing tag of the form `<tag>' is encountered.  If
     an opening tag requires a corresponding closing tag, like `<H1>'
     ... `</H1>', the class should define the `start_tag()' method; if
     a tag requires no closing tag, like `<P>', the class should define
     the `do_tag()' method.

  The module defines a parser class and an exception:

 -- Class: htmllib.HTMLParser (formatter)
     This is the basic HTML parser class.  It supports all entity names
     required by the XHTML 1.0 Recommendation
     (<http://www.w3.org/TR/xhtml1>).   It also defines handlers for
     all HTML 2.0 and many HTML 3.0 and 3.2 elements.

 -- Exception: htmllib.HTMLParseError
     Exception raised by the *note HTMLParser: ee. class when it
     encounters an error while parsing.

     New in version 2.4.

See also
........

Module *note formatter: d4.
     Interface definition for transforming an abstract flow of
     formatting events into specific output events on writer objects.

Module *note HTMLParser: ee.
     Alternate HTML parser that offers a slightly lower-level view of
     the input, but is designed to work with XHTML, and does not
     implement some of the SGML syntax not used in "HTML as deployed"
     and which isn't legal for XHTML.

Module *note htmlentitydefs: ec.
     Definition of replacement text for XHTML 1.0  entities.

Module *note sgmllib: 151.
     Base class for *note HTMLParser: ee.

* Menu:

* HTMLParser Objects::

  ---------- Footnotes ----------

  (1) http://tools.ietf.org/html/rfc1866.html


File: python.info,  Node: HTMLParser Objects,  Up: htmllib --- A parser for HTML documents

5.19.3.1 HTMLParser Objects
...........................

In addition to tag methods, the *note HTMLParser: ee. class provides
some additional methods and instance variables for use within tag
methods.

 -- Attribute: HTMLParser.formatter
     This is the formatter instance associated with the parser.

 -- Attribute: HTMLParser.nofill
     Boolean flag which should be true when whitespace should not be
     collapsed, or false when it should be.  In general, this should
     only be true when character data is to be treated as
     "preformatted" text, as within a `<PRE>' element.  The default
     value is false.  This affects the operation of `handle_data()' and
     *note save_end(): 19a5.

 -- Method: HTMLParser.anchor_bgn (href, name, type)
     This method is called at the start of an anchor region.  The
     arguments correspond to the attributes of the `<A>' tag with the
     same names.  The default implementation maintains a list of
     hyperlinks (defined by the `HREF' attribute for `<A>' tags) within
     the document.  The list of hyperlinks is available as the data
     attribute `anchorlist'.

 -- Method: HTMLParser.anchor_end ()
     This method is called at the end of an anchor region.  The default
     implementation adds a textual footnote marker using an index into
     the list of hyperlinks created by *note anchor_bgn(): 19a6.

 -- Method: HTMLParser.handle_image (source, alt[, ismap[, align[,
          width[, height]]]])
     This method is called to handle images.  The default
     implementation simply passes the _alt_ value to the
     `handle_data()' method.

 -- Method: HTMLParser.save_bgn ()
     Begins saving character data in a buffer instead of sending it to
     the formatter object.  Retrieve the stored data via *note
     save_end(): 19a5. Use of the *note save_bgn(): 19a9. / *note
     save_end(): 19a5. pair may not be nested.

 -- Method: HTMLParser.save_end ()
     Ends buffering character data and returns all data saved since the
     preceding call to *note save_bgn(): 19a9.  If the *note nofill:
     19a4. flag is false, whitespace is collapsed to single spaces.  A
     call to this method without a preceding call to *note save_bgn():
     19a9. will raise a *note TypeError: 215. exception.


File: python.info,  Node: htmlentitydefs --- Definitions of HTML general entities,  Next: xml parsers expat --- Fast XML parsing using Expat,  Prev: htmllib --- A parser for HTML documents,  Up: Structured Markup Processing Tools

5.19.4 `htmlentitydefs' -- Definitions of HTML general entities
---------------------------------------------------------------

     Note: The *note htmlentitydefs: ec. module has been renamed to
     `html.entities' in Python 3.0.  The *note 2to3: bbf. tool will
     automatically adapt imports when converting your sources to 3.0.

This module defines three dictionaries, `name2codepoint',
`codepoint2name', and `entitydefs'. `entitydefs' is used by the *note
htmllib: ed. module to provide the *note entitydefs: 19ab. member of
the *note HTMLParser: ee. class.  The definition provided here contains
all the entities defined by XHTML 1.0  that can be handled using simple
textual substitution in the Latin-1 character set (ISO-8859-1).

 -- Data: htmlentitydefs.entitydefs
     A dictionary mapping XHTML 1.0 entity definitions to their
     replacement text in ISO Latin-1.

 -- Data: htmlentitydefs.name2codepoint
     A dictionary that maps HTML entity names to the Unicode codepoints.

     New in version 2.3.

 -- Data: htmlentitydefs.codepoint2name
     A dictionary that maps Unicode codepoints to HTML entity names.

     New in version 2.3.


File: python.info,  Node: xml parsers expat --- Fast XML parsing using Expat,  Next: xml dom --- The Document Object Model API,  Prev: htmlentitydefs --- Definitions of HTML general entities,  Up: Structured Markup Processing Tools

5.19.5 `xml.parsers.expat' -- Fast XML parsing using Expat
----------------------------------------------------------

New in version 2.0.

  The *note xml.parsers.expat: 1a5. module is a Python interface to the
Expat non-validating XML parser. The module provides a single extension
type, `xmlparser', that represents the current state of an XML parser.
After an `xmlparser' object has been created, various attributes of the
object can be set to handler functions.  When an XML document is then
fed to the parser, the handler functions are called for the character
data and markup in the XML document.

  This module uses the `pyexpat' module to provide access to the Expat
parser.  Direct use of the `pyexpat' module is deprecated.

  This module provides one exception and one type object:

 -- Exception: xml.parsers.expat.ExpatError
     The exception raised when Expat reports an error.  See section
     *note ExpatError Exceptions: 19b1. for more information on
     interpreting Expat errors.

 -- Exception: xml.parsers.expat.error
     Alias for *note ExpatError: 19b0.

 -- Data: xml.parsers.expat.XMLParserType
     The type of the return values from the *note ParserCreate(): 19b4.
     function.

  The *note xml.parsers.expat: 1a5. module contains two functions:

 -- Function: xml.parsers.expat.ErrorString (errno)
     Returns an explanatory string for a given error number _errno_.

 -- Function: xml.parsers.expat.ParserCreate ([encoding[,
          namespace_separator]])
     Creates and returns a new `xmlparser' object.   _encoding_, if
     specified, must be a string naming the encoding  used by the XML
     data.  Expat doesn't support as many encodings as Python does, and
     its repertoire of encodings can't be extended; it supports UTF-8,
     UTF-16, ISO-8859-1 (Latin1), and ASCII.  If _encoding_ (1) is
     given it will override the implicit or explicit encoding of the
     document.

     Expat can optionally do XML namespace processing for you, enabled
     by providing a value for _namespace_separator_.  The value must be
     a one-character string; a *note ValueError: 233. will be raised if
     the string has an illegal length (`None' is considered the same as
     omission).  When namespace processing is enabled, element type
     names and attribute names that belong to a namespace will be
     expanded.  The element name passed to the element handlers
     `StartElementHandler' and `EndElementHandler' will be the
     concatenation of the namespace URI, the namespace separator
     character, and the local part of the name.  If the namespace
     separator is a zero byte (`chr(0)') then the namespace URI and the
     local part will be concatenated without any separator.

     For example, if _namespace_separator_ is set to a space character
     (`' '') and the following document is parsed:

         <?xml version="1.0"?>
         <root xmlns    = "http://default-namespace.org/"
               xmlns:py = "http://www.python.org/ns/">
           <py:elem1 />
           <elem2 xmlns="" />
         </root>

     `StartElementHandler' will receive the following strings for each
     element:

         http://default-namespace.org/ root
         http://www.python.org/ns/ elem1
         elem2



See also
........

The Expat XML Parser(2)
     Home page of the Expat project.

* Menu:

* XMLParser Objects::
* ExpatError Exceptions::
* Example: Example<9>.
* Content Model Descriptions::
* Expat error constants::

  ---------- Footnotes ----------

  (1) The encoding string included in XML output should conform to the
appropriate standards. For example, "UTF-8" is valid, but "UTF8" is
not. See <http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl>
and <http://www.iana.org/assignments/character-sets> .

  (2) http://www.libexpat.org/


File: python.info,  Node: XMLParser Objects,  Next: ExpatError Exceptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.5.1 XMLParser Objects
..........................

`xmlparser' objects have the following methods:

 -- Method: xmlparser.Parse (data[, isfinal])
     Parses the contents of the string _data_, calling the appropriate
     handler functions to process the parsed data.  _isfinal_ must be
     true on the final call to this method.  _data_ can be the empty
     string at any time.

 -- Method: xmlparser.ParseFile (file)
     Parse XML data reading from the object _file_.  _file_ only needs
     to provide the `read(nbytes)' method, returning the empty string
     when there's no more data.

 -- Method: xmlparser.SetBase (base)
     Sets the base to be used for resolving relative URIs in system
     identifiers in declarations.  Resolving relative identifiers is
     left to the application: this value will be passed through as the
     _base_ argument to the *note ExternalEntityRefHandler(): 19bb,
     *note NotationDeclHandler(): 19bc, and *note
     UnparsedEntityDeclHandler(): 19bd. functions.

 -- Method: xmlparser.GetBase ()
     Returns a string containing the base set by a previous call to
     *note SetBase(): 19ba, or `None' if  *note SetBase(): 19ba. hasn't
     been called.

 -- Method: xmlparser.GetInputContext ()
     Returns the input data that generated the current event as a
     string. The data is in the encoding of the entity which contains
     the text. When called while an event handler is not active, the
     return value is `None'.

     New in version 2.1.

 -- Method: xmlparser.ExternalEntityParserCreate (context[, encoding])
     Create a "child" parser which can be used to parse an external
     parsed entity referred to by content parsed by the parent parser.
     The _context_ parameter should be the string passed to the *note
     ExternalEntityRefHandler(): 19bb. handler function, described
     below. The child parser is created with the *note
     ordered_attributes: 19c1, *note returns_unicode: 19c2. and *note
     specified_attributes: 19c3. set to the values of this parser.

 -- Method: xmlparser.SetParamEntityParsing (flag)
     Control parsing of parameter entities (including the external DTD
     subset).  Possible _flag_ values are
     `XML_PARAM_ENTITY_PARSING_NEVER',
     `XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE' and
     `XML_PARAM_ENTITY_PARSING_ALWAYS'.  Return true if setting the flag
     was successful.

 -- Method: xmlparser.UseForeignDTD ([flag])
     Calling this with a true value for _flag_ (the default) will cause
     Expat to call the *note ExternalEntityRefHandler: 19bb. with *note
     None: 389. for all arguments to allow an alternate DTD to be
     loaded.  If the document does not contain a document type
     declaration, the *note ExternalEntityRefHandler: 19bb. will still
     be called, but the *note StartDoctypeDeclHandler: 19c6. and *note
     EndDoctypeDeclHandler: 19c7. will not be called.

     Passing a false value for _flag_ will cancel a previous call that
     passed a true value, but otherwise has no effect.

     This method can only be called before the *note Parse(): 19b8. or
     *note ParseFile(): 19b9.  methods are called; calling it after
     either of those have been called causes *note ExpatError: 19b0. to
     be raised with the *note code: 62. attribute set to
     `errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING'.

     New in version 2.3.

  `xmlparser' objects have the following attributes:

 -- Attribute: xmlparser.buffer_size
     The size of the buffer used when *note buffer_text: 19c9. is true.
     A new buffer size can be set by assigning a new integer value to
     this attribute.  When the size is changed, the buffer will be
     flushed.

     New in version 2.3.

     Changed in version 2.6: The buffer size can now be changed.

 -- Attribute: xmlparser.buffer_text
     Setting this to true causes the `xmlparser' object to buffer
     textual content returned by Expat to avoid multiple calls to the
     *note CharacterDataHandler(): 19ca. callback whenever possible.
     This can improve performance substantially since Expat normally
     breaks character data into chunks at every line ending.  This
     attribute is false by default, and may be changed at any time.

     New in version 2.3.

 -- Attribute: xmlparser.buffer_used
     If *note buffer_text: 19c9. is enabled, the number of bytes stored
     in the buffer.  These bytes represent UTF-8 encoded text.  This
     attribute has no meaningful interpretation when *note buffer_text:
     19c9. is false.

     New in version 2.3.

 -- Attribute: xmlparser.ordered_attributes
     Setting this attribute to a non-zero integer causes the attributes
     to be reported as a list rather than a dictionary.  The attributes
     are presented in the order found in the document text.  For each
     attribute, two list entries are presented: the attribute name and
     the attribute value.  (Older versions of this module also used
     this format.)  By default, this attribute is false; it may be
     changed at any time.

     New in version 2.1.

 -- Attribute: xmlparser.returns_unicode
     If this attribute is set to a non-zero integer, the handler
     functions will be passed Unicode strings.  If *note
     returns_unicode: 19c2. is *note False: 3a0, 8-bit strings
     containing UTF-8 encoded data will be passed to the handlers.
     This is *note True: 39f. by default when Python is built with
     Unicode support.

     Changed in version 1.6: Can be changed at any time to affect the
     result type.

 -- Attribute: xmlparser.specified_attributes
     If set to a non-zero integer, the parser will report only those
     attributes which were specified in the document instance and not
     those which were derived from attribute declarations.
     Applications which set this need to be especially careful to use
     what additional information is available from the declarations as
     needed to comply with the standards for the behavior of XML
     processors.  By default, this attribute is false; it may be
     changed at any time.

     New in version 2.1.

  The following attributes contain values relating to the most recent
error encountered by an `xmlparser' object, and will only have correct
values once a call to `Parse()' or `ParseFile()' has raised a *note
xml.parsers.expat.ExpatError: 19b0. exception.

 -- Attribute: xmlparser.ErrorByteIndex
     Byte index at which an error occurred.

 -- Attribute: xmlparser.ErrorCode
     Numeric code specifying the problem.  This value can be passed to
     the *note ErrorString(): 19b5. function, or compared to one of the
     constants defined in the `errors' object.

 -- Attribute: xmlparser.ErrorColumnNumber
     Column number at which an error occurred.

 -- Attribute: xmlparser.ErrorLineNumber
     Line number at which an error occurred.

  The following attributes contain values relating to the current parse
location in an `xmlparser' object.  During a callback reporting a parse
event they indicate the location of the first of the sequence of
characters that generated the event.  When called outside of a
callback, the position indicated will be just past the last parse event
(regardless of whether there was an associated callback).

  New in version 2.4.

 -- Attribute: xmlparser.CurrentByteIndex
     Current byte index in the parser input.

 -- Attribute: xmlparser.CurrentColumnNumber
     Current column number in the parser input.

 -- Attribute: xmlparser.CurrentLineNumber
     Current line number in the parser input.

  Here is the list of handlers that can be set.  To set a handler on an
`xmlparser' object _o_, use `o.handlername = func'.  _handlername_ must
be taken from the following list, and _func_ must be a callable object
accepting the correct number of arguments.  The arguments are all
strings, unless otherwise stated.

 -- Method: xmlparser.XmlDeclHandler (version, encoding, standalone)
     Called when the XML declaration is parsed.  The XML declaration is
     the (optional) declaration of the applicable version of the XML
     recommendation, the encoding of the document text, and an optional
     "standalone" declaration.  _version_ and _encoding_ will be
     strings of the type dictated by the *note returns_unicode: 19c2.
     attribute, and _standalone_ will be `1' if the document is
     declared standalone, `0' if it is declared not to be standalone,
     or `-1' if the standalone clause was omitted. This is only
     available with Expat version 1.95.0 or newer.

     New in version 2.1.

 -- Method: xmlparser.StartDoctypeDeclHandler (doctypeName, systemId,
          publicId, has_internal_subset)
     Called when Expat begins parsing the document type declaration
     (`<!DOCTYPE ...').  The _doctypeName_ is provided exactly as
     presented.  The _systemId_ and _publicId_ parameters give the
     system and public identifiers if specified, or `None' if omitted.
     _has_internal_subset_ will be true if the document contains and
     internal document declaration subset. This requires Expat version
     1.2 or newer.

 -- Method: xmlparser.EndDoctypeDeclHandler ()
     Called when Expat is done parsing the document type declaration.
     This requires Expat version 1.2 or newer.

 -- Method: xmlparser.ElementDeclHandler (name, model)
     Called once for each element type declaration.  _name_ is the name
     of the element type, and _model_ is a representation of the
     content model.

 -- Method: xmlparser.AttlistDeclHandler (elname, attname, type,
          default, required)
     Called for each declared attribute for an element type.  If an
     attribute list declaration declares three attributes, this handler
     is called three times, once for each attribute.  _elname_ is the
     name of the element to which the declaration applies and _attname_
     is the name of the attribute declared.  The attribute type is a
     string passed as _type_; the possible values are `'CDATA'',
     `'ID'', `'IDREF'', ... _default_ gives the default value for the
     attribute used when the attribute is not specified by the document
     instance, or `None' if there is no default value (`#IMPLIED'
     values).  If the attribute is required to be given in the document
     instance, _required_ will be true. This requires Expat version
     1.95.0 or newer.

 -- Method: xmlparser.StartElementHandler (name, attributes)
     Called for the start of every element.  _name_ is a string
     containing the element name, and _attributes_ is a dictionary
     mapping attribute names to their values.

 -- Method: xmlparser.EndElementHandler (name)
     Called for the end of every element.

 -- Method: xmlparser.ProcessingInstructionHandler (target, data)
     Called for every processing instruction.

 -- Method: xmlparser.CharacterDataHandler (data)
     Called for character data.  This will be called for normal
     character data, CDATA marked content, and ignorable whitespace.
     Applications which must distinguish these cases can use the *note
     StartCdataSectionHandler: 19d9, *note EndCdataSectionHandler:
     19da, and *note ElementDeclHandler: 19d4. callbacks to collect the
     required information.

 -- Method: xmlparser.UnparsedEntityDeclHandler (entityName, base,
          systemId, publicId, notationName)
     Called for unparsed (NDATA) entity declarations.  This is only
     present for version 1.2 of the Expat library; for more recent
     versions, use *note EntityDeclHandler: 19db. instead.  (The
     underlying function in the Expat library has been declared
     obsolete.)

 -- Method: xmlparser.EntityDeclHandler (entityName,
          is_parameter_entity, value, base, systemId, publicId,
          notationName)
     Called for all entity declarations.  For parameter and internal
     entities, _value_ will be a string giving the declared contents of
     the entity; this will be `None' for external entities.  The
     _notationName_ parameter will be `None' for parsed entities, and
     the name of the notation for unparsed entities.
     _is_parameter_entity_ will be true if the entity is a parameter
     entity or false for general entities (most applications only need
     to be concerned with general entities). This is only available
     starting with version 1.95.0 of the Expat library.

     New in version 2.1.

 -- Method: xmlparser.NotationDeclHandler (notationName, base,
          systemId, publicId)
     Called for notation declarations.  _notationName_, _base_, and
     _systemId_, and _publicId_ are strings if given.  If the public
     identifier is omitted, _publicId_ will be `None'.

 -- Method: xmlparser.StartNamespaceDeclHandler (prefix, uri)
     Called when an element contains a namespace declaration.
     Namespace declarations are processed before the *note
     StartElementHandler: 19d6. is called for the element on which
     declarations are placed.

 -- Method: xmlparser.EndNamespaceDeclHandler (prefix)
     Called when the closing tag is reached for an element  that
     contained a namespace declaration.  This is called once for each
     namespace declaration on the element in the reverse of the order
     for which the *note StartNamespaceDeclHandler: 19dc. was called to
     indicate the start of each namespace declaration's scope.  Calls
     to this handler are made after the corresponding *note
     EndElementHandler: 19d7. for the end of the element.

 -- Method: xmlparser.CommentHandler (data)
     Called for comments.  _data_ is the text of the comment, excluding
     the leading '`<!-'`-'' and trailing '`-'`->''.

 -- Method: xmlparser.StartCdataSectionHandler ()
     Called at the start of a CDATA section.  This and *note
     EndCdataSectionHandler: 19da.  are needed to be able to identify
     the syntactical start and end for CDATA sections.

 -- Method: xmlparser.EndCdataSectionHandler ()
     Called at the end of a CDATA section.

 -- Method: xmlparser.DefaultHandler (data)
     Called for any characters in the XML document for which no
     applicable handler has been specified.  This means characters that
     are part of a construct which could be reported, but for which no
     handler has been supplied.

 -- Method: xmlparser.DefaultHandlerExpand (data)
     This is the same as the *note DefaultHandler(): 19df,  but doesn't
     inhibit expansion of internal entities. The entity reference will
     not be passed to the default handler.

 -- Method: xmlparser.NotStandaloneHandler ()
     Called if the XML document hasn't been declared as being a
     standalone document.  This happens when there is an external
     subset or a reference to a parameter entity, but the XML
     declaration does not set standalone to `yes' in an XML
     declaration.  If this handler returns `0', then the parser will
     raise an `XML_ERROR_NOT_STANDALONE' error.  If this handler is not
     set, no exception is raised by the parser for this condition.

 -- Method: xmlparser.ExternalEntityRefHandler (context, base,
          systemId, publicId)
     Called for references to external entities.  _base_ is the current
     base, as set by a previous call to *note SetBase(): 19ba.  The
     public and system identifiers, _systemId_ and _publicId_, are
     strings if given; if the public identifier is not given,
     _publicId_ will be `None'.  The _context_ value is opaque and
     should only be used as described below.

     For external entities to be parsed, this handler must be
     implemented. It is responsible for creating the sub-parser using
     `ExternalEntityParserCreate(context)', initializing it with the
     appropriate callbacks, and parsing the entity.  This handler
     should return an integer; if it returns `0', the parser will raise
     an `XML_ERROR_EXTERNAL_ENTITY_HANDLING' error, otherwise parsing
     will continue.

     If this handler is not provided, external entities are reported by
     the *note DefaultHandler: 19df. callback, if provided.


File: python.info,  Node: ExpatError Exceptions,  Next: Example<9>,  Prev: XMLParser Objects,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.5.2 ExpatError Exceptions
..............................

*note ExpatError: 19b0. exceptions have a number of interesting
attributes:

 -- Attribute: ExpatError.code
     Expat's internal error number for the specific error.  This will
     match one of the constants defined in the `errors' object from
     this module.

     New in version 2.1.

 -- Attribute: ExpatError.lineno
     Line number on which the error was detected.  The first line is
     numbered `1'.

     New in version 2.1.

 -- Attribute: ExpatError.offset
     Character offset into the line where the error occurred.  The
     first column is numbered `0'.

     New in version 2.1.


File: python.info,  Node: Example<9>,  Next: Content Model Descriptions,  Prev: ExpatError Exceptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.5.3 Example
................

The following program defines three handlers that just print out their
arguments.

    import xml.parsers.expat

    # 3 handler functions
    def start_element(name, attrs):
        print 'Start element:', name, attrs
    def end_element(name):
        print 'End element:', name
    def char_data(data):
        print 'Character data:', repr(data)

    p = xml.parsers.expat.ParserCreate()

    p.StartElementHandler = start_element
    p.EndElementHandler = end_element
    p.CharacterDataHandler = char_data

    p.Parse("""<?xml version="1.0"?>
    <parent id="top"><child1 name="paul">Text goes here</child1>
    <child2 name="fred">More text</child2>
    </parent>""", 1)

The output from this program is:

    Start element: parent {'id': 'top'}
    Start element: child1 {'name': 'paul'}
    Character data: 'Text goes here'
    End element: child1
    Character data: '\n'
    Start element: child2 {'name': 'fred'}
    Character data: 'More text'
    End element: child2
    Character data: '\n'
    End element: parent



File: python.info,  Node: Content Model Descriptions,  Next: Expat error constants,  Prev: Example<9>,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.5.4 Content Model Descriptions
...................................

Content modules are described using nested tuples.  Each tuple contains
four values: the type, the quantifier, the name, and a tuple of
children.  Children are simply additional content module descriptions.

  The values of the first two fields are constants defined in the
`model' object of the *note xml.parsers.expat: 1a5. module.  These
constants can be collected in two groups: the model type group and the
quantifier group.

  The constants in the model type group are:

 -- Data: xml.parsers.expat.XML_CTYPE_ANY
     The element named by the model name was declared to have a content
     model of `ANY'.

 -- Data: xml.parsers.expat.XML_CTYPE_CHOICE
     The named element allows a choice from a number of options; this
     is used for content models such as `(A | B | C)'.

 -- Data: xml.parsers.expat.XML_CTYPE_EMPTY
     Elements which are declared to be `EMPTY' have this model type.

 -- Data: xml.parsers.expat.XML_CTYPE_MIXED

 -- Data: xml.parsers.expat.XML_CTYPE_NAME

 -- Data: xml.parsers.expat.XML_CTYPE_SEQ
     Models which represent a series of models which follow one after
     the other are indicated with this model type.  This is used for
     models such as `(A, B, C)'.

  The constants in the quantifier group are:

 -- Data: xml.parsers.expat.XML_CQUANT_NONE
     No modifier is given, so it can appear exactly once, as for `A'.

 -- Data: xml.parsers.expat.XML_CQUANT_OPT
     The model is optional: it can appear once or not at all, as for
     `A?'.

 -- Data: xml.parsers.expat.XML_CQUANT_PLUS
     The model must occur one or more times (like `A+').

 -- Data: xml.parsers.expat.XML_CQUANT_REP
     The model must occur zero or more times, as for `A*'.


File: python.info,  Node: Expat error constants,  Prev: Content Model Descriptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.5.5 Expat error constants
..............................

The following constants are provided in the `errors' object of the
*note xml.parsers.expat: 1a5. module.  These constants are useful in
interpreting some of the attributes of the *note ExpatError: 19b0.
exception objects raised when an error has occurred.

  The `errors' object has the following attributes:

 -- Data: xml.parsers.expat.XML_ERROR_ASYNC_ENTITY

 -- Data: xml.parsers.expat.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF
     An entity reference in an attribute value referred to an external
     entity instead of an internal entity.

 -- Data: xml.parsers.expat.XML_ERROR_BAD_CHAR_REF
     A character reference referred to a character which is illegal in
     XML (for example, character `0', or '`&#0;'').

 -- Data: xml.parsers.expat.XML_ERROR_BINARY_ENTITY_REF
     An entity reference referred to an entity which was declared with
     a notation, so cannot be parsed.

 -- Data: xml.parsers.expat.XML_ERROR_DUPLICATE_ATTRIBUTE
     An attribute was used more than once in a start tag.

 -- Data: xml.parsers.expat.XML_ERROR_INCORRECT_ENCODING

 -- Data: xml.parsers.expat.XML_ERROR_INVALID_TOKEN
     Raised when an input byte could not properly be assigned to a
     character; for example, a NUL byte (value `0') in a UTF-8 input
     stream.

 -- Data: xml.parsers.expat.XML_ERROR_JUNK_AFTER_DOC_ELEMENT
     Something other than whitespace occurred after the document
     element.

 -- Data: xml.parsers.expat.XML_ERROR_MISPLACED_XML_PI
     An XML declaration was found somewhere other than the start of the
     input data.

 -- Data: xml.parsers.expat.XML_ERROR_NO_ELEMENTS
     The document contains no elements (XML requires all documents to
     contain exactly one top-level element)..

 -- Data: xml.parsers.expat.XML_ERROR_NO_MEMORY
     Expat was not able to allocate memory internally.

 -- Data: xml.parsers.expat.XML_ERROR_PARAM_ENTITY_REF
     A parameter entity reference was found where it was not allowed.

 -- Data: xml.parsers.expat.XML_ERROR_PARTIAL_CHAR
     An incomplete character was found in the input.

 -- Data: xml.parsers.expat.XML_ERROR_RECURSIVE_ENTITY_REF
     An entity reference contained another reference to the same
     entity; possibly via a different name, and possibly indirectly.

 -- Data: xml.parsers.expat.XML_ERROR_SYNTAX
     Some unspecified syntax error was encountered.

 -- Data: xml.parsers.expat.XML_ERROR_TAG_MISMATCH
     An end tag did not match the innermost open start tag.

 -- Data: xml.parsers.expat.XML_ERROR_UNCLOSED_TOKEN
     Some token (such as a start tag) was not closed before the end of
     the stream or the next token was encountered.

 -- Data: xml.parsers.expat.XML_ERROR_UNDEFINED_ENTITY
     A reference was made to a entity which was not defined.

 -- Data: xml.parsers.expat.XML_ERROR_UNKNOWN_ENCODING
     The document encoding is not supported by Expat.

 -- Data: xml.parsers.expat.XML_ERROR_UNCLOSED_CDATA_SECTION
     A CDATA marked section was not closed.

 -- Data: xml.parsers.expat.XML_ERROR_EXTERNAL_ENTITY_HANDLING

 -- Data: xml.parsers.expat.XML_ERROR_NOT_STANDALONE
     The parser determined that the document was not "standalone"
     though it declared itself to be in the XML declaration, and the
     `NotStandaloneHandler' was set and returned `0'.

 -- Data: xml.parsers.expat.XML_ERROR_UNEXPECTED_STATE

 -- Data: xml.parsers.expat.XML_ERROR_ENTITY_DECLARED_IN_PE

 -- Data: xml.parsers.expat.XML_ERROR_FEATURE_REQUIRES_XML_DTD
     An operation was requested that requires DTD support to be
     compiled in, but Expat was configured without DTD support.  This
     should never be reported by a standard build of the *note
     xml.parsers.expat: 1a5. module.

 -- Data: xml.parsers.expat.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING
     A behavioral change was requested after parsing started that can
     only be changed before parsing has started.  This is (currently)
     only raised by `UseForeignDTD()'.

 -- Data: xml.parsers.expat.XML_ERROR_UNBOUND_PREFIX
     An undeclared prefix was found when namespace processing was
     enabled.

 -- Data: xml.parsers.expat.XML_ERROR_UNDECLARING_PREFIX
     The document attempted to remove the namespace declaration
     associated with a prefix.

 -- Data: xml.parsers.expat.XML_ERROR_INCOMPLETE_PE
     A parameter entity contained incomplete markup.

 -- Data: xml.parsers.expat.XML_ERROR_XML_DECL
     The document contained no document element at all.

 -- Data: xml.parsers.expat.XML_ERROR_TEXT_DECL
     There was an error parsing a text declaration in an external
     entity.

 -- Data: xml.parsers.expat.XML_ERROR_PUBLICID
     Characters were found in the public id that are not allowed.

 -- Data: xml.parsers.expat.XML_ERROR_SUSPENDED
     The requested operation was made on a suspended parser, but isn't
     allowed.  This includes attempts to provide additional input or to
     stop the parser.

 -- Data: xml.parsers.expat.XML_ERROR_NOT_SUSPENDED
     An attempt to resume the parser was made when the parser had not
     been suspended.

 -- Data: xml.parsers.expat.XML_ERROR_ABORTED
     This should not be reported to Python applications.

 -- Data: xml.parsers.expat.XML_ERROR_FINISHED
     The requested operation was made on a parser which was finished
     parsing input, but isn't allowed.  This includes attempts to
     provide additional input or to stop the parser.

 -- Data: xml.parsers.expat.XML_ERROR_SUSPEND_PE


File: python.info,  Node: xml dom --- The Document Object Model API,  Next: xml dom minidom --- Lightweight DOM implementation,  Prev: xml parsers expat --- Fast XML parsing using Expat,  Up: Structured Markup Processing Tools

5.19.6 `xml.dom' -- The Document Object Model API
-------------------------------------------------

New in version 2.0.

  The Document Object Model, or "DOM," is a cross-language API from the
World Wide Web Consortium (W3C) for accessing and modifying XML
documents.  A DOM implementation presents an XML document as a tree
structure, or allows client code to build such a structure from
scratch.  It then gives access to the structure through a set of
objects which provided well-known interfaces.

  The DOM is extremely useful for random-access applications.  SAX only
allows you a view of one bit of the document at a time.  If you are
looking at one SAX element, you have no access to another.  If you are
looking at a text node, you have no access to a containing element.
When you write a SAX application, you need to keep track of your
program's position in the document somewhere in your own code.  SAX
does not do it for you.  Also, if you need to look ahead in the XML
document, you are just out of luck.

  Some applications are simply impossible in an event driven model with
no access to a tree.  Of course you could build some sort of tree
yourself in SAX events, but the DOM allows you to avoid writing that
code.  The DOM is a standard tree representation for XML data.

  The Document Object Model is being defined by the W3C in stages, or
"levels" in their terminology.  The Python mapping of the API is
substantially based on the DOM Level 2 recommendation.

  DOM applications typically start by parsing some XML into a DOM.  How
this is accomplished is not covered at all by DOM Level 1, and Level 2
provides only limited improvements: There is a `DOMImplementation'
object class which provides access to `Document' creation methods, but
no way to access an XML reader/parser/Document builder in an
implementation-independent way. There is also no well-defined way to
access these methods without an existing `Document' object.  In Python,
each DOM implementation will provide a function *note
getDOMImplementation(): 19ee. DOM Level 3 adds a Load/Store
specification, which defines an interface to the reader, but this is
not yet available in the Python standard library.

  Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification; this portion of the reference manual
describes the interpretation of the specification in Python.

  The specification provided by the W3C defines the DOM API for Java,
ECMAScript, and OMG IDL.  The Python mapping defined here is based in
large part on the IDL version of the specification, but strict
compliance is not required (though implementations are free to support
the strict mapping from IDL).  See section *note Conformance: 19ef. for
a detailed discussion of mapping requirements.

See also
........

Document Object Model (DOM) Level 2 Specification(1)
     The W3C recommendation upon which the Python DOM API is based.

Document Object Model (DOM) Level 1 Specification(2)
     The W3C recommendation for the DOM supported by *note
     xml.dom.minidom: 1a2.

Python Language Mapping Specification(3)
     This specifies the mapping from OMG IDL to Python.

* Menu:

* Module Contents: Module Contents<3>.
* Objects in the DOM::
* Conformance::

  ---------- Footnotes ----------

  (1) http://www.w3.org/TR/DOM-Level-2-Core/

  (2) http://www.w3.org/TR/REC-DOM-Level-1/

  (3) http://www.omg.org/spec/PYTH/1.2/PDF


File: python.info,  Node: Module Contents<3>,  Next: Objects in the DOM,  Up: xml dom --- The Document Object Model API

5.19.6.1 Module Contents
........................

The *note xml.dom: 1a1. contains the following functions:

 -- Function: xml.dom.registerDOMImplementation (name, factory)
     Register the _factory_ function with the name _name_.  The factory
     function should return an object which implements the
     `DOMImplementation' interface.  The factory function can return
     the same object every time, or a new one for each call, as
     appropriate for the specific implementation (e.g. if that
     implementation supports some customization).

 -- Function: xml.dom.getDOMImplementation ([name[, features]])
     Return a suitable DOM implementation. The _name_ is either
     well-known, the module name of a DOM implementation, or `None'. If
     it is not `None', imports the corresponding module and returns a
     `DOMImplementation' object if the import succeeds.  If no name is
     given, and if the environment variable `PYTHON_DOM' is set, this
     variable is used to find the implementation.

     If name is not given, this examines the available implementations
     to find one with the required feature set.  If no implementation
     can be found, raise an *note ImportError: 35f.  The features list
     must be a sequence of `(feature, version)' pairs which are passed
     to the `hasFeature()' method on available `DOMImplementation'
     objects.

  Some convenience constants are also provided:

 -- Data: xml.dom.EMPTY_NAMESPACE
     The value used to indicate that no namespace is associated with a
     node in the DOM.  This is typically found as the `namespaceURI' of
     a node, or used as the _namespaceURI_ parameter to a
     namespaces-specific method.

     New in version 2.2.

 -- Data: xml.dom.XML_NAMESPACE
     The namespace URI associated with the reserved prefix `xml', as
     defined by Namespaces in XML(1) (section 4).

     New in version 2.2.

 -- Data: xml.dom.XMLNS_NAMESPACE
     The namespace URI for namespace declarations, as defined by
     Document Object Model (DOM) Level 2 Core Specification(2) (section
     1.1.8).

     New in version 2.2.

 -- Data: xml.dom.XHTML_NAMESPACE
     The URI of the XHTML namespace as defined by XHTML 1.0: The
     Extensible HyperText Markup Language(3) (section 3.1.1).

     New in version 2.2.

  In addition, *note xml.dom: 1a1. contains a base `Node' class and the
DOM exception classes.  The `Node' class provided by this module does
not implement any of the methods or attributes defined by the DOM
specification; concrete DOM implementations must provide those.  The
`Node' class provided as part of this module does provide the constants
used for the `nodeType' attribute on concrete `Node' objects; they are
located within the class rather than at the module level to conform
with the DOM specifications.

  ---------- Footnotes ----------

  (1) http://www.w3.org/TR/REC-xml-names/

  (2) http://www.w3.org/TR/DOM-Level-2-Core/core.html

  (3) http://www.w3.org/TR/xhtml1/


File: python.info,  Node: Objects in the DOM,  Next: Conformance,  Prev: Module Contents<3>,  Up: xml dom --- The Document Object Model API

5.19.6.2 Objects in the DOM
...........................

The definitive documentation for the DOM is the DOM specification from
the W3C.

  Note that DOM attributes may also be manipulated as nodes instead of
as simple strings.  It is fairly rare that you must do this, however,
so this usage is not yet documented.

Interface                            Section                                 Purpose
------------------------------------------------------------------------------------------------------------------- 
`DOMImplementation'                  *note DOMImplementation Objects: 19f8.  Interface to the underlying
                                                                             implementation.
`Node'                               *note Node Objects: 19f9.               Base interface for most objects in a
                                                                             document.
`NodeList'                           *note NodeList Objects: 19fa.           Interface for a sequence of nodes.
`DocumentType'                       *note DocumentType Objects: 19fb.       Information about the declarations
                                                                             needed to process a document.
`Document'                           *note Document Objects: 19fc.           Object which represents an entire
                                                                             document.
`Element'                            *note Element Objects: 19fd.            Element nodes in the document
                                                                             hierarchy.
`Attr'                               *note Attr Objects: 19fe.               Attribute value nodes on element
                                                                             nodes.
`Comment'                            *note Comment Objects: 19ff.            Representation of comments in the
                                                                             source document.
`Text'                               *note Text and CDATASection Objects:    Nodes containing textual content
                                     1a00.                                   from the document.
`ProcessingInstruction'              *note ProcessingInstruction Objects:    Processing instruction
                                     1a01.                                   representation.

  An additional section describes the exceptions defined for working
with the DOM in Python.

* Menu:

* DOMImplementation Objects::
* Node Objects::
* NodeList Objects::
* DocumentType Objects::
* Document Objects::
* Element Objects::
* Attr Objects::
* NamedNodeMap Objects::
* Comment Objects::
* Text and CDATASection Objects::
* ProcessingInstruction Objects::
* Exceptions: Exceptions<6>.

